<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://javayong.cn/atom.xsl"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN">
  <id>https://javayong.cn/</id>
  <title>勇哥Java实战</title>
  <subtitle>Java 基础、高并发三剑客（缓存、消息队列、分库分表）、实战项目讲解。</subtitle>
  <icon>https://javayong.cn/favicon.ico</icon>
  <updated>2023-11-20T07:24:06.300Z</updated>
  <generator>vuepress-plugin-feed2</generator>
  <link rel="self" href="https://javayong.cn/atom.xml"/>
  <link rel="alternate" href="https://javayong.cn/"/>
  <category term="技术人生"/>
  <category term="cache"/>
  <category term="RocketMQ"/>
  <entry>
    <title type="text">聊聊我与流式计算的故事</title>
    <id>https://javayong.cn/codelife/guotuxuexistorm.html</id>
    <link href="https://javayong.cn/codelife/guotuxuexistorm.html"/>
    <updated>2023-11-20T07:14:27.000Z</updated>
    <summary type="html"><![CDATA[<p>聊聊流式计算吧 , 那一段经历于我而言很精彩，很有趣，想把这段经历分享给大家。</p>
<h2> <strong>1 背景介绍</strong></h2>
<p>2014年，我在艺龙旅行网促销团队负责红包系统。</p>
<p>彼时，促销大战如火如荼，<strong>优惠券计算服务</strong>也成为艺龙促销业务中最重要的服务之一。</p>
<p>而优惠券计算服务正是采用当时大名鼎鼎的<strong>流式计算框架</strong> <strong>Storm</strong>。</p>
<blockquote>
<p>流式计算是利用分布式的思想和方法，对海量“流”式数据进行<strong>实时处理</strong>的系统，它源自对海量数据**“时效”**价值上的挖掘诉求。</p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<p>聊聊流式计算吧 , 那一段经历于我而言很精彩，很有趣，想把这段经历分享给大家。</p>
<h2> <strong>1 背景介绍</strong></h2>
<p>2014年，我在艺龙旅行网促销团队负责红包系统。</p>
<p>彼时，促销大战如火如荼，<strong>优惠券计算服务</strong>也成为艺龙促销业务中最重要的服务之一。</p>
<p>而优惠券计算服务正是采用当时大名鼎鼎的<strong>流式计算框架</strong> <strong>Storm</strong>。</p>
<blockquote>
<p>流式计算是利用分布式的思想和方法，对海量“流”式数据进行<strong>实时处理</strong>的系统，它源自对海量数据**“时效”**价值上的挖掘诉求。</p>
</blockquote>
<p>优惠券计算服务的逻辑是：每个城市每个酒店的使用优惠券的规则并不相同，当运营人员修改规则之后，触发优惠券计算服务，计算完成之后，用户下单时在使用优惠券时会呈现最新的规则。</p>
<p>优惠券计算服务是我们团队的明星项目，很多研发的同学都对 Storm 特别感兴趣 , 因为 Storm 的核心开发语言是 <strong>clojure</strong> ， 比较小众。</p>
<p>于是，在团队内部，发现一个很有趣的现象：<strong>很多同学的办公桌上放着《clojure in Action 》这本书</strong>。</p>
<figure><img src="https://pic2.zhimg.com/80/v2-8c80900e0c323c7bce88fb8843aff1a9_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>clojure in Action</p>
<p>彼时，艺龙开始发力移动互联网，业务量的激增，优惠券计算服务开始遇到了瓶颈。</p>
<p>比如运营人员修改全量规则时，整个计算流程要耗时一上午，也就谈不上<strong>实时计算</strong>了。</p>
<p>CTO 几次找团队负责人，并严厉批责成他尽快优化。经过一个半月几次优化，系统的瓶颈依然明显，时不时运营同事会走到我们的工位附近，催促我们：“系统生效了么？ ”</p>
<p>我并不负责计算服务，每当同事被质疑时，我都感到很疑惑：<strong>“优惠券计算服务真的那么复杂吗？ ”</strong> ， 同时也跃跃欲试：“ <strong>Storm 真有那么难搞吗</strong>？”</p>
<p>我心中暗暗下定了决心，一定要弄清楚优惠券计算服务的逻辑 。</p>
<h2> <strong>2 国图学习</strong></h2>
<p>北京有很多景点都让我流连忘返，比如史铁生小说里的地坛，满山枫叶的香山，如诗如画的颐和园，美仑美奂的天坛 。</p>
<p>在我心里，有一处很神圣的地方，它是知识和希望的象征，那就是<strong>国家图书馆</strong> 。</p>
<figure><img src="https://pic3.zhimg.com/80/v2-be9271da30a9dab6f3dc0a739769e1de_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>中国国家图书馆位于北京市中关村南大街33号，与海淀区白石桥高粱河、紫竹院公园相邻。<strong>它是国家总书库，国家书目中心，国家古籍保护中心，同时也是世界最大、最先进的国家图书馆之一</strong> 。</p>
<p>每到周末，当我想安静下来，专注思考时，我就会背着笔记本电脑来到国家图书馆。</p>
<p><strong>选择自己喜欢的书，然后将笔记本电脑打开，一边看书，一边在电脑上写点笔记。</strong></p>
<p><strong>偶尔抬起头，望着那些正在阅读的读者，心里面感觉很阳关，觉得生命充满了希望。</strong></p>
<p>我并不负责流式计算服务，但想要揭开 Storm 神秘面纱的探索欲，同时探寻优惠券计算服务为什么会这么慢的渴望，让我好几天晚上没睡好。</p>
<p>于是周六上午9点半， 我来到国家图书馆 ，想让自己安静下来，思考如何解决这个问题。解决问题的快感，是我一直追求的。</p>
<p>当我把笔记本电脑放平在桌上，我很兴奋，同时灵台一片澄清：优惠券计算服务的核心是 Storm ，那么<strong>我需要先了解 Storm 的整体概念</strong>。</p>
<p>打开官网，浏览官网的文档，第一次看到 Storm 的逻辑流程图时， <strong>做为程序员，我第一次竟然感受到抽象之美</strong>：从源头流下来的水通过水龙头（ <strong>Spout</strong> ），再经过层层转接头( <strong>Bolt</strong> )过滤，不就是我们想要的纯净水吗？</p>
<figure><img src="https://pic1.zhimg.com/80/v2-a4977cee51bb48192c724dbdf0f009fc_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>storm逻辑图，已授权</p>
<p>其实我们原来都是 <strong>CRUD boy</strong> ，机械的使用那些框架，只会做增删改查，并不会思考框架背后的设计思路。 但框架到底是什么？从来没有思考过。 我一直觉得我很笨拙，学什么都很慢，但那一刻我突然恍然大悟：<strong>框架本身是将解决问题的思路抽象化，从而便于研发人员使用</strong>，把复杂的问题抽象成有美感，是需要功底的。</p>
<p>了解完 Storm 整体概念 ， 下一步也就是大家熟知的<strong>写 Hello World</strong> 阶段了 。</p>
<figure><img src="https://pic3.zhimg.com/80/v2-c8a1f6d1a328692199d58dd4746c414e_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>我参考教程写了一个简单的 Storm 应用（简称：拓扑），在部署后，程序正常跑了起来。</p>
<p>我脑海里一直有一个疑问：“是不是优惠券计算服务的 storm 集群的配置没有调优，才导致计算的性能太差 ? ” 所以我必须去<strong>理解 storm 的并发度是如何计算的</strong>。</p>
<p>整个下午，我一直在查阅相关的资料，并结合下图思考：Nimbus， Supervisor ，Worker ，Task 这些名词到底是什么概念，以及他们之间是如何交互的。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-5d3c97776c0618f4e1e1721379c86bcf_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>进而思考：<strong>拓扑到底会启动几个进程，每个进程内部线程模型是怎样的</strong>，颇有些<strong>庖丁解牛</strong>的味道。</p>
<p>这个习惯一直保持到现在，当我看到一个系统，我会下意思的去思考：“这个系统的线程模型如何，每次操作有哪些线程参于，他们之间如何交互”。我知道有更厉害的大牛，运行一行代码就知道 CPU 会运行的哪些指令，我做不到，但我觉得那就更加深刻了。</p>
<p>不管怎样，这一天，我的思绪经过多次的变化，兴奋，犹疑，放弃，阳光，激动，畏难心理一直存在，很多次想放弃，但好奇心一直鼓励着我。</p>
<p>等天色已黑，我走出国图的大门，脑子里全部都是 Storm 进程，线程模型，内心里面，有了莫名的自信。感觉自己就像仙剑奇侠传里的<strong>酒剑仙</strong>，伴随着激昂的 BGM ，拔剑四顾，斩妖除魔。</p>
<blockquote>
<p>御剑乘风来，除魔天地间，有酒乐逍遥，无酒我亦癫。
一饮尽江河，再饮吞日月，千杯醉不倒，唯我酒剑仙。</p>
</blockquote>
<h2> <strong>3 找到瓶颈</strong></h2>
<p>当我理解了 Storm 的整体概念，接下来我需要去找到优惠券计算服务的性能瓶颈。这个时候，<strong>梳理计算服务整体流程</strong>非常关键。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-f0aeb303287cd077b923bdbae1bed8f7_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>优惠券流式计算拓扑</p>
<p>计算服务整体流程分为三个步骤 ：</p>
<ol>
<li>抽取数据：<strong>酒店信息拉取服务</strong>拉取酒店信息，并存储到<strong>水源头</strong>( Redis A/B 集群 ) ;</li>
<li>计算过程：<strong>Storm 拓扑</strong>从水源头获取酒店数据，通过运营配置的规则对数据进行清洗 ，将计算好的数据存储到<strong>水存放池</strong> ( Redis C 集群) ；</li>
<li>入库阶段：<strong>入库服务</strong>从<strong>水存放池</strong>获取数据，将计算结果存储到数据库 。</li>
</ol>
<p>当我们把整个计算的过程拆分成 <strong>抽取--&gt;计算 --&gt; 存储</strong> 三个阶段的时候，计算服务的架构就变得异常清晰，那到底在哪个阶段最耗时 ，也成为我追查的目标。</p>
<p>优惠券计算服务当时没有详细的性能监控体系，所以我只能先从<strong>日志</strong>着手。 在运营同事触发全量计算后，分别观察三个阶段对应服务的日志：</p>
<ul>
<li>抽取数据：<strong>酒店信息拉取服务</strong></li>
<li>计算过程: <strong>Storm 拓扑</strong></li>
<li>入库阶段: <strong>入库服务</strong></li>
</ul>
<p>令人惊讶的现象：一次全量计算需要耗时4个多小时，但抽取数据的任务竟然跑了2个多小时，和我预期完全不一样。</p>
<figure><img src="https://pic1.zhimg.com/80/v2-4e0ece1fbcb6c6a75ad699a0dd46ae0c_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>抽水泵</p>
<p>假如我把酒店信息拉取服务比作抽水泵，那么<strong>整个系统最大的问题竟然是抽水泵抽水马力不足</strong>。</p>
<h2> <strong>4 推进重构</strong></h2>
<p>为什么抽水泵抽水马力不足 ？</p>
<p>通过阅读源码，我发现因为线程模型不够好，应用在部署多个节点后，每个节点只能有两个线程执行拉取酒店信息。</p>
<p>怎么处理呢？ 在原有代码上优化可行吗？ 好像也不太容易，因为老代码最初是一个 C# 研发同事写的，他当时也不熟悉 JAVA ，从设计层面来讲，有很多冗余且不合理的代码，而且经过3年左右的维护，代码老化严重，于是我只能想到重构。</p>
<p>当我把想法和团队负责人沟通后，他有点半信半疑，他认为我的判断没有问题，但不确定我是否可以将系统重构好。 我那时候信心爆棚，主动请缨，打包票不会出问题的。可能是由于 CTO 逼的太紧了，他同意了。</p>
<p>在重构之间，梳理好系统的整体逻辑。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-25fa611c23e24b6fb0e5df7070b0f197_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>酒店拉取服务逻辑图</p>
<p>重构的重点原则有两条：</p>
<ol>
<li>拉取服务可水平扩展，若性能不足时，增加服务节点即可提升性能；</li>
<li>配置文件可配置 worker 线程数量。</li>
</ol>
<p>那思想层面，我已经做好准备了，那硬实力层面我有没有做好准备吗？ 非常自信的讲，准备好了，因为<strong>我遇到了 RocketMQ</strong> 。</p>
<p>我在《我与消息队列的8年情缘》这篇文章写到：</p>
<blockquote>
<p>2014年，我搜罗了很多的淘宝的消息队列的资料，我知道MetaQ的版本已经升级MetaQ 3.0，只是开源版本还没有放出来。
大约秋天的样子，我加入了RocketMQ技术群。誓嘉(RocketMQ创始人)在群里说：“最近要开源了，放出来后，大家赶紧fork呀”。他的这句话发在群里之后，群里都炸开了锅。我更是欢喜雀跃，期待着能早日见到阿里自己内部的消息中间件。</p>
</blockquote>
<figure><img src="https://pic3.zhimg.com/80/v2-06dea7880f38c233f95f6d318550c96e_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>终于，RocketMQ终于开源了。我迫不及待想一窥他的风采。
因为我想学网络编程，而RocketMQ的通讯模块remoting底层也是Netty写的。所以，RocketMQ的通讯层是我学习切入的点。
我模仿RocketMQ的remoting写了一个玩具的rpc，这更大大提高我的自信心。正好，艺龙举办技术创新活动。我想想，要不尝试一下用Netty改写下Cobar的通讯模块。于是参考Cobar的源码花了两周写了个netty版的proxy，其实非常粗糙，很多功能不完善。后来，这次活动颁给我一个鼓励奖，现在想想都很好玩。</p>
<p>在重构酒店信息拉取服务时，我将 RocketMQ 如何创建线程的知识点正好也用了上去，并学习如何将模块拆分得更加合理。同时在重构过程中，不断 Review 新老代码的差别，确保核心逻辑正确。</p>
<p>非常幸运，大概一周时间，我就重构完了。</p>
<p>重构完成并不意味着结束，怎么验证呢 ？ 我当时采取了两种方式：</p>
<ul>
<li>代码评审
我拉着优惠券计算服务的同事，一起 review 代码 。整个过程，大家也并没有提出异议，并对我创建线程的技巧感到很好奇。我心中窃喜：”那是学习 RocketMQ 的“。</li>
<li>测试环境数据验证
我们将新旧两版服务同时触发，比对两个版本的数据的异同，将比对结果输出到日志文件，然后从中找到差异的地方，修复重构版的 BUG 。 然后在测试环境部署重构版，观察一段时间，确保无异常。</li>
</ul>
<p>从编写第一行代码，三周时间，重构版终于上线了。 我将原来的老服务替换后，部署了3个节点， 每个节点8个 worker 并行拉取酒店信息 。</p>
<p>令人开心和激动的是，重构是非常成功的。 因为业务给我们的时间需求也是1个小时左右。一次全量计算从原来4个小时急速缩减到1小时15分钟，整个酒店拉取服务耗时40分钟左右。</p>
<p>我心里长舒一口气，内心吟诵李白的诗："十步杀一人，千里不留行。<strong>事了拂衣去，深藏身与名。"</strong></p>
<h2> <strong>5 向前一步</strong></h2>
<p>前 Facebook COO 谢丽尔·桑德伯格 写了一本书《向前一步》，我特别喜欢这本书的书名 。</p>
<figure><img src="https://pic2.zhimg.com/80/v2-a0c478c37f423ce6a0b202f1712ef261_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>在优化优惠券计算服务的前期，团队经过一个多月的时间，也没有什么成效。 我自己也犹豫：”我能不能解决这个问题？“ ，但<strong>最终我还是向前一步</strong>，并帮助团队大大提升了服务的性能，负责人也有了信心，他也敢投入资源优化<strong>Storm 拓扑</strong>和<strong>入库流程</strong>。</p>
<p>在阅读优惠券计算服务的代码中，我发现两个问题：</p>
<ol>
<li>流式计算逻辑中有大量网络 IO 请求，主要是查询特定的酒店数据，用于后续计算；</li>
<li>每次计算时需要查询基础配置数据，它们都是从数据库中获取。</li>
</ol>
<p>对于Storm 拓扑优化，我提了两点建议：</p>
<ol>
<li>流式计算拓扑和酒店拉取服务各司其职，将流式计算中的网络 IO 请求挪到酒店拉取服务，将数据前置准备好；</li>
<li>基础配置缓存化，引入读写锁（也是 RocketMQ 名字服务的技巧）。</li>
</ol>
<p>对于入库流程，一位研发同学将原来的单条数据入库修改成批量入库。</p>
<p>经过大家一起努力 ，优惠券计算服务的整体性能大大提升了，全量计算耗时已经变成40分钟了，再也不会有运营同事在我们的工位附近吐槽系统慢了。</p>
<h2> <strong>6 写到最后</strong></h2>
<p>2014年，我向前一步推动了公司流式计算服务的优化，并取得了一点点进步。</p>
<p>时光荏苒，我已中年，生命中遇到越来越多的挫折，有的时候也会让人低落，但每当想起这个故事，我会深深感动于当时的一往无前。</p>
<p>当再次面临选择时，我希望自己也能够向前一步，想着如何帮助读者成长，或是实现一个产品帮助更多的人。</p>
]]></content>
    <category term="技术人生"/>
    <published>2023-11-20T07:14:27.000Z</published>
  </entry>
  <entry>
    <title type="text">聊聊如何学习开源项目</title>
    <id>https://javayong.cn/codelife/howtolearnopenproject.html</id>
    <link href="https://javayong.cn/codelife/howtolearnopenproject.html"/>
    <updated>2023-11-20T07:14:27.000Z</updated>
    <summary type="html"><![CDATA[<p>工作几年的程序员同学，有了一定的项目经验，对于编程也有了自己的理解，但他们偶尔也会感到困惑，不知道接下来该如何提升自己。</p>
<p>在笔者看来："这个阶段的程序员最需要的是提升自身编程能力和视野高度，而学习开源项目是最有效的方法之一"。</p>
<p>这篇文章，笔者聊聊自己的学习开源项目的心得，希望对你有所帮助。</p>
<h2> <strong>1 学会使用</strong></h2>
<p>首先，我们需要学习<strong>如何使用开源项目</strong>。</p>
<p>Github 是全球最大的在线软件源代码托管服务平台，很多开源项目都托管在他上面。</p>
<p>在 GIthub 下载源码后，需要重点关注类似 <strong>Quick Start，Getting started ，Example</strong> 之类的文档，这些文档告诉初学者如何使用项目。</p>]]></summary>
    <content type="html"><![CDATA[<p>工作几年的程序员同学，有了一定的项目经验，对于编程也有了自己的理解，但他们偶尔也会感到困惑，不知道接下来该如何提升自己。</p>
<p>在笔者看来："这个阶段的程序员最需要的是提升自身编程能力和视野高度，而学习开源项目是最有效的方法之一"。</p>
<p>这篇文章，笔者聊聊自己的学习开源项目的心得，希望对你有所帮助。</p>
<h2> <strong>1 学会使用</strong></h2>
<p>首先，我们需要学习<strong>如何使用开源项目</strong>。</p>
<p>Github 是全球最大的在线软件源代码托管服务平台，很多开源项目都托管在他上面。</p>
<p>在 GIthub 下载源码后，需要重点关注类似 <strong>Quick Start，Getting started ，Example</strong> 之类的文档，这些文档告诉初学者如何使用项目。</p>
<p>假如项目需要部署，参考项目文档，在独立的环境中，尝试从零开始，动手部署该项目。</p>
<p>某些项目也会提供完善的 example 工程·，里面有现成的例子，可以尝试按照文档介绍运行入门例子。</p>
<p>如果入门例子运行顺利 ，对于项目初学者来讲是一个很好的开始。若运行中出现异常，也不必慌张，寻找项目中 FAQ 文档，或者搜索出现问题的关键字（比如异常信息），查询相关的解决方案。</p>
<p>成功运行了项目中第一个基础例子之后，可以尝试运行更复杂的功能例子。</p>
<p>笔者建议<strong>单独创建一个工程，一个一个功能例子完善整个项目。当这个项目越来越充盈，也就证明你掌握得越多</strong>。在学习过程中，将学习的心得记录在笔记中，便于后续回溯。</p>
<h2> <strong>2 阅读源码</strong></h2>
<p><strong>阅读源码是深入理解开源项目最重要的一步</strong>。</p>
<p>阅读源码之前，尝试从源码构建该项目。通常开源项目都会提供一份构建指南，指导你如何搭建一个用于开发、调试和构建的环境。构建成功后，尝试运行该项目。</p>
<p>查看该项目的架构设计文档，梳理出整个项目的骨架，可以画流程图或者 UML 图，加深对项目的理解。</p>
<p>当我们了解到整个项目的骨架后，可以挑选感兴趣的模块来阅读，比如你对网络通讯感兴趣，就阅读网络层的代码，深入到实现细节，如它用了什么库，采用了什么设计模式，为什么这样做等。如果可以，DEBUG 细节代码。</p>
<p>阅读源码的时候，重视单元测试，尝试去运行单元测试，基本上一个好的单元测试会将该代码的功能和边界描述清楚。</p>
<p>笔者体系化的阅读源码是在2014年。彼时，RocketMQ 3.0 刚开源不久，笔者对消息队列极其感兴趣，同时也迫切想了解网络编程框架 Netty 到底是如何使用的。</p>
<p>于是，先从 RocketMQ 网络通讯模块 remoting 开始学习，因为源码中有完善的测试用例，先运行单元测试，学习网络编码模型。</p>
<p>在学习网络编程的过程中，笔者有两点思维突破：</p>
<p><strong>▍一、客户端的编程模型</strong></p>
<p>RocketMQ 客户端网络通讯有如下三种方式：</p>
<ul>
<li>oneway : 单向发送</li>
<li>sync ：同步调用</li>
<li>callback ：异步回调</li>
</ul>
<p>很多技术的思想是相通的，下图是蚂蚁开源的通讯组件 sofa-bolt 支持的调用类型。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-43eaf9faa7bc9825070114612b87f36b_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>蚂蚁通讯框架Bolt调用类型</p>
<p><strong>▍二、服务端处理器模式</strong></p>
<p>RocketMQ 服务端通讯使用经典的 Reactor 模式 ，服务端注册不同的业务处理器，而各个业务处理器可以绑定不同的线程池。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://pic2.zhimg.com/80/v2-50551cf8c23a2a719a999ba7a2c9cf91_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<hr>
<p>学完网络框架 Remoting 之后，然后结合 Broker 模块，学习 RocketMQ 存储模型，通过这种方式就可以对 RocketMQ 有了一个相对清晰的认识。</p>
<h2> <strong>3 知行合一</strong></h2>
<p>笔者大学刚毕业的时候，读李开复老师的书，书中有一句话，我印象深刻： “<strong>I Hear and I Forget, I See and I Remember, I Do and I Understand</strong> ” 。</p>
<p>中国古代哲学家荀子也说过："<strong>不闻不若闻之，闻之不若见之，见之不若知之，知之不若行之；学至于行之而止矣</strong>"。</p>
<p>学习源码的过程中，将知识点夯实的关键要诀是<strong>动手实践</strong>，并保证实践之后有<strong>输出产物</strong>，也就是<strong>知行合一</strong>。</p>
<p>笔者总结了两点经验，供大家参考。</p>
<p><strong>▍一、源码中的知识点应用到项目中</strong></p>
<p>开源项目中有非常多的<strong>优秀实践</strong> ，可以将代码中的编码技巧，设计思想，优秀源码引进到业务项目里。</p>
<p>2014年，艺龙的优惠券计算服务遇到性能瓶颈，笔者负责重构这个系统。 在阅读 RocketMQ 源码后，学习到了线程池使用精髓：<strong>线程池隔离，各司其职</strong> 。</p>
<p>于是，笔者先梳理出业务场景，根据任务类型，绑定不同的线程池，为了便于扩展同时对外暴露并发度的配置参数。在重构这个系统的过程中，还引入 RocketMQ 创建线程工具类代码 。</p>
<p>重构之后，不仅系统的性能提升了5倍，而且笔者的自信心也大大提升，对技术的理解也更加深刻。</p>
<p><strong>▍ 二、造轮子</strong></p>
<p>当我们学习了一个开源项目，我们可以参考开源源码仿写一个。仿写的过程就是查漏补缺的过程，也能完善自己的知识体系。</p>
<p>2016年，sharding-jdbc 开源了，下图是当时 sharding-jdbc 的架构设计图：</p>
<figure><img src="https://pic2.zhimg.com/80/v2-70ec651391c885be8bbfb66b2e2d8235_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>笔者当时对分库分表着迷，同时脑海里有很多疑问，比如如何封装 jdbc 的接口，如何实现 SQL 解析 ，如何将多个分片的结果聚合等。</p>
<p>于是，笔者参考 sharding-jdbc 的源码，仿写了一个分库分表组件。</p>
<figure><img src="https://pic2.zhimg.com/80/v2-1414538009d90083904223e66a600625_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>经过这次仿写，笔者深入实践了 client 模式分库分表的原理，并积累了自己的技术储备。</p>
<h2> <strong>4 参与开源</strong></h2>
<blockquote>
<p>“开源理念之一就是非常鼓励不同的人一起合作”。——Linux 之父 <code>Linus Torvalds</code> 2016 年 2 月 TED 演讲《<strong><a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1Cs411z73j" target="_blank" rel="noopener noreferrer">The mind behind Linux (opens new window)</a></strong>》</p>
</blockquote>
<p>在《教授鼓励学生参与开源项目的 5 个理由》这篇文章里，提到了如下五点理由：</p>
<ol>
<li>无边界的学习</li>
<li>专业的交流</li>
<li>外在的机会</li>
<li>更深入的理解计算机科学</li>
<li>玩</li>
</ol>
<p>那么程序员如何参与开源呢 ？参与开源有很多种方式，最常见的有如下几种：</p>
<ol>
<li>直接参与开源项目的开发</li>
<li>参考开源项目的社区比赛</li>
<li>修复开源项目中的 Bug</li>
<li>开源项目文档编写</li>
<li>参与开源项目的测试和 Demo 编写工作</li>
<li>参与开源项目推广</li>
</ol>
<p>参与一个开源项目，并与许许多多同样聪明的工程师协作，把脑海中的奇思妙想一一实现，那是多么美好的事情。</p>
<h2> <strong>5 写到最后</strong></h2>
<p>亲爱的程序员朋友，当你不知道选择哪一个开源项目开始学习时，希望你<strong>立足当下，行动起来</strong>。当前技术团队使用的开源组件，正是你学习的方向。</p>
<p>行动起来，你会变成更好的自己，加油。</p>
]]></content>
    <category term="技术人生"/>
    <published>2023-11-20T06:53:02.000Z</published>
  </entry>
  <entry>
    <title type="text">我与消息队列的八年情缘</title>
    <id>https://javayong.cn/codelife/messagequeuecareer.html</id>
    <link href="https://javayong.cn/codelife/messagequeuecareer.html"/>
    <updated>2023-11-20T06:53:02.000Z</updated>
    <summary type="html"><![CDATA[<p>谈起消息队列，内心还是会有些波澜。</p>
<p><strong>消息队列</strong>，缓存，分库分表是高并发解决方案三剑客，而消息队列是我最喜欢，也是思考最多的技术。</p>
<p>我想按照下面的四个阶段分享我与消息队列的故事，同时也是对我技术成长经历的回顾。</p>
<ul>
<li>初识：ActiveMQ</li>
<li>进阶：Redis&amp;RabbitMQ</li>
<li>升华：MetaQ</li>
<li>钟情：RocketMQ</li>
</ul>
<h2> <strong>1 初识ActiveMQ</strong></h2>
<h3> <strong>1.1 异步&amp;解耦</strong></h3>]]></summary>
    <content type="html"><![CDATA[<p>谈起消息队列，内心还是会有些波澜。</p>
<p><strong>消息队列</strong>，缓存，分库分表是高并发解决方案三剑客，而消息队列是我最喜欢，也是思考最多的技术。</p>
<p>我想按照下面的四个阶段分享我与消息队列的故事，同时也是对我技术成长经历的回顾。</p>
<ul>
<li>初识：ActiveMQ</li>
<li>进阶：Redis&amp;RabbitMQ</li>
<li>升华：MetaQ</li>
<li>钟情：RocketMQ</li>
</ul>
<h2> <strong>1 初识ActiveMQ</strong></h2>
<h3> <strong>1.1 异步&amp;解耦</strong></h3>
<p>2011年初，我在一家互联网彩票公司做研发。</p>
<p>我负责的是用户中心系统，提供用户注册，查询，修改等基础功能。用户注册成功之后，需要给用户发送短信。</p>
<p>因为原来都是面向过程编程，我就把新增用户模块和发送短信模块都揉在一起了。</p>
<figure><img src="https://pic1.zhimg.com/80/v2-684a72a1a19ce37b1b42cd9db76b6604_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>起初都还好，但问题慢慢的显现出来。</p>
<ul>
<li>短信渠道不够稳定，发送短信会达到5秒左右，这样用户注册接口耗时很大，影响前端用户体验;</li>
<li>短信渠道接口发生变化，用户中心代码就必须修改了。但用户中心是核心系统。每次上线都必要谨小慎微。这种感觉很别扭，非核心功能影响到核心系统了。</li>
</ul>
<p>第一个问题，我可以采取线程池的方法来做，主要是<strong>异步化</strong>。但第二个问题却让我束手无措。</p>
<p>于是我向技术经理请教，他告诉我引入消息队列去解决这个问题。</p>
<ul>
<li>将发送短信功能单独拆成独立的Job服务;</li>
<li>用户中心用户注册成功后，发送一条消息到消息队列，Job服务收到消息调用短信服务发送短信即可。</li>
</ul>
<figure><img src="https://pic2.zhimg.com/80/v2-1352ec3cb37b34ef1915118e64da2161_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>这时，我才明白: 消息队列最核心的功能就是<strong>异步</strong>和<strong>解耦</strong>。</p>
<h3> <strong>1.2 调度中心</strong></h3>
<p>彩票系统的业务是比较复杂的。在彩票订单的生命周期里，经过创建，拆分子订单，出票，算奖等诸多环节。 每一个环节都需要不同的服务处理，每个系统都有自己独立的表，业务功能也相对独立。假如每个应用都去修改订单主表的信息，那就会相当混乱了。</p>
<p>公司的架构师设计了<strong>调度中心</strong>的服务，调度中心的职责是维护订单核心状态机，订单返奖流程，彩票核心数据生成。</p>
<figure><img src="https://pic1.zhimg.com/80/v2-31cf1f1abe47c95553a1975008e533cc_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>调度中心通过<strong>消息队列</strong>和出票网关，算奖服务等系统传递和交换信息。</p>
<p>这种设计在那个时候青涩的我的眼里，简直就是水滴vs人类舰队，降维打击。</p>
<p>随着我对业务理解的不断深入，我隐约觉得：“好的架构是简洁的，也是应该易于维护的”。</p>
<p>当彩票业务日均千万交易额的时候，调度中心的研发维护人员也只有两个人。调度中心的源码里业务逻辑，日志，代码规范都是极好的。</p>
<p>在我日后的程序人生里，我也会下意识模仿调度中心的编码方式，“不玩奇技淫巧，代码是给人阅读的”。</p>
<h3> <strong>1.3 重启大法</strong></h3>
<p>随着彩票业务的爆炸增长，每天的消息量从30万激增到150~200万左右，一切看起来似乎很平稳。</p>
<p>某一天双色球投注截止，调度中心无法从消息队列中消费数据。消息总线处于只能发，不能收的状态下。 整个技术团队都处于极度的焦虑状态，“要是出不了票，那可是几百万的损失呀，要是用户中了两个双色球？那可是千万呀”。大家急得像热锅上的蚂蚁。</p>
<p>这也是整个技术团队第一次遇到消费堆积的情况，大家都没有经验。</p>
<p>首先想到的是多部署几台调度中心服务，部署完成之后，调度中心消费了几千条消息后还是Hang住了。 这时，架构师只能采用<strong>重启</strong>的策略。你没有看错，就是重启大法。说起来真的很惭愧，但当时真的只能采用这种方式。</p>
<p>调度中心重启后，消费了一两万后又Hang住了。只能又重启一次。来来回回持续20多次，像挤牙膏一样。而且随着出票截止时间的临近，这种思想上的紧张和恐惧感更加强烈。终于，通过1小时的手工不断重启，消息终于消费完了。</p>
<p>我当时正好在读毕玄老师的《分布式java应用基础与实践》，猜想是不是线程阻塞了，于是我用Jstack命令查看堆栈情况。 果然不出所料，线程都阻塞在提交数据的方法上。</p>
<figure><img src="https://pic1.zhimg.com/80/v2-827a3153474627f273451d4390f540a8_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>我们马上和DBA沟通，发现oracle数据库执行了非常多的大事务，每次大的事务执行都需要30分钟以上，导致调度中心的调度出票线程阻塞了。</p>
<p>技术部后来采取了如下的方案规避堆积问题：</p>
<ol>
<li>生产者发送消息的时候，将超大的消息拆分成多批次的消息，减少调度中心执行大事务的几率;</li>
<li>数据源配置参数，假如事务执行超过一定时长，自动抛异常，回滚。</li>
</ol>
<h3> <strong>1.4 复盘</strong></h3>
<p>Spring封装的ActiveMQ的API非常简洁易用，使用过程中真的非常舒服。</p>
<p>受限于当时彩票技术团队的技术水平和视野，我们在使用ActiveMQ中遇到了一些问题。</p>
<ol>
<li>高吞吐下，堆积到一定消息量易Hang住；</li>
</ol>
<p>技术团队发现在吞吐量特别高的场景下，假如消息堆积越大，ActiveMQ有较小几率会Hang住的。</p>
<p>出票网关的消息量特别大，有的消息并不需要马上消费，但是为了规避消息队列Hang住的问题，出票网关消费数据的时候，先将消息先持久化到本地磁盘，生成本地XML文件，然后异步定时执行消息。通过这种方式，我们大幅度提升了出票网关的消费速度，基本杜绝了出票网关队列的堆积。</p>
<p>但这种方式感觉也挺怪的，消费消息的时候，还要本地再存储一份数据，消息存储在本地，假如磁盘坏了，也有丢消息的风险。</p>
<ol>
<li>高可用机制待完善</li>
</ol>
<p>我们采用的master/slave部署模式，一主一从，服务器配置是4核8G 。</p>
<p>这种部署方式可以同时运行两个ActiveMQ， 只允许一个slave连接到Master上面，也就是说只能有2台MQ做集群，这两个服务之间有一个数据备份通道，利用这个通道Master向Slave单向地数据备份。 这个方案在实际生产线上不方便， 因为当Master挂了之后， Slave并不能自动地接收Client发来的请来，需要手动干预，且要停止Slave再重启Master才能恢复负载集群。</p>
<p>还有一些很诡异丢消息的事件，生产者发送消息成功，但master控制台查询不到，但slave控制台竟然能查询到该消息。</p>
<p>但消费者没有办法消费slave上的消息，还得通过人工介入的方式去处理。</p>
<h2> <strong>2 进阶Redis&amp;RabbitMQ</strong></h2>
<p>2014年，我在艺龙网从事红包系统和优惠券系统优化相关工作。</p>
<h3> <strong>2.1 Redis可以做消息队列吗</strong></h3>
<p>酒店优惠券计算服务使用的是初代流式计算框架<strong>Storm</strong>。Storm这里就不详细介绍，可以参看下面的逻辑图：</p>
<figure><img src="https://pic1.zhimg.com/80/v2-a4977cee51bb48192c724dbdf0f009fc_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>这里我们的Storm集群的水源头（数据源）是redis集群，使用<strong>list</strong>数据结构实现了消息队列的push/pop功能。</p>
<figure><img src="https://pic3.zhimg.com/80/v2-372e57ad3ab16387f5cd7d9cf0d8f752_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>流式计算的整体流程：</p>
<ol>
<li>酒店信息服务发送酒店信息到Redis集群A/B;</li>
<li>Storm的spout组件从Redis集群A/B获取数据, 获取成功后，发送tuple消息给Bolt组件;</li>
<li>Bolt组件收到消息后，通过运营配置的规则对数据进行清洗;</li>
<li>最后Storm把处理好的数据发送到Redis集群C;</li>
<li>入库服务从Redis集群C获取数据,存储数据到数据库;</li>
<li>搜索团队扫描数据库表，生成索引。</li>
</ol>
<figure><img src="https://pic4.zhimg.com/80/v2-f0aeb303287cd077b923bdbae1bed8f7_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>这套流式计算服务每天处理千万条数据，处理得还算顺利。 但方案在团队内部还是有不同声音:</p>
<ul>
<li>storm的拓扑升级时候，或者优惠券服务重启的时候，偶尔出现丢消息的情况。但消息的丢失，对业务来讲没有那么敏感，而且我们也提供了手工刷新的功能，也在业务的容忍范围内;</li>
<li>团队需要经常关注Redis的缓存使用量，担心Redis队列堆积, 导致out of memory;</li>
<li>架构师认为搜索团队直接扫描数据库不够解耦，建议将Redis集群C替换成Kafka，搜索团队从kafka直接消费消息，生成索引;</li>
</ul>
<p>我认为使用Redis做消息队列应该满足如下条件：</p>
<ol>
<li>容忍小概率消息丢失，通过定时任务/手工触发达到最终一致的业务场景;</li>
<li>消息堆积概率低，有相关的报警监控;</li>
<li>消费者的消费模型要足够简单。</li>
</ol>
<h3> <strong>2.2 RabbitMQ是管子不是池子</strong></h3>
<p>RabbitMQ是用<strong>erlang</strong>语言编写的。RabbitMQ满足了我的两点需求：</p>
<ol>
<li>高可用机制。艺龙内部是使用的镜像高可用模式，而且这种模式在艺龙已经使用了较长时间了，稳定性也得到了一定的验证。</li>
<li>我负责的红包系统里，RabbitMQ每天的吞吐也在百万条消息左右，消息的发送和消费都还挺完美。</li>
</ol>
<p>优惠券服务原使用<strong>SqlServer</strong>，由于数据量太大，技术团队决定使用分库分表的策略，使用公司自主研发的分布式数据库DDA。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-904a47d470e130aff98261183a231c5b_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>因为是第一次使用分布式数据库，为了测试DDA的稳定性，我们模拟发送1000万条消息到RabbitMQ，然后优惠券重构服务消费消息后，按照用户编号hash到不同的mysql库。</p>
<p>RabbitMQ集群模式是镜像高可用，3台服务器，每台配置是4核8G 。</p>
<p>我们以每小时300万条消息的速度发送消息，最开始1个小时生产者和消费者表现都很好，但由于消费者的速度跟不上生产者的速度，导致消息队列有积压情况产生。第三个小时，消息队列已堆积了500多万条消息了， 生产者发送消息的速度由最开始的2毫秒激增到500毫秒左右。RabbitMQ的控制台已血溅当场，标红报警。</p>
<p>这是一次无意中的测试，从测试的情况来看，RabbitMQ很优秀，但<strong>RabbitMQ对消息堆积的支持并不好，当大量消息积压的时候，会导致 RabbitMQ 的性能急剧下降</strong>。</p>
<p>有的朋友对我讲：“RabbitMQ明明是管子，你非得把他当池子？”</p>
<p>随着整个互联网数据量的激增, 很多业务场景下是允许适当堆积的，只要保证消费者可以平稳消费，整个业务没有大的波动即可。</p>
<p>我心里面越来越相信：消息队列既可以做<strong>管子</strong>，也可以当做<strong>池子</strong>。</p>
<figure><img src="https://pic4.zhimg.com/v2-5c93c94a66b6b3b11f6233aebdf9bd03_b.jpg" alt="动图封面" tabindex="0"><figcaption>动图封面</figcaption></figure>
<h2> <strong>3 升华MetaQ</strong></h2>
<blockquote>
<p>Metamorphosis的起源是我从对linkedin的开源MQ–现在转移到apache的kafka的学习开始的，这是一个设计很独特的MQ系统，它采用pull机制，而 不是一般MQ的push模型，它大量利用了zookeeper做服务发现和offset存储，它的设计理念我非常欣赏并赞同，强烈建议你阅读一下它的设计文档，总体上说metamorphosis的设计跟它是完全一致的。--- MetaQ的作者庄晓丹</p>
</blockquote>
<h3> <strong>3.1 惊艳消费者模型</strong></h3>
<p>2015年，我主要从事神州专车订单研发工作。</p>
<p>MetaQ满足了我对于消息队列的幻想：“分布式，高吞吐，高堆积”。</p>
<p>MetaQ支持两种消费模型： <strong>集群消费</strong>和<strong>广播消费</strong> ，因为以前使用过的消费者模型都是用队列模型，当我第一次接触到这种发布订阅模型的时候还是被惊艳到了。</p>
<p><strong>▍ 集群消费</strong></p>
<figure><img src="https://pic3.zhimg.com/80/v2-5ec2d8830589b16d67445d7e07838ea2_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>订单创建成功后，发送一条消息给MetaQ。这条消息可以被派单服务消费，也可以被BI服务消费。</p>
<p><strong>▍ 广播消费</strong></p>
<p>派单服务在讲订单指派给司机的时候，会给司机发送一个推送消息。推送就是用广播消费的模式实现的。</p>
<figure><img src="https://pic3.zhimg.com/80/v2-f72389f95a2d01005728fa50334d8ffa_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>大体流程是:</p>
<ol>
<li>司机端推送服务是一个TCP服务，启动后，采用的是广播模式消费MetaQ的PushTopic;</li>
<li>司机端会定时发送TCP请求到推送服务，鉴权成功后，推送服务会保存司机编号和channel的引用；</li>
<li>派单服务发送推送消息到MetaQ；</li>
<li>推送服务的每一台机器都会收到该消息，然后判断内存中是否存在该司机的channel引用，若存在，则推送消息。</li>
</ol>
<p>这是非常经典的广播消费的案例。我曾经研读京麦TCP网关的设计，它的推送也是采用类似的方式。</p>
<h3> <strong>3.2 激进的消峰</strong></h3>
<p>2015年是打车大战硝烟弥漫的一年。</p>
<p>对神州专车来讲，随着订单量的不断增长，欣喜的同时，性能的压力与日俱增。早晚高峰期，用户打车的时候，经常点击下单经常无响应。 在系统层面来看，专车api网关发现大规模超时，订单服务的性能急剧下降。数据库层面压力更大，高峰期一条记录插入竟然需要8秒的时间。</p>
<p>整个技术团队需要尽快提升专车系统的性能，此前已经按照模块领域做了数据库的拆分。但系统的瓶颈依然很明显。</p>
<p>我们设计了现在看来有点激进的方案：</p>
<ol>
<li>设计订单缓存。缓存方案大家要有兴趣，我们可以以后再聊，里面有很多可以详聊的点;</li>
<li>在订单的载客生命周期里，订单的修改操作先修改缓存，然后发送消息到MetaQ，订单落盘服务消费消息，并判断订单信息是否正常（比如有无乱序)，若订单数据无误，则存储到数据库中。</li>
</ol>
<figure><img src="https://pic2.zhimg.com/80/v2-916def60b0f03150635e89fce05db839_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>这里有两个细节：</p>
<ol>
<li>消费者消费的时候需要顺序消费，实现的方式是按照订单号路由到不同的partition，同一个订单号的消息，每次都发到同一个partition;</li>
</ol>
<figure><img src="https://pic3.zhimg.com/80/v2-1b79aa5ad5805e511218563fc7b072ca_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<ol>
<li>一个守护任务，定时轮询当前正在进行的订单，当缓存与数据不一致时候，修复数据，并发送报警。</li>
</ol>
<p>这次优化大大提升订单服务的整体性能，也为后来订单服务库分库分表以及异构打下了坚实的基础，根据我们的统计数据，基本没有发生过缓存和数据库最后不一致的场景。 但这种方案对缓存高可用有较高的要求，还是有点小激进吧。</p>
<h3> <strong>3.3 消息SDK封装</strong></h3>
<p>做过基础架构的同学可能都有经验：“三方组件会封装一层”，神州架构团队也是将metaq-client封装了一层。</p>
<p>在我的思维里面，封装一层可以减少研发人员使用第三方组件的心智投入，统一技术栈，也就如此了。</p>
<p>直到发生一次意外，我的思维升级了。那是一天下午，整个专车服务崩溃较长时间。技术团队发现："专车使用zookeeper做服务发现。zk集群的leader机器挂掉了，一直在选主。"</p>
<p>临时解决后，我们发现MetaQ和服务发现都使用同一套zk集群，而且consumer的offset提交，以及负载均衡都会对zk集群进行大量的写操作。</p>
<p>为了减少MetaQ对zk集群的影响，我们的目标是：“MetaQ使用独立的zk集群”。</p>
<ol>
<li>需要部署新的zk集群；</li>
<li>MetaQ的zk数据需要同步到新的集群；</li>
<li>保证切换到新的集群，应用服务基本无感知。</li>
</ol>
<p>我很好奇向架构部同学请教，他说新的集群已经部署好了，但需要同步zk数据到新的集群。他在客户端里添加了<strong>双写</strong>的操作。也就是说：我们除了会写原有的zk集群一份数据，同时也会在新的zk集群写一份。 过了几周后，MetaQ使用独立的zk集群这个任务已经完成了。</p>
<figure><img src="https://pic2.zhimg.com/80/v2-3fdf1c91a142672cf1f462859dad0189_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>这一次的经历带给我很大的感慨：“还可以这么玩？” ，也让我思考着：三方组件封装没有想像中那么简单。</p>
<p>我们可以看下<strong>快手</strong>消息的SDK封装策略：</p>
<ol>
<li>对外只提供最基本的 API，所有访问必须经过SDK提供的接口。简洁的 API 就像冰山的一个角，除了对外的简单接口，下面所有的东西都可以升级更换，而不会破坏兼容性 ;</li>
<li>业务开发起来也很简单，只要需要提供 Topic（全局唯一）和 Group 就可以生产和消费，不用提供环境、NameServer 地址等。SDK 内部会根据 Topic 解析出集群 NameServer 的地址，然后连接相应的集群。生产环境和测试环境环境会解析出不同的地址，从而实现了隔离；</li>
<li>上图分为 3 层，第二层是通用的，第三层才对应具体的 MQ 实现，因此，理论上可以更换为其它消息中间件，而客户端程序不需要修改；</li>
<li>SDK 内部集成了热变更机制，可以在不重启 Client 的情况下做动态配置，比如下发路由策略（更换集群 NameServer 的地址，或者连接到别的集群去），Client 的线程数、超时时间等。通过 Maven 强制更新机制，可以保证业务使用的 SDK 基本上是最新的。</li>
</ol>
<figure><img src="https://pic4.zhimg.com/80/v2-02d34bc27148a7459795af88850a0ac7_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<h2> <strong>3.4 重构MetaQ , 自成体系</strong></h2>
<p>我有一个习惯 : "经常找运维，DBA，架构师了解当前系统是否有什么问题，以及他们解决问题的思路。这样，我就有另外一个视角来审视公司的系统运行情况"。</p>
<p>MetaQ也有他的缺点。</p>
<ol>
<li>MetaQ的基层通讯框架是gecko，MetaQ偶尔会出现rpc无响应，应用假死的情况，不太好定位问题；</li>
<li>MetaQ的运维能力薄弱，只有简单的Dashboard界面，无法实现自动化主题申请，消息追踪等功能。</li>
</ol>
<p>有一天，我发现测试环境的一台消费者服务器启动后，不断报链接异常的问题，而且cpu占用很高。我用netstat命令马上查一下，发现已经创建了几百个链接。出于好奇心，我打开了源码，发现网络通讯框架gecko已经被替换成了netty。我们马上和架构部的同学联系。</p>
<p>我这才明白：他们已经开始重构MetaQ了。我从来没有想过重构一个开源软件，因为距离我太远了。或者那个时候，我觉得自己的能力还达不到。</p>
<p>后来，神州自研的消息队列自成体系了，已经在生产环境运行的挺好。</p>
<p>时至今天，我还是很欣赏神州架构团队。他们自研了消息队列，DataLink（数据异构中间件），分库分表中间件等。他们愿意去创新，有勇气去做一个更好的技术产品。</p>
<p>我从他们身上学到很多。</p>
<p>也许在看到他们重构MetaQ的那一刻，我的心里埋下了种子。</p>
<figure><img src="https://pic1.zhimg.com/80/v2-4fd5a72bda57c252694863ccee54b450_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<h2> <strong>4 钟情RocketMQ</strong></h2>
<h3> <strong>4.1 开源的盛宴</strong></h3>
<p>2014年，我搜罗了很多的淘宝的消息队列的资料，我知道MetaQ的版本已经升级MetaQ 3.0，只是开源版本还没有放出来。</p>
<p>大约秋天的样子，我加入了RocketMQ技术群。誓嘉(RocketMQ创始人)在群里说：“最近要开源了，放出来后，大家赶紧fork呀”。他的这句话发在群里之后，群里都炸开了锅。我更是欢喜雀跃，期待着能早日见到阿里自己内部的消息中间件。</p>
<figure><img src="https://pic2.zhimg.com/80/v2-9b8d0b6bdd93b09091433e0f21a804f1_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>终于，RocketMQ终于开源了。我迫不及待想一窥他的风采。</p>
<p>因为我想学网络编程，而RocketMQ的通讯模块remoting底层也是Netty写的。所以，RocketMQ的通讯层是我学习切入的点。</p>
<p>我模仿RocketMQ的remoting写了一个玩具的rpc，这更大大提高我的自信心。正好，艺龙举办技术创新活动。我想想，要不尝试一下用Netty改写下Cobar的通讯模块。于是参考Cobar的源码花了两周写了个netty版的proxy，其实非常粗糙，很多功能不完善。后来，这次活动颁给我一个鼓励奖，现在想想都很好玩。</p>
<p>因为在神州优车使用MetaQ的关系，我学习RocketMQ也比较得心应手。为了真正去理解源码，我时常会参考RocketMQ的源码，写一些轮子来验证我的学习效果。</p>
<p>虽然自己做了一些练习，但一直没有在业务环境使用过。2018年是我真正使用RocketMQ的一年，也是有所得的一年。</p>
<p><strong>▍ 短信服务</strong></p>
<p>短信服务应用很广泛，比如用户注册登录验证码，营销短信，下单成功短信通知等等。 最开始设计短信服务的时候，我想学习业界是怎么做的。于是把目标锁定在腾讯云的短信服务上。 腾讯云的短信服务有如下特点：</p>
<ul>
<li>统一的SDK，后端入口是http/https服务 , 分配appId/appSecret鉴权；</li>
<li>简洁的API设计：单发，群发，营销单发，营销群发，模板单发，模板群发。</li>
</ul>
<p>于是，我参考了这种设计思路。</p>
<ol>
<li>模仿腾讯云的SDK设计，提供简单易用的短信接口；</li>
<li>设计短信服务API端，接收发短信请求，发送短信信息到消息队列；</li>
<li>worker服务消费消息，按照负载均衡的算法，调用不同渠道商的短信接口；</li>
<li>Dashboard可以查看短信发送记录，配置渠道商信息。</li>
</ol>
<figure><img src="https://pic1.zhimg.com/80/v2-e673dae2710d23989aa30148e6a7864c_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>短信服务是我真正意义第一次生产环境使用RocketMQ，当短信一条条发出来的时候，还是蛮有成就感的。</p>
<p><strong>▍ MQ控制台</strong></p>
<figure><img src="https://pic2.zhimg.com/80/v2-33e925a01b0e08634a199e10cc4b5039_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>使用过RocketMQ的朋友，肯定对上图的控制台很熟悉。当时团队有多个RocketMQ集群，每组集群都需要单独部署一套控制台。于是我想着：能不能稍微把控制台改造一番，能满足支持多组集群。</p>
<p>于是，撸起袖子干了起来。大概花了20天的时间，我们基于开源的版本改造了能支持多组集群的版本。做完之后，虽然能满足我最初的想法，但是做的很粗糙。而且搜狐开源了他们自己的MQCloud ，我看了他们的设计之后， 觉得离一个消息治理平台还很远。</p>
<p>后来我读了《网易云音乐的消息队列改造之路》，《今日头条在消息服务平台和容灾体系建设方面的实践与思考》这两篇文章，越是心痒难耐，蛮想去做的是一个真正意义上的消息治理平台。一直没有什么场景和机会，还是有点可惜。</p>
<p>最近看了哈罗单车架构专家梁勇的一篇文章《哈啰在分布式消息治理和微服务治理中的实践》，推荐大家一读。</p>
<blockquote>
<p><a href="https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/N-vd6he4nsZp-G3Plc4m6A" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/N-vd6he4nsZp-G3Plc4m6A</a></p>
</blockquote>
<p><strong>▍ 一扇窗子，开始自研组件</strong></p>
<p>后来，我尝试进一步深入使用RocketMQ。</p>
<ul>
<li>仿ONS风格封装消息SDK；</li>
<li>运维侧平滑扩容消息队列；</li>
<li>生产环境DefaultMQPullConsumer消费模式尝试</li>
</ul>
<p>这些做完之后，我们又自研了注册中心、配置中心，任务调度系统。设计这些系统的时候，从RocketMQ源码里汲取了很多的营养，虽然现在看来有很多设计不完善的地方，代码质量也有待提高，但做完这些系统后，还是大大提升我的自信心。</p>
<p>RocketMQ给我打开了一扇窗子，让我能看到更广阔的Java世界。 对我而言，这就是开源的盛宴。</p>
<h3> <strong>4.2 Kafka: 大数据生态的不可或缺的部分</strong></h3>
<p>Kafka是一个拥有高吞吐、可持久化、可水平扩展，支持流式数据处理等多种特性的分布式消息流处理中间件，采用分布式消息发布与订阅机制，在日志收集、流式数据传输、在线/离线系统分析、实时监控等领域有广泛的应用。</p>
<p><strong>▍ 日志同步</strong></p>
<p>在大型业务系统设计中，为了快速定位问题，全链路追踪日志，以及故障及时预警监控，通常需要将各系统应用的日志集中分析处理。</p>
<p>Kafka设计初衷就是为了应对大量日志传输场景，应用通过可靠异步方式将日志消息同步到消息服务，再通过其他组件对日志做实时或离线分析，也可用于关键日志信息收集进行应用监控。</p>
<p>日志同步主要有三个关键部分：日志采集客户端，Kafka消息队列以及后端的日志处理应用。</p>
<ol>
<li>日志采集客户端，负责用户各类应用服务的日志数据采集，以消息方式将日志“批量”“异步”发送Kafka客户端。 Kafka客户端批量提交和压缩消息，对应用服务的性能影响非常小。</li>
<li>Kafka将日志存储在消息文件中，提供持久化。</li>
<li>日志处理应用，如Logstash，订阅并消费Kafka中的日志消息，最终供文件搜索服务检索日志，或者由Kafka将消息传递给Hadoop等其他大数据应用系统化存储与分析。</li>
</ol>
<p>日志同步示意图：</p>
<figure><img src="https://pic4.zhimg.com/80/v2-ea9701e39e78c4b153f8046eb912cc2b_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>▍<strong>流计算处理</strong></p>
<p>在很多领域，如股市走向分析、气象数据测控、网站用户行为分析，由于数据产生快、实时性强且量大，您很难统一采集这些数据并将其入库存储后再做处理，这便导致传统的数据处理架构不能满足需求。Kafka以及Storm、Samza、Spark等流计算引擎的出现，就是为了更好地解决这类数据在处理过程中遇到的问题，流计算模型能实现在数据流动的过程中对数据进行实时地捕捉和处理，并根据业务需求进行计算分析，最终把结果保存或者分发给需要的组件。</p>
<p><strong>▍ 数据中转枢纽</strong></p>
<p>近10多年来，诸如KV存储（HBase）、搜索（ElasticSearch）、流式处理（Storm、Spark、Samza）、时序数据库（OpenTSDB）等专用系统应运而生。这些系统是为单一的目标而产生的，因其简单性使得在商业硬件上构建分布式系统变得更加容易且性价比更高。通常，同一份数据集需要被注入到多个专用系统内。例如，当应用日志用于离线日志分析时，搜索单个日志记录同样不可或缺，而构建各自独立的工作流来采集每种类型的数据再导入到各自的专用系统显然不切实际，利用消息队列Kafka版作为数据中转枢纽，同份数据可以被导入到不同专用系统中。</p>
<p>下图是美团 MySQL 数据实时同步到 Hive 的架构图，也是一个非常经典的案例。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-8ac62729fb8adb03e53a5ba885703543_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<h3> <strong>4.3 如何技术选型</strong></h3>
<p>2018年去哪儿QMQ开源了，2019年腾讯TubeMQ开源了，2020年Pulsar如火如荼。</p>
<p>消息队列的生态是如此的繁荣，那我们如何选型呢？</p>
<p>我想我们不必局限于消息队列，可以再扩大一下。简单谈一谈我的看法。</p>
<blockquote>
<p>Databases are specializing – the “one size fits all” approach no longer applies ----- MongoDB设计哲学</p>
</blockquote>
<p>第一点：先有场景，然后再有适配这种场景的技术。什么样的场景选择什么样的技术。</p>
<p>第二点：现实往往很复杂，当我们真正做技术选型，并需要落地的时候，<strong>技术储备</strong>和<strong>成本</strong>是两个我们需要重点考量的因素。</p>
<p><strong>▍ 技术储备</strong></p>
<ul>
<li>技术团队有无使用这门技术的经验，是否踩过生产环境的坑，以及针对这些坑有没有完备的解决方案；</li>
<li>架构团队是否有成熟的SDK，工具链，甚至是技术产品。</li>
</ul>
<p><strong>▍ 成本</strong></p>
<ul>
<li>研发，测试，运维投入人力成本；</li>
<li>服务器资源成本；</li>
<li>招聘成本等。</li>
</ul>
<p>最后一点是<strong>人</strong>的因素，特别是管理者的因素。每一次大的技术选型考验技术管理者的视野，格局，以及管理智慧。</p>
<h2> <strong>5 写到最后</strong></h2>
<blockquote>
<p>我觉得这个世界上没有什么毫无道理的横空出世，真的，如果没有大量的积累大量的思考是不会把事情做好的。。。 总之，在经历了这部电影以后，我觉得我要学的太多了，这世界上有太多的能人，你以为的极限，弄不好，只是别人的起点。所以只有不停地进取，才能不丢人。那，人可以不上学，但一定要学习，真的。 ------ 韩寒《后会无期》演讲</p>
</blockquote>
<p>我学习消息队列的过程是不断思考，不断实践的过程，虽然我以为的极限，弄不好，只是别人的起点，但至少现在，当我面对这门技术的时候，我的内心充满了好奇心，同时也是无所畏惧的。</p>
<p>我始终相信：每天学习一点点，比昨天进步一点点就好。</p>
]]></content>
    <category term="技术人生"/>
    <published>2023-11-20T06:53:02.000Z</published>
  </entry>
  <entry>
    <title type="text">追源码的平凡之路</title>
    <id>https://javayong.cn/codelife/runningforcode.html</id>
    <link href="https://javayong.cn/codelife/runningforcode.html"/>
    <updated>2023-11-20T06:32:00.000Z</updated>
    <summary type="html"><![CDATA[<figure><img src="https://pica.zhimg.com/80/v2-43738226ef4af0ef6eee3844123cfa52_720w.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>在斯坦福大学, 乔布斯做了一场我认为他最精彩的演讲。他讲的第一个故事是 <code>connecting the dots</code>，这也是贯穿他一生非常重要的思想。</p>
<blockquote>
<p>你不可能充满预见地将生命的点滴串联起来；只有在你回头看的时候，你才发现这些点点滴滴之间的联系。所以，你要坚信，你现在所经历的将在你未来的生命中串联起来… 正是这种信仰让我不会失去希望，它让我的人生变得与众不同。</p>
</blockquote>]]></summary>
    <content type="html"><![CDATA[<figure><img src="https://pica.zhimg.com/80/v2-43738226ef4af0ef6eee3844123cfa52_720w.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>在斯坦福大学, 乔布斯做了一场我认为他最精彩的演讲。他讲的第一个故事是 <code>connecting the dots</code>，这也是贯穿他一生非常重要的思想。</p>
<blockquote>
<p>你不可能充满预见地将生命的点滴串联起来；只有在你回头看的时候，你才发现这些点点滴滴之间的联系。所以，你要坚信，你现在所经历的将在你未来的生命中串联起来… 正是这种信仰让我不会失去希望，它让我的人生变得与众不同。</p>
</blockquote>
<p>我不禁在想：我的编码以及架构生涯中，那些点是什么，又终将会连成怎样的线？</p>
<p>十年前刚进入 IT 行业的时候，我是一个很普通的工程师，脑袋也不灵光，工作老是得不到要领，而我的同学智商很高，他看一次代码基本就会写了，我得花很长时间去消化吸收，我对自己能不能在这一行生存下去都产生了质疑。</p>
<p>没有办法，只能笨鸟先飞，当遇到问题的时候，我都抱着死咬不放的心态去寻找最佳解决方案。洗澡的时候、吃饭的时候、甚至上厕所的时候都会去思考。<strong>很自然的，"追" 源码也成为我程序人生的一部分。</strong></p>
<p>我阅读过很多源码，和大家分享几个对我职业影响比较大的源码追寻经历。</p>
<hr>
<h2> <strong>01 数据库连接池 Durid</strong></h2>
<p>这是在2013年，我负责重构一个彩票算奖服务，原有代码是 C# 版本的，每次计算订单金额需要耗费 2~3 个小时，很多用户反馈体验很差，因为收到奖金很晚。</p>
<p>我当时采用 Druid 作为新项目的数据库连接池，重构后效果很明显，算奖性能提升到了原来的 10 倍。</p>
<p>不过，有一个问题是：每天第一次数据库请求总会报连接错误。当时我也不怎么会看源码，就直接给 Druid 的作者温少（也是 FastJson 作者）发了一封邮件：</p>
<figure><img src="https://pic3.zhimg.com/80/v2-7ca20947be50d941c9cf9d4d16de31de_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>温少给我回复了邮件，我马上翻看源码，发现我配置的连接心跳有问题。核心点在于连接池每隔一段时间就会发送心跳包到数据库服务器，而数据库为了节省资源，会关闭掉长期没有读写的连接。</p>
<p>这次简单的源码之旅给了我很大的激励，也让我更加关注技术背后的原理。</p>
<blockquote>
<p>1、精神层面：向别人请教问题是会上瘾的。
2、技能层面：理解连接池的实现原理。druid是基于数组实现的，后来用到的 jedis 连接池基于 commons-pool 实现的，netty 连接池是基于 FixChannelPool 实现的。
3、架构层面：客户端和服务端的长连接通信需要考虑心跳。类似 druid 连接池发送心跳的机制，以及 netty 中的 idleStateHandler。</p>
</blockquote>
<hr>
<h2> <strong>02 分库中间件 Cobar</strong></h2>
<p>还是在 2013 年，当时移动互联网大潮奔涌而来，各大互联网公司的数据爆炸般的增长。</p>
<p>我曾在 JavaEye 上看到淘宝订单的技术人员分享他们分库分表的帖子，顿时觉得如获至宝，可惜受限于篇幅，文章没讲很细节的原理，总感觉隔靴搔痒。</p>
<p>没曾想到不久后阿里将 Cobar 开源了，用 Navicat 配置好 Cobar 信息，就像连单个 MySQL 一样，而且数据会均匀地分布到多个数据库中。这对于我当时还很孱弱的技术思维来讲，简直就像三体里的水滴遇到人类舰队般，给了我很大的刺激。</p>
<p>因为对分库分表原理的渴求，我花了大约 3 个月的时间把整个 Cobar 的核心代码抄了一次。真的是智商不够，体力来凑。</p>
<p>但光有体力是真的不够，经常会陷入怀疑，有些地方还是看不懂，边抄代码边学习好像进步没那么明显。那好，总得找一个突破口吧。</p>
<p>网络通讯是非常重要的一环，因此我决定把 Cobar 的网络通讯模块剥离出来，去深刻理解使用原生 NIO 实现通讯的模式。剥离的过程同样很痛苦，但我有目标了，不至于像没头的苍蝇，后来也就有了人生第一个 GitHub 项目。</p>
<figure><img src="https://pic1.zhimg.com/80/v2-072c1e1249e3d33d5330f9837d8bca9c_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>在写 NIO 工程的同时，我还学习到了 Maven 的 Assemble 打包模式，这个现在听起来很简单，但在 2013 年还是以 Tomcat 部署 war 包占主流的年代，让当时的我眼前一亮。</p>
<p>追 Cobar 的过程中，我也找到了和阿里大牛面对面交流的机会，虽然我资质驽钝，但这位大牛对我的问题耐心解答，似乎打通了我的任督二脉。因此，这次经历说成是我编码生涯中最重要的一次经历也不为过。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-fe2ac8e12029dfd11ab7f52ffbeb8cb7_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>后来在艺龙网工作，和艺龙做数据库中间件的架构师沟通时，因为我有研究 Cobar 源码的底子，理解他的思路也很快。另外，也帮助他找到了分布式事务的一个 Bug。</p>
<hr>
<h2> <strong>03 阿里的消息中间件 MetaQ</strong></h2>
<p>2015年我加入神州专车，那个时候神州专车处于上升期，各个系统遇到了较大的瓶颈。MetaQ 在那个时期发挥了很重要的作用，相关引申的知识点也很多。</p>
<h3> <strong>3.1 广播消息在推送系统中的使用</strong></h3>
<p>当时我们使用的 MetaQ 是庄晓丹在 GitHub 开源的版本。2016年初，我 checkout 了 MetaQ 的源码，边理解业务边深入理解它的机制。</p>
<p>很有幸地和架构部的同事讨论了专车推送的设计方案。最开始的时候，我们也是使用极光推送，后来因为定制化的需求越来越多，因此决定自研推送系统。</p>
<p>那服务器如何推送消息到每一个连接的专车 APP 呢？方案很简单：采用 MetaQ 的广播模式就可以实现这个功能。</p>
<figure><img src="https://pic4.zhimg.com/80/v2-5b3aa8fb41799928519130b1ee855b6b_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<blockquote>
<p>1、业务系统推送消息到 MetaQ
2、TCP 网关广播模式消费 MetaQ 的消息
3、TCP 网关获取当前服务器所持有的 Session 会话，推送数据给 App</p>
</blockquote>
<p>后来，我仔细研读了京东京麦系统的 TCP 网关设计，关于推送方面的实现和我们上面的方案非常相似。</p>
<p>2018年，我服务的电商公司研发直播答题系统，我用这个方案又实现了推送题目的功能。</p>
<h3> <strong>3.2 ZK 崩溃引申的一连串知识</strong></h3>
<p>我们都知道 MetaQ 依赖 ZooKeeper 来实现负载均衡。突然有一天，专车整个 ZK 集群 down 掉了。架构负责人修改了 ZK 的 JVM 参数，问题貌似解决了，但疑问随之产生了。</p>
<p><strong>MetaQ 和服务治理共用一套 ZK 集群合适吗？</strong></p>
<p>阅读 MetaQ 源码后，我发现 MetaQ 在消费者很多的情况下，启动时会频繁的争抢锁，另外消费的过程，也会对 offset 频繁的修改。在 Topic 数量增多，partition 数量增多的情况下，MetaQ 对 ZK 实际上是有写压力的。</p>
<p>后来，神州架构部确实也是将 MetaQ 的 ZK 集群和服务治理的 ZK 集群分开了。当然迁移也是有技巧的，这里就不展开了。</p>
<p><strong>ZK 作为神州体系的注册中心是否有瓶颈?</strong></p>
<p>ZK 会存储各个服务的 IP 和端口，以及对外暴露的方法。随着专车系统的服务越来越多，ZK 真的可以承受得了吗？后来，公司领导邀请了京东的研发同学来给大家答疑。</p>
<p>京东的注册中心服务信息用什么实现的呢？京东同学的回答是：MySQL。我在旁边听得目瞪口呆，什么？MySQL？后来，淘宝中间件博客出了一篇文章：阿里巴巴为什么不用 ZooKeeper 做服务发现？</p>
<p>当数据中心服务规模超过一定的数量，作为注册中心的 ZooKeeper 很快就会像驴子一样不堪重负。</p>
<p>后来我参考张开涛写的一篇博客以及在 GitHub 上零落的 JSF 代码， 手撸了一个 AP 模型、客户端使用 BerkeleyDB 的注册中心。</p>
<p>我们也知道 2019年，阿里在 SpringCloud 生态上发力，Nacos 诞生了。Nacos 同时支持 AP 和 CP 两种模型，开源世界的选择更有多样性了。当我们使用 ZooKeeper 的时候，一定要注意集群规模和使用场景。</p>
<hr>
<h2> <strong>04 任务调度系统 XXL-Job</strong></h2>
<p>时间已经到了 2018 年，技术部需要一个可靠的任务调度系统。最开始使用的是 XXL-Job，但不知道怎么搞的，老是使用遇到有问题。从追源码到优化改造共经历了 3 个阶段。</p>
<figure><img src="https://pic3.zhimg.com/80/v2-045cd57add4d876187cffb03d286cf16_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>第 1 阶段，我看了 XXL-Job 的源码后，第一直觉是「简单」。因为作者已经最大限度的将这个系统做成了开箱即用，去掉了 Quartz 的集群调度模式，自研基于数据库的调度器。</p>
<p>但当前公司已经有自研的 RPC 服务，让其他团队配合 XXL-Job 添加JobHandler 好像也不太容易。所以最开始，我修改了调度器的代码，使用了公司的 RPC 来执行，只不过将 XXL-Job 的 JobHandler 替换为公司 RPC 的ServiceId。运行起来还行，能满足公司要求。</p>
<p>第 2 阶段，为什么我想再优化一波呢？因为当前的 RPC 调度是同步执行，不支持异步，假如 RPC 执行任务很长，那么 XXL-Job 的调度线程就会被阻塞。</p>
<p>我找到了美团的朋友，向他请教他们公司是如何设计任务调度系统的。他给我演示了美团任务调度系统 Crane 的执行过程，考虑到保密他仅仅给我讲了其中的原理。我根据他的描述做了如下架构设计：</p>
<figure><img src="https://pic1.zhimg.com/80/v2-f9c518f9eb6ffb3144f8739790279ad0_720w.webp" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>Schedule-Client 收到调度请求后，会将任务丢到线程池中异步执行，同时立马返回给调度服务器，这样就不会阻塞了。</p>
<p>第 3 阶段，光有架构设计没用，工程上如何做到更优雅的实现呢? 我想到了阿里云的schedulex，假如我是一名阿里云的开发者，我会怎么设计一个好的任务调度系统以支持每天千亿级别的任务调度呢？</p>
<p>我翻看了 schedulex 的开放文档以及 client 端源码，想不到真的是宝藏。schedulex client 里包含如下几个亮点：</p>
<blockquote>
<p>1、RPC 调用类似 RocketMQ remoting
2、任务调度通过 RPC 触发，有统一的注册中心（NameServer 模式）
3、支持多端口启动，以防当前端口启动失败
4、任务执行和任务调度的线程池做了隔离</p>
</blockquote>
<p>借鉴这些优点，我很快完成了工程实现，技术同事们对这个改造还算满意。但我深知，当前的系统还有两个待解决的问题：</p>
<blockquote>
<p>1、任务调度重度依赖数据库, 当真正有 10 万、20 万级别的任务的时候，任务的分配以及调度的触发肯定会有瓶颈。
2、当系统是容器的时候，是否可以正常使用？</p>
</blockquote>
<p>于是，今年年初我在 GitHub 上写下了自己相对完整的一个任务调度系统，将 Quartz 替换成了时间轮，将任务触发改成服务端推送模式。</p>
<p>在写任务调度的过程中，实际上也是不断超越自己的过程，我想把它做成一个可以和行业对标的作品，就必须向业界最先进的技术产品以及优秀的同行们学习。</p>
<hr>
<h2> <strong>05 写在最后</strong></h2>
<p>回顾那些追源码的点滴，心潮澎湃，久久不能平复。它们是我架构师之路最美好的记忆。</p>
<p>乔布斯的演讲里提到：工作将占据你生命中的很大一部分，只有从事你认为具有非凡意义的工作，方能给你带来真正的满足。而从事一份伟大工作的唯一方法，就是去热爱这份工作。</p>
<p>专注当前做的事情，并且把每件事情做到能力范围内的极限，也许此时没有那么大的成就感，但在未来的某个时间节点，你可能突然就有一种「蓦然回首，那人却在灯火阑珊处」的后知后觉。</p>
<p>亲爱的程序员朋友，爱你所选，全情投入，相信你必有所得。</p>
]]></content>
    <category term="技术人生"/>
    <published>2023-11-20T06:25:57.000Z</published>
  </entry>
  <entry>
    <title type="text">聊聊本地缓存和分布式缓存</title>
    <id>https://javayong.cn/cache/00localandclustercache.html</id>
    <link href="https://javayong.cn/cache/00localandclustercache.html"/>
    <updated>2023-11-20T05:21:16.000Z</updated>
    <summary type="html"><![CDATA[<p>缓存的世界很广阔，对于<strong>应用系统</strong>来讲，我们经常将缓存划分为<strong>本地缓存</strong>和<strong>分布式缓存</strong>。</p>
<p><strong>本地缓存</strong> ：应用中的缓存组件，缓存组件和应用在同一进程中，缓存的读写非常快，没有网络开销。但各应用或集群的各节点都需要维护自己的单独缓存，无法共享缓存。</p>
<p><strong>分布式缓存</strong>：和应用分离的缓存组件或服务，与本地应用隔离，多个应用可直接共享缓存。</p>
<h2> 1 缓存的本质</h2>
<p>我们常常会讲：“加了缓存，我们的系统就会更快” 。</p>]]></summary>
    <content type="html"><![CDATA[<p>缓存的世界很广阔，对于<strong>应用系统</strong>来讲，我们经常将缓存划分为<strong>本地缓存</strong>和<strong>分布式缓存</strong>。</p>
<p><strong>本地缓存</strong> ：应用中的缓存组件，缓存组件和应用在同一进程中，缓存的读写非常快，没有网络开销。但各应用或集群的各节点都需要维护自己的单独缓存，无法共享缓存。</p>
<p><strong>分布式缓存</strong>：和应用分离的缓存组件或服务，与本地应用隔离，多个应用可直接共享缓存。</p>
<h2> 1 缓存的本质</h2>
<p>我们常常会讲：“加了缓存，我们的系统就会更快” 。</p>
<p>所谓的“更快”，本质上做到了如下两点：</p>
<ul>
<li>
<p>减小 CPU 消耗</p>
<p>将原来需要实时计算的内容提前算好、把一些公用的数据进行复用，这可以减少 CPU 消耗，从而提升响应性能。</p>
</li>
<li>
<p>减小 I/O 消耗</p>
<p>将原来对网络、磁盘等较慢介质的读写访问变为对内存等较快介质的访问，从而提升响应性能。</p>
</li>
</ul>
<p>假如可以通过增强 CPU、I/O 本身的性能来满足需求的话，<strong>升级硬件往往是更好的解决方案</strong>，即使需要一些额外的投入成本，也通常要优于引入缓存后可能带来的风险。</p>
<p>从开发角度来说，引入缓存会提高系统复杂度，因为你要考虑缓存的失效、更新、一致性等问题。</p>
<p>从运维角度来说，缓存会掩盖掉一些缺陷，让问题在更久的时间以后，出现在距离发生现场更远的位置上。</p>
<p>从安全角度来说，缓存可能泄漏某些保密数据，也是容易受到攻击的薄弱点。</p>
<p>因此，<strong>缓存是把双刃剑</strong>。</p>
<h2> 2 本地缓存 JDK Map</h2>
<p>JDK Map 经常用于缓存实现：</p>
<ul>
<li>
<p>HashMap</p>
<p>HashMap 是一种基于哈希表的集合类，它提供了快速的插入、查找和删除操作。可以将键值对作为缓存项的存储方式，将键作为缓存项的唯一标识符，值作为缓存项的内容。</p>
</li>
<li>
<p>ConcurrentHashMap</p>
<p>ConcurrentHashMap 是线程安全的 HashMap，它在多线程环境下可以保证高效的并发读写操作。</p>
</li>
<li>
<p>LinkedHashMap</p>
<p>LinkedHashMap 是一种有序的 HashMap ，它保留了元素插入的顺序，可以按照插入顺序或者访问顺序进行遍历。</p>
</li>
<li>
<p>TreeMap</p>
<p>TreeMap 是一种基于红黑树的有序 Map，它可以按照键的顺序进行遍历。</p>
</li>
</ul>
<p>笔者曾经负责艺龙红包系统，<strong>红包活动</strong>就是<strong>存储在</strong> <strong>ConcurrentHashMap</strong> 中 ，通过<strong>定时任务刷新缓存</strong> 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//up-c95ec12a6b7f24b5be368bc5fad03be5bdd.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>核心流程：</p>
<p>1、红包系统启动后，初始化一个 ConcurrentHashMap 作为红包活动缓存 ；</p>
<p>2、数据库查询所有的红包活动 , 并将活动信息存储在 Map 中 ;</p>
<p>3、定时任务每隔 30 秒 ，执行缓存加载方法，刷新缓存。</p>
<p>为什么红包系统会将红包活动信息存储在本地内存 ConcurrentHashMap 呢 ？</p>
<ul>
<li>
<p>红包系统是高并发应用，快速将请求结果响应给前端，大大提升用户体验；</p>
</li>
<li>
<p>红包活动数量并不多，就算全部放入到 Map 里也不会产生内存溢出的问题；</p>
</li>
<li>
<p>定时任务刷新缓存并不会影响红包系统的业务。</p>
</li>
</ul>
<p>笔者见过很多<strong>单体应用</strong>都使用这种方案，该方案的特点是简洁易用，工程实现也容易 。</p>
<h2> 3 本地缓存框架</h2>
<p>虽然使用 JDK Map 能快捷构建缓存，但缓存的功能还是比较孱弱的。</p>
<p>因为现实场景里，我们可能需要给缓存添加<strong>缓存统计</strong>、<strong>过期失效</strong>、<strong>淘汰策略</strong>等功能。</p>
<p>于是，<strong>本地缓存框架</strong>应运而生。</p>
<p>流行的 Java 缓存框架包括： Ehcache , Google Guava ,  Caffeine Cache 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//up-ce94ccdd52ecb8650adc02ecbcb8314e22c.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>下图展示了 Caffeine 框架的使用示例。</p>
<figure><img src="https://www.javayong.cn/pics/temp//up-7e823491b7efd6f3cc2a370d3acb91c541b.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>虽然本地缓存框架的功能很强大，但是本地缓存的缺陷依然明显。</p>
<p>1、高并发的场景，<strong>应用重启之后，本地缓存就失效了，系统的负载就比较大</strong>，需要花较长的时间才能恢复；</p>
<p>2、每个应用节点都会维护自己的单独缓存，<strong>缓存同步比较头疼</strong>。</p>
<h2> 4 分布式缓存</h2>
<p>分布式缓存是指将缓存数据分布在多台机器上，以提高缓存容量和并发读写能力的缓存系统。分布式缓存通常由多台机器组成一个集群，每台机器上都运行着相同的缓存服务进程，缓存数据被均匀地分布在集群中的各个节点上。</p>
<p>Redis 是分布式缓存的首选，甚至我们一提到缓存，很多后端工程师首先想到的就它。</p>
<p>下图是神州专车订单的 Redis 集群架构 。将 Redis 集群拆分成四个分片，每个分片包含一主一从，主从可以切换。 应用 A 根据不同的缓存 key 访问不同的分片。</p>
<figure><img src="https://www.javayong.cn/pics/temp//up-3081e4dc2134380f257af5a411382aac0e1.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>与本地缓存相比，分布式缓存具有以下优点：</p>
<p><strong>1、容量和性能可扩展</strong></p>
<p>通过增加集群中的机器数量，可以扩展缓存的容量和并发读写能力。同时，缓存数据对于应用来讲都是共享的。</p>
<p><strong>2、高可用性</strong></p>
<p>由于数据被分布在多台机器上，即使其中一台机器故障，缓存服务也能继续提供服务。</p>
<p>但是分布式缓存的缺点同样不容忽视。</p>
<p><strong>1、网络延迟</strong></p>
<p>分布式缓存通常需要通过网络通信来进行数据读写，可能会出现网络延迟等问题，相对于本地缓存而言，响应时间更长。</p>
<p><strong>2、复杂性</strong></p>
<p>分布式缓存需要考虑序列化、数据分片、缓存大小等问题，相对于本地缓存而言更加复杂。</p>
<p>笔者曾经也认为无脑上分布式缓存  ，系统就一定更快，但直到一次事故，对于分布式缓存的观念才彻底改变。</p>
<p>2014年，同事开发了比分直播的系统，所有的请求都是从分布式缓存 Memcached 中获取后直接响应。常规情况下，从缓存中查询数据非常快，但在线用户稍微多一点，整个系统就会特别卡。</p>
<p>通过 jstat 命令发现 GC 频率极高，几次请求就将新生代占满了，而且 CPU 的消耗都在 GC 线程上。初步判断是缓存值过大导致的，果不其然，缓存大小在 300k 到 500k 左右。</p>
<p>解决过程还比较波折，分为两个步骤：</p>
<ol>
<li><strong>修改新生代大小</strong>，从原来的 2G 修改成 4G，并精简缓存数据大小 (从平均 300k 左右降为 80k 左右)；</li>
<li>把<strong>缓存拆成两个部分</strong>，第一部分是<strong>全量数据</strong>，第二部分是<strong>增量数据</strong>（数据量很小）。页面第一次请求拉取全量数据，当比分有变化的时候，通过 websocket 推送增量数据。</li>
</ol>
<p>经过这次优化，笔者理解到：缓存虽然可以提升整体速度，但是在高并发场景下，缓存对象大小依然是需要关注的点，稍不留神就会产生事故。另外我们也需要合理地控制读取策略，最大程度减少 GC 的频率 , 从而提升整体性能。</p>
<h2> 5 多级缓存</h2>
<p>开源中国网站最开始完全是用本地缓存框架 Ehcache 。</p>
<p>后来随着访问量的激增，出现了一个可怕的问题：“因为 Java 程序更新很频繁，每次更新的时候都要重启。一旦重启后，整个 Ehcache 缓存里的数据都被清掉。重启后若大量访问进来的话，开源中国的数据库基本上很快就会崩掉”。</p>
<p>于是，开源中国开发了多级缓存框架  <strong>J2Cache</strong>，使用了多级缓存 <strong>Ehcache + Redis</strong> 。</p>
<p>多级缓存有如下优势：</p>
<ol>
<li>离用户越近，速度越快；</li>
<li>减少分布式缓存查询频率，降低序列化和反序列化的 CPU 消耗；</li>
<li>大幅度减少网络 IO 以及带宽消耗。</li>
</ol>
<p>本地缓存做为一级缓存，分布式缓存做为二级缓存，首先从一级缓存中查询，若能查询到数据则直接返回，否则从二级缓存中查询，若二级缓存中可以查询到数据，则回填到一级缓存中，并返回数据。若二级缓存也查询不到，则从数据源中查询，将结果分别回填到一级缓存，二级缓存中。</p>
<figure><img src="https://www.javayong.cn/pics/temp//up-15ad6ae5ee11e2033883b25177a7e6864c5.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>2018年，笔者服务的一家电商公司需要进行 app 首页接口的性能优化。笔者花了大概两天的时间完成了整个方案，采取的是两级缓存模式，同时利用了 Guava 的惰性加载机制，整体架构如下图所示：</p>
<figure><img src="https://www.javayong.cn/pics/temp//510c833e-95e2-4222-9d54-d8f97abc2888.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>缓存读取流程如下：</p>
<p>1、业务网关刚启动时，本地缓存没有数据，读取 Redis 缓存，如果 Redis 缓存也没数据，则通过 RPC 调用导购服务读取数据，然后再将数据写入本地缓存和 Redis 中；若 Redis 缓存不为空，则将缓存数据写入本地缓存中。</p>
<p>2、由于步骤1已经对本地缓存预热，后续请求直接读取本地缓存，返回给用户端。</p>
<p>3、Guava 配置了 refresh 机制，每隔一段时间会调用自定义 LoadingCache 线程池（5个最大线程，5个核心线程）去导购服务同步数据到本地缓存和 Redis 中。</p>
<p>优化后，性能表现很好，平均耗时在 5ms 左右。最开始我以为出现问题的几率很小，可是有一天晚上，突然发现 app 端首页显示的数据时而相同，时而不同。</p>
<p>也就是说： 虽然 LoadingCache 线程一直在调用接口更新缓存信息，但是各个 服务器本地缓存中的数据并非完成一致。 说明了两个很重要的点：</p>
<p>1、惰性加载仍然可能造成多台机器的数据不一致</p>
<p>2、LoadingCache 线程池数量配置的不太合理,  导致了线程堆积</p>
<p>最终，我们的解决方案是：</p>
<p>1、惰性加载结合消息机制来更新缓存数据，也就是：当导购服务的配置发生变化时，通知业务网关重新拉取数据，更新缓存。</p>
<p>2、适当调大 LoadigCache 的线程池参数，并在线程池埋点，监控线程池的使用情况，当线程繁忙时能发出告警，然后动态修改线程池参数。</p>
<h2> 6 没有银弹</h2>
<p><strong>没有银弹</strong>是 Fred Brooks 在 1987 年所发表的一篇关于软件工程的经典论文。</p>
<p>论文强调真正的银弹并不存在，而所谓的银弹则是指没有任何一项技术或方法可以能让软件工程的生产力在十年内提高十倍。</p>
<p>通俗来讲：<strong>在技术领域中没有一种通用的解决方案可以解决所有问题</strong>。</p>
<p>技术本质上是为了解决问题而存在的，每个问题都有其独特的环境和限制条件，没有一种通用的技术或工具可以完美地解决所有问题。</p>
<p>虽然技术不断发展和进步，但是对于复杂的问题，仍需要结合多种技术和方法，进行系统性的思考和综合性的解决方案设计，才能得到最优解决方案。</p>
<p>回到文章开头的问题 ，如何说服技术老大用 Redis ？</p>
<p>假如应用就是一个单体应用，缓存可以不共享，通过定时任务刷新缓存对业务没有影响，而且本地内存可以 Hold 住缓存的对象大小，那么你的技术老大的方案没有问题。</p>
<p>假如应用业务比较复杂，需要使用缓存提升系统的性能，同时分布式缓存共享的特性对于研发来讲开发更加快捷，Redis 确实是个不错的选择，可以从研发成本、代码维护、人力模型等多个角度和技术老大提出自己的观点。</p>
<p>总而言之，<strong>在技术领域中，没有银弹</strong>。我们需要不断探索和研究新的技术，但同时也需要认识到技术的局限性，不盲目追求所谓的“银弹”，而是结合具体问题和需求，选择最适合的解决方案。</p>
]]></content>
    <category term="cache"/>
    <published>2023-11-17T13:31:29.000Z</published>
  </entry>
  <entry>
    <title type="text"></title>
    <id>https://javayong.cn/googlef80b0a25b49e7dc1.html</id>
    <link href="https://javayong.cn/googlef80b0a25b49e7dc1.html"/>
    <updated>2023-11-17T11:08:04.000Z</updated>
    <summary type="html"><![CDATA[<p>google-site-verification: googlef80b0a25b49e7dc1.html</p>
]]></summary>
    <content type="html"><![CDATA[<p>google-site-verification: googlef80b0a25b49e7dc1.html</p>
]]></content>
    <published>2023-11-17T11:08:04.000Z</published>
  </entry>
  <entry>
    <title type="text">四种强大的JDK本地缓存</title>
    <id>https://javayong.cn/cache/01fourJDKlocalcache.html</id>
    <link href="https://javayong.cn/cache/01fourJDKlocalcache.html"/>
    <updated>2023-11-16T08:17:07.000Z</updated>
    <summary type="html"><![CDATA[<p>这篇文章，笔者想聊聊那些在业务系统中较少被使用，但却活跃于中间件或者框架里，强大却又低调的缓存，<strong>笔者愿称他们为缓存世界的扫地僧</strong>。</p>
<figure><img src="https://javayong.cn/pics/cache/cachesaodisheng.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 HashMap/ConcurrentHashMap 配置缓存</h2>
<p>HashMap 是一种基于哈希表的集合类，它提供了快速的插入、查找和删除操作。</p>]]></summary>
    <content type="html"><![CDATA[<p>这篇文章，笔者想聊聊那些在业务系统中较少被使用，但却活跃于中间件或者框架里，强大却又低调的缓存，<strong>笔者愿称他们为缓存世界的扫地僧</strong>。</p>
<figure><img src="https://javayong.cn/pics/cache/cachesaodisheng.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 HashMap/ConcurrentHashMap 配置缓存</h2>
<p>HashMap 是一种基于哈希表的集合类，它提供了快速的插入、查找和删除操作。</p>
<p>HashMap 是很多程序员接触的第一种缓存 , 因为现实业务场景里，我们可能需要给缓存添加<strong>缓存统计</strong>、<strong>过期失效</strong>、<strong>淘汰策略</strong>等功能，HashMap 的功能就显得孱弱 ，所以 HashMap 在业务系统中使用得并不算多。</p>
<p>但 <strong>HashMap 在中间件中却是香饽饽</strong>，我们消息中间件 RocketMQ 为例。</p>
<figure><img src="https://javayong.cn/pics/cache/rocketmq架构.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>上图是 RocketMQ 的集群模式 ，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master 。</p>
<p>每个 Broker 与 Name Server 集群中的所有节点建立长连接，定时每隔 30 秒注册 <strong>主题的路由信息</strong>到所有 Name Server。</p>
<p>消息发送者、消息消费者，在同一时间只会连接  Name Server 集群中的一台服务器，并且会每隔 30s 会定时更新 Topic 的路由信息。</p>
<p>我们可以理解 Name Server 集群的作用就是<strong>注册中心</strong>，注册中心会保存<strong>路由信息</strong>（主题的读写队列数、操作权限等），路由信息就是保存在 <strong>HashMap</strong> 中 。</p>
<figure><img src="https://javayong.cn/pics/cache/rocketmqhash.webp?" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>路由信息通过几个 HashMap 来保存，当 Broker 向 Nameserver 发送心跳包（路由信息），Nameserver 需要对 HashMap 进行数据更新，但我们都知道 HashMap 并不是线程安全的，高并发场景下，容易出现 CPU 100% 问题，所以更新 HashMap 时需要加锁，RocketMQ 使用了 JDK 的读写锁 ReentrantReadWriteLock 。</p>
<p>下面我们看下路由信息如何更新和读取：</p>
<p><strong>1、写操作：更新路由信息，操作写锁</strong></p>
<figure><img src="https://javayong.cn/pics/cache/读写锁.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>2、读操作：查询主题信息，操作读锁</strong></p>
<figure><img src="https://javayong.cn/pics/cache/readlock.webp?" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>同时，我们需要注意 Name Server 维护路由信息还需要定时任务的支撑。</p>
<ul>
<li>每个 Broker 定时每隔 30 秒注册 <strong>主题的路由信息</strong>到所有 Name Server</li>
<li>Name Server 定时任务每隔10 秒清除已宕机的 Broker</li>
</ul>
<p>我们做一个小小的总结，Name Server 维护路由的模式是： <strong>HashMap + 读写锁 + 定时任务更新</strong>。</p>
<ul>
<li>HashMap 作为存储容器</li>
<li>读写锁控制锁的颗粒度</li>
<li>定时任务定时更新缓存</li>
</ul>
<p>写到这里，我们不禁想到 ConcurrentHashMap  。</p>
<p>ConcurrentHashMap 可以保证线程安全，JDK1.7 之前使用<strong>分段锁机制</strong>实现，JDK1.8 则使用<strong>数组+链表+红黑树</strong>数据结构和<strong>CAS原子操作</strong>实现。</p>
<p>Broker 使用不同的 ConcurrentHashMap 分别用来存储消费组、消费进度、消息过滤信息等。</p>
<p>那么名字服务为什么不使用 ConcurrentHashMap 作为存储容器呢 ？</p>
<p>最核心的原因在于：路由信息由多个 HashMap 组成，通过每次写操作可能要操作多个对象 ，为了保证其一致性，所以才需要加读写锁。</p>
<h2> 2 LinkedHashMap 最近最少使用缓存</h2>
<p>LinkedHashMap 是 HashMap 的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。</p>
<p>LinkedHashMap 支持两种顺序<strong>插入顺序 、 访问顺序</strong>。</p>
<ul>
<li><strong>插入顺序</strong>：先添加的在前面，后添加的在后面，修改操作并不影响顺序</li>
<li><strong>访问顺序</strong>：问指的是 get/put 操作，对一个键执行 get/put 操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</li>
</ul>
<p>LinkedHashMap 经典的用法是作为 LruCache (最近最少使用缓存) ，而 MyBatis 的二级缓存的淘汰机制就是使用的 LinkedHashMap 。</p>
<p>MyBatis 的二级缓存是使用<strong>责任链</strong>+ <strong>装饰器</strong>的设计模式实现的。</p>
<figure><img src="https://javayong.cn/pics/cache/mybatisjar.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>上图中，装饰器包目录下 Cache 接口有不同的实现类，比如<strong>过期淘汰</strong>、<strong>日志记录</strong>等。</p>
<figure><img src="https://javayong.cn/pics/cache/lrucache.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>LruCache 使用了装饰器模式 ，使用 LinkedHashMap 默认保存 1024 个缓存 key ，当 key 最久未被访问，并且 keyMap 的大小超过 1024 时 ，记录最老的 key ，当下次添加缓存对象时，删除最老的 key。</p>
<p>使用 LinkedHashMap 重点需要做到<strong>使用访问顺序模式</strong>和<strong>重写 removeEldestEntry 方法</strong>。 因为 LinkedHashMap 并不是线程安全的，Mybatis 二级缓存责任链中 SynchronizedCache 对象可以实现线程安全的对缓存读写。</p>
<h2> 3 TreeMap 排序对象缓存</h2>
<p>TreeMap 是一种基于红黑树的有序 Map，它可以按照键的顺序进行遍历。</p>
<p>TreeMap 有两种应用场景让笔者印象极为深刻 ，他们分别是一致性哈希算法和 RocketMQ 消费快照 。</p>
<p>本文重点介绍 TreeMap 在一致性哈希算法中的应用。</p>
<p>一致性哈希（Consistent Hashing）算法被广泛应用于缓存系统、分布式数据库、负载均衡器等分布式系统中，以实现高性能和高可用性。它解决了传统哈希算法在动态环境下扩展性和负载均衡性能的问题。</p>
<p>一致性哈希的主要优点是在节点增减时，只有少量的数据需要重新映射，因为只有那些直接或间接与新增或删除节点相邻的数据项需要迁移。这大大减少了系统的迁移开销和影响，使得系统更具扩展性和可伸缩性。</p>
<p>TreeMap 在一致性哈希中可以用作节点/虚拟节点的存储结构，用来维护节点在哈希环上的位置和键的有序性。</p>
<p><strong>1、我们定义一个 TreeMap 存储节点/虚拟节点 。</strong></p>
<figure><img src="https://javayong.cn/pics/cache/consistenttreemap.png?" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>2、初始化节点</strong></p>
<p>构造函数包含三个部分：物理节点集合、每个物理节点对应的虚拟节点个数、哈希函数 。</p>
<figure><img src="https://javayong.cn/pics/cache/consistentainit.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们重点看下添加节点逻辑：</p>
<figure><img src="https://javayong.cn/pics/cache/consistentaddnode.png?a=123" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>3、按照 key 查询节点</strong></p>
<p>添加完节点之后，节点分布类似下图：</p>
<figure><img src="https://javayong.cn/pics/cache/hashring0.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://javayong.cn/pics/cache/consistentroute.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>当需要定位某个 key 属于哪个节点时，先通过哈希函数计算 key 的哈希值，并在环上顺时针方向找到第一个大于等于该哈希值的节点位置。该节点即为数据的归属节点 。</p>
<p>我们添加一个新的节点 node5 , 从下图中，我们可以看到，影响的范围（深黄色）并不大 ，这也就是一致性哈希算法的优势。</p>
<figure><img src="https://javayong.cn/pics/cache/hashring1.png?" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 4 ByteBuffer 网络编程缓冲池</h2>
<p>ByteBuffer 是字节缓冲区，主要用于用户读取和缓存字节数据，多用于网络编程、文件 IO 处理等。</p>
<p>笔者第一次接触 ByteBuffer 是在分库分表中间件 Cobar 中 。在网络编程里，经常需要分配内存，在高并发场景下，性能压力比较大。</p>
<p>Cobar 抽象了一个 NIOProcessor 类用来处理网络请求，每个处理器初始化的时候都会创建一个缓冲池 BufferPool 。 BufferPool 用于池化 ByteBuffer ，这和我们平常使用的数据库连接池的思路是一致的。</p>
<figure><img src="https://javayong.cn/pics/cache/cobarbufferpool.png?a=1" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>下图展示了缓冲池 BufferPool 的源码：</p>
<figure><img src="https://javayong.cn/pics/cache/cobarbytebuffer.png?b=2" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>缓冲池 BufferPool 的核心功能是<strong>分配缓存</strong>和<strong>回收缓存</strong> ，通过将缓存池化，可以大大提升系统的性能。</p>
<p>如今 ，Netty 内置了更为强大的内存池化工具 ByteBuf ，我们会在后面的文章里详聊。</p>
<h2> 5 写到最后</h2>
<p>这篇文章，笔者总结了四种<strong>强大且低调</strong>的缓存。</p>
<p>1、HashMap/ConcurrentHashMap 经常用于配置缓存，对于 HashMap 来讲，<strong>HashMap + 读写锁 + 定时任务更新</strong>是常用的模式。而 ConcurrentHashMap 广泛存在于各种中间件，线程安全且灵活易用。</p>
<p>2、LinkedHashMap 经常被用于创建最近最少使用缓存 LruCache 。推荐学习 Mybatis 二级缓存的设计，它使用<strong>责任链</strong>+ <strong>装饰器</strong>的设计模式，内置 LruCache 的实现就是使用 LinkedHashMap 。</p>
<p>3、TreeMap 是一种基于红黑树的有序 Map 。TreeMap 在一致性哈希中可以用作节点/虚拟节点的存储结构，用来维护节点在哈希环上的位置和键的有序性。</p>
<p>4、ByteBuffer 是字节缓冲区，主要用于用户读取和缓存字节数据，多用于网络编程、文件 IO 处理等。分库分表中间件 Cobar 在网络请求处理中，创建了缓冲池 BufferPool 用于池化 ByteBuffer ，从而大大提升系统的性能。</p>
]]></content>
    <category term="cache"/>
    <published>2023-11-16T08:17:07.000Z</published>
  </entry>
  <entry>
    <title type="text">聊聊分页列表缓存</title>
    <id>https://javayong.cn/cache/02pagelistcache.html</id>
    <link href="https://javayong.cn/cache/02pagelistcache.html"/>
    <updated>2023-11-16T13:16:12.000Z</updated>
    <summary type="html"><![CDATA[<p>开源中国的红薯哥写了很多关于缓存的文章，其中多级缓存思路，分页列表缓存这些知识点给了我很大的启发性。</p>
<p>写这篇文章，我们聊聊<strong>分页列表缓存</strong>，希望能帮助大家提升缓存技术认知。</p>
<h2> 1 直接缓存分页列表结果</h2>
<p>显而易见，这是最简单易懂的方式。</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536756-1162415241.png" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>开源中国的红薯哥写了很多关于缓存的文章，其中多级缓存思路，分页列表缓存这些知识点给了我很大的启发性。</p>
<p>写这篇文章，我们聊聊<strong>分页列表缓存</strong>，希望能帮助大家提升缓存技术认知。</p>
<h2> 1 直接缓存分页列表结果</h2>
<p>显而易见，这是最简单易懂的方式。</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536756-1162415241.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们按照不同的分页条件来缓存分页结果 ，伪代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方案的优点是工程简单，性能也快，但是有一个非常明显的缺陷基因：<strong>列表缓存的颗粒度非常大</strong>。</p>
<p>假如列表中数据发生增删，为了保证数据的一致性，需要修改分页列表缓存。</p>
<p>有两种方式 ：</p>
<p>1、依靠缓存过期来惰性的实现 ，但业务场景必须包容；</p>
<p>2、使用 Redis 的 keys 找到该业务的分页缓存，执行删除指令。 但 keys 命令对性能影响很大，会导致 Redis 很大的延迟 。</p>
<h2> 2 查询对象ID列表，再缓存每个对象条目</h2>
<p>缓存分页结果虽然好用，但缓存的颗粒度太大，保证数据一致性比较麻烦。</p>
<p>所以我们的目标是<strong>更细粒度的控制缓存</strong> 。</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535770-925522893.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们查询出商品分页对象ID列表，然后为每一个商品对象创建缓存 ,  通过商品ID和商品对象缓存聚合成列表返回给前端。</p>
<p>伪代码如下：<img src="https://www.javayong.cn/pics/cache//2487169-20230523161536367-1808772045.png" alt=""></p>
<p>核心流程：</p>
<p><strong>1、从数据库中查询分页 ID 列表</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的 SQL 类似：</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、批量从缓存中获取商品对象</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>假如我们使用本地缓存，直接一条一条从本地缓存中聚合也极快。</p>
<p>假如我们使用分布式缓存，Redis 天然支持批量查询的命令 ，比如 mget ，hmget 。</p>
<p><strong>3、组装没有命中的商品ID</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为缓存中可能因为过期或者其他原因导致缓存没有命中的情况，所以我们需要找到哪些商品没有在缓存里。</p>
<p><strong>4、批量从数据库查询未命中的商品信息列表，重新加载到缓存</strong></p>
<p>首先从数据库里<strong>批量</strong>查询出未命中的商品信息列表 ，请注意是<strong>批量</strong>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数是未命中缓存的商品ID列表，组装成对应的 SQL，这样性能更快 ：</p>
<div class="language-SQL line-numbers-mode" data-ext="SQL"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后这些未命中的商品信息存储到缓存里 , 使用 Redis 的 mset 命令。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5、 遍历商品ID列表，组装对象列表</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前方案里，缓存都有命中的情况下，经过两次网络 IO ，第一次数据库查询 IO ，第二次 Redis 查询 IO ,  性能都会比较好。</p>
<p>所有的操作都是批量操作，就算有缓存没有命中的情况，整体速度也较快。</p>
<p>”<strong>查询对象ID列表，再缓存每个对象条目</strong>“ 这个方案比较灵活，当我们<strong>查询对象ID列表</strong>，可以不限于数据库，还可以是搜索引擎，Redis 等等。</p>
<p>下图是开源中国的搜索流程：</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535579-752010347.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>精髓在于：<strong>搜索的分页结果只包含业务对象 ID  ，对象的详细资料需要从缓存 + MySQL 中获取。</strong></p>
<h2> 3 缓存对象ID列表,同时缓存每个对象条目</h2>
<p>笔者曾经重构过类似朋友圈的服务，进入班级页面 ，瀑布流的形式展示班级成员的所有动态。</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536234-1479945726.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们使用推模式将每一条动态 ID 存储在 Redis  ZSet 数据结构中 。Redis ZSet 是一种类型为有序集合的数据结构，它由多个有序的唯一的字符串元素组成，每个元素都关联着一个浮点数分值。</p>
<p>ZSet 使用的是 member -&gt; score 结构 ：</p>
<ul>
<li>member : 被排序的标识，也是默认的第二排序维度（ score 相同时，Redis 以 member 的字典序排列）</li>
<li>score : 被排序的分值，存储类型是 double</li>
</ul>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536124-570559847.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>如上图所示：<strong>ZSet 存储动态 ID 列表  ,  member 的值是动态编号 , score 值是创建时间</strong>。</p>
<p>通过 ZSet 的 <strong>ZREVRANGE 命令</strong>就可以实现分页的效果。</p>
<p>ZREVRANGE 是 Redis 中用于有序集合（sorted set）的命令之一，它用于按照成员的分数从大到小返回有序集合中的指定范围的成员。</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535893-748949994.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>为了达到分页的效果，传递如下的分页参数 ：</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535058-1294698241.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>通过 ZREVRANGE 命令，我们可以查询出动态 ID 列表。</p>
<p>查询出动态 ID 列表后，还需要缓存每个动态对象条目，动态对象包含了详情，评论，点赞，收藏这些功能数据 ，我们需要为这些数据提供单独做缓存配置。</p>
<figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536578-881577270.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>无论是查询缓存，还是重新写入缓存，为了提升系统性能，批量操作效率更高。</p>
<p>若**缓存对象结构简单，使用 mget 、hmget 命令；若结构复杂，可以考虑使用 pipleline，Lua 脚本模式 。**笔者选择的批量方案是 Redis 的 pipleline 功能。</p>
<p>我们再来模拟获取动态分页列表的流程：</p>
<ol>
<li>使用 ZSet 的 ZREVRANGE 命令 ，传入分页参数，查询出动态 ID 列表 ；</li>
<li>传递动态 ID 列表参数，通过 Redis 的 pipleline 功能从缓存中批量获取动态的详情，评论，点赞，收藏这些功能数据 ，组装成列表 。</li>
</ol>
<h2> 4 总结</h2>
<p>本文介绍了实现分页列表缓存的三种方式：</p>
<ol>
<li>
<p>直接缓存分页列表结果</p>
</li>
<li>
<p>查询对象ID列表，只缓存每个对象条目</p>
</li>
<li>
<p>缓存对象ID列表，同时缓存每个对象条目</p>
</li>
</ol>
<p>这三种方式是一层一层递进的，要诀是：</p>
<p><strong>细粒度的控制缓存</strong>和<strong>批量加载对象</strong>。</p>
]]></content>
    <category term="cache"/>
    <published>2023-11-16T08:17:07.000Z</published>
  </entry>
  <entry>
    <title type="text">详解布隆过滤器</title>
    <id>https://javayong.cn/cache/05boolfilter.html</id>
    <link href="https://javayong.cn/cache/05boolfilter.html"/>
    <updated>2023-11-20T05:15:08.000Z</updated>
    <summary type="html"><![CDATA[<p>布隆过滤器是一个精巧而且经典的数据结构。</p>
<p>你可能没想到： RocketMQ、 Hbase 、Cassandra 、LevelDB 、RocksDB 这些知名项目中都有布隆过滤器的身影。</p>
<p>对于后端程序员来讲，学习和理解布隆过滤器有很大的必要性。来吧，我们一起品味布隆过滤器的设计之美。</p>
<figure><img src="https://www.javayong.cn/pics/temp//gGTKn38KyF.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 缓存穿透</h2>]]></summary>
    <content type="html"><![CDATA[<p>布隆过滤器是一个精巧而且经典的数据结构。</p>
<p>你可能没想到： RocketMQ、 Hbase 、Cassandra 、LevelDB 、RocksDB 这些知名项目中都有布隆过滤器的身影。</p>
<p>对于后端程序员来讲，学习和理解布隆过滤器有很大的必要性。来吧，我们一起品味布隆过滤器的设计之美。</p>
<figure><img src="https://www.javayong.cn/pics/temp//gGTKn38KyF.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 缓存穿透</h2>
<p>我们先来看一个商品服务查询详情的接口：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://www.javayong.cn/pics/temp//szzXnQVHGA.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>假设此商品既不存储在缓存中，也不存在数据库中，则没有办法<strong>回写缓存</strong>，当有类似这样大量的请求访问服务时，数据库的压力就会极大。</p>
<p>这是一个典型的缓存穿透的场景。</p>
<p>为了解决这个问题呢，通常我们可以向分布式缓存中写入一个过期时间较短的空值占位，但这样会占用较多的存储空间，性价比不足。</p>
<p>问题的本质是："<strong>如何以极小的代价检索一个元素是否在一个集合中</strong>？"</p>
<p>我们的主角<strong>布隆过滤器</strong>出场了，它就能游刃有余的<strong>平衡好时间和空间两种维度</strong>。</p>
<h2> 2 原理解析</h2>
<p><strong>布隆过滤器</strong>（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<strong>二进制向量</strong>和一系列<strong>随机映射函数</strong>。</p>
<p>布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是<strong>空间效率</strong>和<strong>查询时间</strong>都<strong>远远超过一般的算法</strong>，缺点是有一定的误识别率和删除困难。</p>
<p>布隆过滤器的原理：当一个元素被加入集合时，通过 K 个散列函数将这个元素映射成一个位数组中的 K 个点，把它们置为 1。检索时，我们只要看看这些点是不是都是 1 就（大约）知道集合中有没有它了：如果这<strong>些点有任何一个 0</strong>，则<strong>被检元素一定不在</strong>；如果<strong>都是 1</strong>，则被检元素<strong>很可能在</strong>。</p>
<p>简单来说就是准备一个长度为 m 的位数组并初始化所有元素为 0，用 k 个散列函数对元素进行 k 次散列运算跟 len (m) 取余得到 k 个位置并将 m 中对应位置设置为 1。</p>
<figure><img src="https://www.javayong.cn/pics/temp//Qcb9oB5g1v.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>如上图，位数组的长度是８，散列函数个数是 3，先后保持两个元素ｘ，ｙ。这两个元素都经过三次哈希函数生成三个哈希值，并映射到位数组的不同的位置，并置为1。元素 x 映射到位数组的第０位，第４位，第７位，元素ｙ映射到数组的位数组的第１位，第４位，第６位。</p>
<p>保存元素 x 后，位数组的第4位被设置为1之后，在处理元素 y 时第4位会被覆盖，同样也会设置为 1。</p>
<p>当布隆过滤器<strong>保存的元素越多</strong>，<strong>被置为 1 的 bit 位也会越来越多</strong>，元素 x 即便没有存储过，假设哈希函数映射到位数组的三个位都被其他值设置为 1 了，对于布隆过滤器的机制来讲，元素 x 这个值也是存在的，也就是说布隆过滤器<strong>存在一定的误判率</strong>。</p>
<p><strong>▍ 误判率</strong></p>
<p>布隆过滤器包含如下四个属性：</p>
<ul>
<li>
<p>k : 哈希函数个数</p>
</li>
<li>
<p>m : 位数组长度</p>
</li>
<li>
<p>n : 插入的元素个数</p>
</li>
<li>
<p>p : 误判率</p>
</li>
</ul>
<p>若位数组长度太小则会导致所有 bit 位很快都会被置为 1 ，那么检索任意值都会返回”可能存在“ ， 起不到过滤的效果。 位数组长度越大，则误判率越小。</p>
<p>同时，哈希函数的个数也需要考量，哈希函数的个数越大，检索的速度会越慢，误判率也越小，反之，则误判率越高。</p>
<figure><img src="https://www.javayong.cn/pics/temp//9JhROcXyEi.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>从张图我们可以观察到相同位数组长度的情况下，随着哈希函数的个人的增长，误判率显著的下降。</p>
<p>误判率 p 的公式是<img src="https://www.javayong.cn/pics/temp//NntKce0NiK.webp!large" alt=""></p>
<p>1. k 次哈希函数某一 bit 位未被置为 1 的概率为<img src="https://www.javayong.cn/pics/temp//AeAm0pE51W.webp!large" alt=""></p>
<p>2. 插入 n 个元素后某一 bit 位依旧为 0 的概率为<img src="https://www.javayong.cn/pics/temp//JWSFwFmn1w.webp!large" alt=""></p>
<p>3. 那么插入 n 个元素后某一 bit 位置为1的概率为<img src="https://www.javayong.cn/pics/temp//45NmbP5AEk.webp!large" alt="">
4. 整体误判率为 <img src="https://www.javayong.cn/pics/temp//786m1xNDFG.webp!large" alt="">，当 m 足够大时，误判率会越小，该公式约等于<img src="https://www.javayong.cn/pics/temp//VsYuYA5bWH.webp!large" alt=""></p>
<p>我们会预估布隆过滤器的误判率 p 以及待插入的元素个数 n 分别推导出最合适的位数组长度 m 和 哈希函数个数 k。</p>
<img src="https://www.javayong.cn/pics/temp//up-f6c28a2073b26b6a18f7615b2a34c4fbf98.jpg" style="zoom:43%;">
<p><strong>▍ 布隆过滤器支持删除吗</strong></p>
<p>布隆过滤器其实并不支持删除元素，因为多个元素可能哈希到一个布隆过滤器的同一个位置，如果直接删除该位置的元素，则会影响其他元素的判断。</p>
<p><strong>▍ 时间和空间效率</strong></p>
<p>布隆过滤器的空间复杂度为 O(m) ，插入和查询时间复杂度都是 O(k) 。 存储空间和插入、查询时间都不会随元素增加而增大。 空间、时间效率都很高。</p>
<p><strong>▍哈希函数类型</strong></p>
<p>Murmur3，FNV 系列和 Jenkins 等非密码学哈希函数适合，因为 Murmur3 算法简单，能够平衡好速度和随机分布，很多开源产品经常选用它作为哈希函数。</p>
<h2> 3 Guava实现</h2>
<p>Google Guava是 Google 开发和维护的开源 Java开发库，它包含许多基本的工具类，例如字符串处理、集合、并发工具、I/O和数学函数等等。</p>
<p><strong>1、添加Maven依赖</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、创建布隆过滤器</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3、添加数据</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4、判断数据是否存在</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来，我们查看 Guava 源码中布隆过滤器是如何实现的 ？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Guava 的计算位数组长度和哈希次数和原理解析这一节展示的公式保持一致。</p>
<p>重点来了，Bloom filter 是如何判断元素存在的 ？</p>
<p>方法名就非常有 google 特色 ， ”<strong>mightContain</strong>“ 的中文表意是：”可能存在“ 。<strong>方法的返回值为 true ，元素可能存在，但若返回值为 false ，元素必定不存在。</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4 Redisson实现</h2>
<p>Redisson 是一个用 Java 编写的 Redis 客户端，它实现了分布式对象和服务，包括集合、映射、锁、队列等。Redisson的API简单易用，使得在分布式环境下使用Redis 更加容易和高效。</p>
<p><strong>1、添加Maven依赖</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、配置 Redisson 客户端</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3、初始化</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>4、判断数据是否存在</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>好，我们来从源码分析 Redisson 布隆过滤器是如何实现的 ？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://www.javayong.cn/pics/temp//nSbowXJ8Dk.webp!large" alt="Bf配置信息" tabindex="0"><figcaption>Bf配置信息</figcaption></figure>
<p>Redisson 布隆过滤器初始化的时候，会创建一个 Hash 数据结构的 key ，存储布隆过滤器的4个核心属性。</p>
<p>那么 Redisson 布隆过滤器如何保存元素呢 ？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从源码中，我们发现 Redisson 布隆过滤器操作的对象是 <strong>位图（bitMap）</strong> 。</p>
<p>在 Redis 中，位图本质上是 string 数据类型，Redis 中一个字符串类型的值最多能存储 512 MB 的内容，每个字符串由多个字节组成，每个字节又由 8 个 Bit 位组成。位图结构正是使用“位”来实现存储的，它通过将比特位设置为 0 或 1来达到数据存取的目的，它存储上限为 <code>2^32 </code>，我们可以使用<code>getbit/setbit</code>命令来处理这个位数组。</p>
<p>为了方便大家理解，我做了一个简单的测试。</p>
<figure><img src="https://www.javayong.cn/pics/temp//9GDwxhCukO.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>通过 Redisson API 创建 key 为 <code>mybitset </code>的 位图 ，设置索引 3 ，5，6，8 位为 1 ，右侧的<strong>二进制值</strong>也完全匹配。</p>
<h2> 5 实战要点</h2>
<p>通过 Guava 和 Redisson 创建和使用布隆过滤器比较简单，我们下面讨论实战层面的注意事项。</p>
<p><strong>1、缓存穿透场景</strong></p>
<p>首先我们需要<strong>初始化</strong>布隆过滤器，然后当用户请求时，判断过滤器中是否包含该元素，若不包含该元素，则直接返回不存在。</p>
<p>若包含则从缓存中查询数据，若缓存中也没有，则查询数据库并回写到缓存里，最后给前端返回。</p>
<figure><img src="https://www.javayong.cn/pics/temp//f6Avy1Movi.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>2、元素删除场景</strong></p>
<p>现实场景，元素不仅仅是只有增加，还存在删除元素的场景，比如说商品的删除。</p>
<p>原理解析这一节，我们已经知晓：<strong>布隆过滤器其实并不支持删除元素，因为多个元素可能哈希到一个布隆过滤器的同一个位置，如果直接删除该位置的元素，则会影响其他元素的判断</strong>。</p>
<p>从工程角度来看，<strong>定时重新构建布隆过滤器</strong>这个方案可行也可靠，同时也相对简单。</p>
<figure><img src="https://www.javayong.cn/pics/temp//wp53mfGqZW.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<ol>
<li>定时任务触发全量商品查询 ;</li>
<li>将商品编号添加到新的布隆过滤器 ;</li>
<li>任务完成，修改商品布隆过滤器的映射（从旧 A 修改成 新 B ）;</li>
<li>商品服务根据布隆过滤器的映射，选择新的布隆过滤器 B进行相关的查询操作 ；</li>
<li>选择合适的时间点，删除旧的布隆过滤器 A。</li>
</ol>
<h2> 6 总结</h2>
<p><strong>布隆过滤器</strong>是一个很长的<strong>二进制向量</strong>和一系列<strong>随机映射函数</strong>，用于<strong>检索一个元素是否在一个集合中</strong>。</p>
<p>它的<strong>空间效率</strong>和<strong>查询时间</strong>都<strong>远远超过一般的算法</strong>，但是有一定的误判率 （函数返回 true , 意味着元素可能存在，函数返回 false ，元素必定不存在）。</p>
<p>布隆过滤器的四个核心属性：</p>
<ul>
<li>
<p>k : 哈希函数个数</p>
</li>
<li>
<p>m : 位数组长度</p>
</li>
<li>
<p>n : 插入的元素个数</p>
</li>
<li>
<p>p : 误判率</p>
</li>
</ul>
<p>Java 世界里 ，通过 Guava 和 Redisson 创建和使用布隆过滤器非常简单。</p>
<p>布隆过滤器无法删除元素，但我们可以通过<strong>定时重新构建布隆过滤器</strong>方案实现删除元素的效果。</p>
<p>为什么这么多的开源项目中使用布隆过滤器 ？</p>
<p>因为它的设计精巧且简洁，工程上实现非常容易，效能高，虽然有一定的误判率，但软件设计不就是要 trade off 吗 ？</p>
<hr>
<p>参考资料：</p>
<blockquote>
<p>https://hackernoon.com/probabilistic-data-structures-bloom-filter-5374112a7832</p>
</blockquote>
]]></content>
    <category term="cache"/>
    <published>2023-11-16T08:17:07.000Z</published>
  </entry>
  <entry>
    <title type="text">聊聊 Redis 事务</title>
    <id>https://javayong.cn/cache/07Redistransaction.html</id>
    <link href="https://javayong.cn/cache/07Redistransaction.html"/>
    <updated>2023-11-20T05:20:32.000Z</updated>
    <summary type="html"><![CDATA[<p>准确的讲，Redis 事务包含两种模式 : <strong>事务模式</strong> 和 <strong>Lua 脚本</strong>。</p>
<p>先说结论：</p>
<p>Redis 的事务模式具备如下特点：</p>
<ul>
<li>保证隔离性；</li>
<li>无法保证持久性；</li>
<li>具备了一定的原子性，但不支持回滚；</li>
<li>一致性的概念有分歧，假设在一致性的核心是约束的语意下，Redis 的事务可以保证一致性。</li>
</ul>
<p>但 Lua 脚本更具备实用场景，它是另一种形式的事务，他具备一定的原子性，但脚本报错的情况下，事务并不会回滚。Lua 脚本可以保证隔离性，而且可以完美的支持<strong>后面的步骤依赖前面步骤的结果</strong>。</p>]]></summary>
    <content type="html"><![CDATA[<p>准确的讲，Redis 事务包含两种模式 : <strong>事务模式</strong> 和 <strong>Lua 脚本</strong>。</p>
<p>先说结论：</p>
<p>Redis 的事务模式具备如下特点：</p>
<ul>
<li>保证隔离性；</li>
<li>无法保证持久性；</li>
<li>具备了一定的原子性，但不支持回滚；</li>
<li>一致性的概念有分歧，假设在一致性的核心是约束的语意下，Redis 的事务可以保证一致性。</li>
</ul>
<p>但 Lua 脚本更具备实用场景，它是另一种形式的事务，他具备一定的原子性，但脚本报错的情况下，事务并不会回滚。Lua 脚本可以保证隔离性，而且可以完美的支持<strong>后面的步骤依赖前面步骤的结果</strong>。</p>
<p><strong>Lua 脚本模式的身影几乎无处不在，比如分布式锁、延迟队列、抢红包等场景。</strong></p>
<h2> 1 事务原理</h2>
<p>Redis 的事务包含如下命令：</p>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">MULTI 标记一个事务块的开始。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">EXEC 执行所有事务块内的命令。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">DISCARD 取消事务，放弃执行事务块内的所有命令。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">WATCH key [key ...] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">UNWATCH 取消 WATCH 命令对所有 key 的监视。</td>
</tr>
</tbody>
</table>
<p>事务包含三个阶段：</p>
<ol>
<li>事务开启，使用 MULTI , 该命令标志着执行该命令的客户端从非事务状态切换至事务状态 ；</li>
<li>命令入队，MULTI 开启事务之后，客户端的命令并不会被立即执行，而是放入一个事务队列 ；</li>
<li>执行事务或者丢弃。如果收到 EXEC 的命令，事务队列里的命令将会被执行 ，如果是 DISCARD 则事务被丢弃。</li>
</ol>
<p>下面展示一个事务的例子。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有一个疑问？在开启事务的时候，Redis key 可以被修改吗？</p>
<figure><img src="https://www.javayong.cn/pics/temp//zgcHEZMogT.webp!large" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p><strong>在事务执行 EXEC 命令之前 ，Redis key 依然可以被修改</strong>。</p>
<p>在事务开启之前，我们可以 watch 命令监听 Redis key 。在事务执行之前，我们修改 key 值 ，事务执行失败，返回 <strong>nil</strong> 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//s5X2lsfqGT.webp!large" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>通过上面的例子，watch 命令可以<strong>实现类似乐观锁的效果</strong> 。</p>
<h2> 2 事务的ACID</h2>
<h3> 2.1 原子性</h3>
<p>原子性是指：一个事务中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>第一个例子：</p>
<p>在执行 EXEC 命令前，客户端发送的操作命令错误，比如：语法错误或者使用了不存在的命令。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个例子中，我们使用了不存在的命令，导致入队失败，整个事务都将无法执行 。</p>
<p>第二个例子：</p>
<p>事务操作入队时，命令和操作的数据类型不匹配 ，入队列正常，但执行 EXEC 命令异常 。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子里，Redis 在执行 EXEC 命令时，如果出现了错误，Redis 不会终止其它命令的执行，事务也不会因为某个命令执行失败而回滚 。</p>
<p>综上，我对 Redis 事务原子性的理解如下：</p>
<ol>
<li>命令入队时报错， 会放弃事务执行，保证原子性；</li>
<li>命令入队时正常，执行 EXEC 命令后报错，不保证原子性；</li>
</ol>
<p>也就是：<strong>Redis 事务在特定条件下，才具备一定的原子性</strong> 。</p>
<h3> 2.2 隔离性</h3>
<p>数据库的隔离性是指：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p>
<p>事务隔离分为不同级别 ，分别是：</p>
<ul>
<li>未提交读（read uncommitted）</li>
<li>提交读（read committed）</li>
<li>可重复读（repeatable read）</li>
<li>串行化（serializable）</li>
</ul>
<p>首先，需要明确一点：Redis 并没有事务隔离级别的概念。这里我们讨论 Redis 的隔离性是指：<strong>并发场景下，事务之间是否可以做到互不干扰</strong>。</p>
<p>我们可以将事务执行可以分为 <strong>EXEC 命令执行前</strong>和 <strong>EXEC 命令执行后</strong>两个阶段，分开讨论。</p>
<ol>
<li>EXEC 命令执行前</li>
</ol>
<p>在事务原理这一小节，我们发现在事务执行之前 ，Redis key 依然可以被修改。此时，可以使用 <strong>WATCH 机制</strong>来实现乐观锁的效果。</p>
<ol>
<li>EXEC 命令执行后</li>
</ol>
<p>因为 Redis 是单线程执行操作命令， EXEC 命令执行后，Redis 会保证命令队列中的所有命令执行完 。 这样就可以保证事务的隔离性。</p>
<h3> 2.3 持久性</h3>
<p>数据库的持久性是指 ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<p>Redis 的数据是否持久化取决于 Redis 的持久化配置模式 。</p>
<ol>
<li>没有配置 RDB 或者 AOF ，事务的持久性无法保证；</li>
<li>使用了 RDB模式，在一个事务执行后，下一次的 RDB 快照还未执行前，如果发生了实例宕机，事务的持久性同样无法保证；</li>
<li>使用了 AOF 模式；AOF 模式的三种配置选项 no 、everysec 都会存在数据丢失的情况  。always 可以保证事务的持久性，但因为性能太差，在生产环境一般不推荐使用。</li>
</ol>
<p>综上，<strong>redis 事务的持久性是无法保证的</strong> 。</p>
<h3> 2.4 一致性</h3>
<p>一致性的概念一直很让人困惑，在我搜寻的资料里，有两类不同的定义。</p>
<ol>
<li>维基百科</li>
</ol>
<p>我们先看下维基百科上一致性的定义：</p>
<blockquote>
<p>Consistency ensures that a transaction can only bring the database from one valid state to another, maintaining database invariants: any data written to the database must be valid according to all defined rules, including constraints, cascades, triggers, and any combination thereof. This prevents database corruption by an illegal transaction, but does not guarantee that a transaction is correct. Referential integrity guarantees the primary key – foreign key relationship.</p>
</blockquote>
<p>在这段文字里，一致性的核心是“<strong>约束</strong>”，“<strong>any data written to the database must be valid according to all defined rules</strong> ”。</p>
<p>如何理解约束？这里引用知乎问题 <strong>如何理解数据库的内部一致性和外部一致性</strong>，蚂蚁金服 OceanBase 研发专家韩富晟回答的一段话：</p>
<blockquote>
<p>“约束”由数据库的使用者告诉数据库，使用者要求数据一定符合这样或者那样的约束。当数据发生修改时，数据库会检查数据是否还符合约束条件，如果约束条件不再被满足，那么修改操作不会发生。</p>
<p>关系数据库最常见的两类约束是“唯一性约束”和“完整性约束”，表格中定义的主键和唯一键都保证了指定的数据项绝不会出现重复，表格之间定义的参照完整性也保证了同一个属性在不同表格中的一致性。</p>
<p>“ Consistency in ACID ”是如此的好用，以至于已经融化在大部分使用者的血液里了，使用者会在表格设计的时候自觉的加上需要的约束条件，数据库也会严格的执行这个约束条件。</p>
</blockquote>
<p>所以<strong>事务的一致性和预先定义的约束有关，保证了约束即保证了一致性</strong>。</p>
<p>我们细细品一品这句话： <strong>This prevents database corruption by an illegal transaction, but does not guarantee that a transaction is correct</strong>。</p>
<p>写到这里可能大家还是有点模糊，我们举经典<strong>转账</strong>的案例。</p>
<p>我们开启一个事务，张三和李四账号上的初始余额都是1000元，并且余额字段没有任何约束。张三给李四转账1200元。张三的余额更新为 -200 ， 李四的余额更新为2200。</p>
<p>从应用层面来看，这个事务明显不合法，因为现实场景中，用户余额不可能小于 0 ， 但是它完全遵循数据库的约束，所以从数据库层面来看，这个事务依然保证了一致性。</p>
<p>Redis 的事务一致性是指：Redis 事务在执行过程中符合数据库的约束，没有包含非法或者无效的错误数据。</p>
<p>我们分三种异常场景分别讨论：</p>
<ol>
<li>执行 EXEC 命令前，客户端发送的操作命令错误，事务终止，数据保持一致性；</li>
<li>执行 EXEC 命令后，命令和操作的数据类型不匹配，错误的命令会报错，但事务不会因为错误的命令而终止，而是会继续执行。正确的命令正常执行，错误的命令报错，从这个角度来看，数据也可以保持一致性；</li>
<li>执行事务的过程中，Redis 服务宕机。这里需要考虑服务配置的持久化模式。
<ul>
<li>无持久化的内存模式：服务重启之后，数据库没有保持数据，因此数据都是保持一致性的；</li>
<li>RDB / AOF 模式： 服务重启后，Redis 通过 RDB / AOF 文件恢复数据，数据库会还原到一致的状态。</li>
</ul>
</li>
</ol>
<p>综上所述，<strong>在一致性的核心是约束的语意下，Redis 的事务可以保证一致性</strong>。</p>
<ol>
<li>《设计数据密集型应用》</li>
</ol>
<p>这本书是分布式系统入门的神书。在事务这一章节有一段关于 ACID 的解释：</p>
<figure><img src="https://www.javayong.cn/pics/temp//zOQBAJrpdO.webp!large" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<blockquote>
<p>Atomicity, isolation, and durability are properties of the database,whereas consistency (in the ACID sense) is a property of the application. The application may rely on the database’s atomicity and isolation properties in order to achieve consistency, but it’s not up to the database alone. Thus, the letter C doesn’t really belong in ACID.</p>
</blockquote>
<p>原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是应用程序的属性。应用可能依赖数据库的原子性和隔离属性来实现一致性，但这并不仅取决于数据库。因此，字母 C 不属于 ACID 。</p>
<p>很多时候，我们一直在纠结的一致性，其实就是指<strong>符合现实世界的一致性</strong>，现实世界的一致性才是事务追求的最终目标。</p>
<p>为了实现现实世界的一致性，需要满足如下几点：</p>
<ol>
<li>保证原子性，持久性和隔离性，如果这些特征都无法保证，那么事务的一致性也无法保证；</li>
<li>数据库本身的约束，比如字符串长度不能超过列的限制或者唯一性约束；</li>
<li>业务层面同样需要进行保障 。</li>
</ol>
<h3> 2.5 事务特点</h3>
<p>我们通常称 Redis 为内存数据库 ,  不同于传统的关系数据库，为了提供了更高的性能，更快的写入速度，在设计和实现层面做了一些平衡，并不能完全支持事务的 ACID。</p>
<p>Redis 的事务具备如下特点：</p>
<ul>
<li>保证隔离性；</li>
<li>无法保证持久性；</li>
<li>具备了一定的原子性，但不支持回滚；</li>
<li>一致性的概念有分歧，假设在一致性的核心是约束的语意下，Redis 的事务可以保证一致性。</li>
</ul>
<p>从工程角度来看，假设事务操作中每个步骤需要依赖上一个步骤返回的结果，则需要通过 watch 来实现乐观锁 。</p>
<h2> 3 Lua 脚本</h2>
<h3> 3.1 简介</h3>
<figure><img src="https://www.javayong.cn/pics/temp//0g0mSCwReL.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Lua 由标准 C 编写而成，代码简洁优美，几乎在所有操作系统和平台上都可以编译，运行。Lua 脚本可以很容易的被 C/C ++ 代码调用，也可以反过来调用 C/C++ 的函数，这使得 Lua 在应用程序中可以被广泛应用。</p>
<p>Lua 脚本在游戏领域大放异彩，大家耳熟能详的《大话西游II》，《魔兽世界》都大量使用 Lua 脚本。Java 后端工程师接触过的 api 网关，比如 <strong>Openresty</strong> ，<strong>Kong</strong> 都可以看到 Lua 脚本的身影。</p>
<p>从 Redis 2.6.0 版本开始， Redis内置的 Lua 解释器，可以实现在 Redis 中运行 Lua 脚本。</p>
<p>使用 Lua 脚本的好处 ：</p>
<ul>
<li>减少网络开销。将多个请求通过脚本的形式一次发送，减少网络时延。</li>
<li>原子操作。Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。</li>
<li>复用。客户端发送的脚本会永久存在 Redis 中，其他客户端可以复用这一脚本而不需要使用代码完成相同的逻辑。</li>
</ul>
<p>Redis Lua 脚本常用命令：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>命令及描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>EVAL script numkeys key [key ...] arg [arg ...] 执行 Lua 脚本。</td>
</tr>
<tr>
<td>2</td>
<td>EVALSHA sha1 numkeys key [key ...] arg [arg ...] 执行 Lua 脚本。</td>
</tr>
<tr>
<td>3</td>
<td>SCRIPT EXISTS script [script ...] 查看指定的脚本是否已经被保存在缓存当中。</td>
</tr>
<tr>
<td>4</td>
<td>SCRIPT FLUSH 从脚本缓存中移除所有脚本。</td>
</tr>
<tr>
<td>5</td>
<td>SCRIPT KILL 杀死当前正在运行的 Lua 脚本。</td>
</tr>
<tr>
<td>6</td>
<td>SCRIPT LOAD script 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本。</td>
</tr>
</tbody>
</table>
<h3> 3.2 EVAL 命令</h3>
<p>命令格式：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>说明：</p>
<ul>
<li><code>script</code>是第一个参数，为 Lua 5.1脚本；</li>
<li>第二个参数<code>numkeys</code>指定后续参数有几个 key；</li>
<li><code>key [key ...]</code>，是要操作的键，可以指定多个，在 Lua 脚本中通过<code>KEYS[1]</code>, <code>KEYS[2]</code>获取；</li>
<li><code>arg [arg ...]</code>，参数，在 Lua 脚本中通过<code>ARGV[1]</code>, <code>ARGV[2]</code>获取。</li>
</ul>
<p>简单实例：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面演示下 Lua 如何调用 Redis 命令 ，通过<code>redis.call()</code>来执行了 Redis 命令 。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 3.3 EVALSHA 命令</h3>
<p>使用 EVAL 命令每次请求都需要传输 Lua 脚本 ，若 Lua 脚本过长，不仅会消耗网络带宽，而且也会对 Redis 的性能造成一定的影响。</p>
<p>思路是先将 Lua 脚本先缓存起来 ,  返回给客户端 Lua 脚本的 sha1 摘要。 客户端存储脚本的 sha1 摘要 ，每次请求执行 EVALSHA  命令即可。</p>
<figure><img src="https://www.javayong.cn/pics/temp//zokNNe0Swx.webp!large" alt="img" tabindex="0"><figcaption>img</figcaption></figure>
<p>EVALSHA  命令基本语法如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>实例如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4 事务 VS Lua 脚本</h2>
<blockquote>
<p>从定义上来说， <strong>Redis 中的脚本本身就是一种事务</strong>， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用<strong>脚本要来得更简单，并且速度更快</strong>。</p>
<p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p>
<p>不过<strong>我们并不打算在短时间内就移除事务功能</strong>， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。</p>
<p>--  https://redis.io/</p>
</blockquote>
<p>Lua 脚本是另一种形式的事务，他具备一定的原子性，但脚本报错的情况下，事务并不会回滚。Lua 脚本可以保证隔离性，而且可以完美的支持<strong>后面的步骤依赖前面步骤的结果</strong>。</p>
<p><strong>Lua 脚本模式的身影几乎无处不在，比如分布式锁、延迟队列、抢红包等场景。</strong></p>
<p>不过在编写 Lua 脚本时，要注意如下两点：</p>
<ol>
<li>为了避免 Redis 阻塞，Lua 脚本业务逻辑不能过于复杂和耗时；</li>
<li>仔细检查和测试 Lua 脚本 ，因为执行 Lua 脚本具备一定的原子性，不支持回滚。</li>
</ol>
]]></content>
    <category term="cache"/>
    <published>2023-11-16T08:17:07.000Z</published>
  </entry>
  <entry>
    <title type="text">1 缓存穿透</title>
    <id>https://javayong.cn/cache/08cacherisk.html</id>
    <link href="https://javayong.cn/cache/08cacherisk.html"/>
    <updated>2023-11-16T08:17:07.000Z</updated>
    <summary type="html"><![CDATA[<figure><img src="https://javayong.cn/pics/cache/cacherisk.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h1> 1 缓存穿透</h1>
<h1> 2 缓存击穿</h1>
<h1> 3 缓存雪崩</h1>
<p>缓存雪崩指的是因为某些原因导致缓存中大量的数据同时失效或过期，导致后续请求都落到数据源上，令数据源在短时间内压力剧增。</p>
<p>为什么会出现缓存大量数据同时失效或者过期呢？</p>
<p><strong>1、大量缓存数据同时过期</strong></p>]]></summary>
    <content type="html"><![CDATA[<figure><img src="https://javayong.cn/pics/cache/cacherisk.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h1> 1 缓存穿透</h1>
<h1> 2 缓存击穿</h1>
<h1> 3 缓存雪崩</h1>
<p>缓存雪崩指的是因为某些原因导致缓存中大量的数据同时失效或过期，导致后续请求都落到数据源上，令数据源在短时间内压力剧增。</p>
<p>为什么会出现缓存大量数据同时失效或者过期呢？</p>
<p><strong>1、大量缓存数据同时过期</strong></p>
<p><strong>2、缓存服务出现故障</strong></p>
<p>出现这种情况，往往是系统有专门的缓存预热功能，也可能大量公共数据是由某一次冷操作加载的，这样都可能出现由此载入缓存的大批数据具有相同的过期时间，在同一时刻一起失效。</p>
<p>还有一种情况是缓存服务由于某些原因崩溃后重启，此时也会造成大量数据同时失效，这种现象被称为缓存雪崩。要避免缓存雪崩问题，通常会采取下面的三种办法：</p>
<p>解决方案通常包括使用分布式缓存部署、设置不同的过期时间、应用程序限流等措施来避免缓存失效时间集中在同一时间段，以及使用缓存预热和自动刷新机制等手段来减轻缓存压力。</p>
<ol>
<li>提升缓存系统可用性，建设分布式缓存的集群。</li>
<li>启用透明多级缓存，各个服务节点一级缓存中的数据通常会具有不一样的加载时间，也就分散了它们的过期时间。</li>
<li>将缓存的生存期从固定时间改为一个时间段内的随机时间，譬如原本是一个小时过期，那可以缓存不同数据时，设置生存期为 55 分钟到 65 分钟之间的某个随机时间。</li>
</ol>
<h1> 4 缓存污染</h1>
]]></content>
    <published>2023-11-16T08:17:07.000Z</published>
  </entry>
  <entry>
    <title type="text">品味Spring Cache设计之美</title>
    <id>https://javayong.cn/cache/09SpringCache.html</id>
    <link href="https://javayong.cn/cache/09SpringCache.html"/>
    <updated>2023-11-17T08:13:01.000Z</updated>
    <summary type="html"><![CDATA[<p>最近负责教育类产品的架构工作，两位研发同学建议：“团队封装的<strong>Redis</strong>客户端可否适配<strong>Spring Cache</strong>，这样加缓存就会方便多了” 。</p>
<p>于是边查阅文档边实战，收获颇丰，写这篇文章，想和大家分享笔者学习的过程，一起品味Spring Cache设计之美。</p>
<figure><img src="https://www.javayong.cn/pics/temp//RK8gWPf7o2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>最近负责教育类产品的架构工作，两位研发同学建议：“团队封装的<strong>Redis</strong>客户端可否适配<strong>Spring Cache</strong>，这样加缓存就会方便多了” 。</p>
<p>于是边查阅文档边实战，收获颇丰，写这篇文章，想和大家分享笔者学习的过程，一起品味Spring Cache设计之美。</p>
<figure><img src="https://www.javayong.cn/pics/temp//RK8gWPf7o2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 硬编码</h2>
<p>在学习Spring Cache之前，笔者经常会硬编码的方式使用缓存。</p>
<p>举个例子，为了提升用户信息的查询效率，我们对用户信息使用了缓存，示例代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相信很多同学都写过类似风格的代码，这种风格符合面向过程的编程思维，非常容易理解。但它也有一些缺点：</p>
<ol>
<li>
<p>代码不够优雅。业务逻辑有四个典型动作：<strong>存储</strong>，<strong>读取</strong>，<strong>修改</strong>，<strong>删除</strong>。每次操作都需要定义缓存Key ，调用缓存命令的API，产生较多的<strong>重复代码</strong>；</p>
</li>
<li>
<p>缓存操作和业务逻辑之间的代码<strong>耦合度高</strong>，对业务逻辑有较强的侵入性。</p>
<p>侵入性主要体现如下两点：</p>
<ul>
<li>开发联调阶段，需要去掉缓存，只能注释或者临时删除缓存操作代码，也容易出错；</li>
<li>某些场景下，需要更换缓存组件，每个缓存组件有自己的API，更换成本颇高。</li>
</ul>
</li>
</ol>
<h2> 2 缓存抽象</h2>
<p>首先需要明确一点：Spring Cache不是一个具体的缓存实现方案，而是一个对(<strong>Cache Abstraction</strong>)。</p>
<figure><img src="https://www.javayong.cn/pics/temp//ZewikIryyK.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3> 2.1 Spring AOP</h3>
<p>Spring AOP是基于代理模式（<strong>proxy-based</strong>）。</p>
<p>通常情况下，定义一个对象，调用它的方法的时候，方法是直接被调用的。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://www.javayong.cn/pics/temp//9PtqLGrXss.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>将代码做一些调整，pojo对象的引用修改成代理类。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://www.javayong.cn/pics/temp//y2L0WUBAkn.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>调用pojo的foo方法的时候，实际上是动态生成的代理类调用foo方法。</p>
<p>代理类在方法调用前可以获取方法的参数，当调用方法结束后，可以获取调用该方法的返回值，通过这种方式就可以实现缓存的逻辑。</p>
<h3> 2.2 缓存声明</h3>
<p>缓存声明，也就是标识需要缓存的方法以及<strong>缓存策略</strong>。</p>
<p>Spring Cache 提供了五个注解。</p>
<ul>
<li>@Cacheable：根据方法的请求参数对其结果进行缓存，下次同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法；</li>
<li>@CachePut：根据方法的请求参数对其结果进行缓存，它每次都会触发真实方法的调用；</li>
<li>@CacheEvict：根据一定的条件删除缓存；</li>
<li>@Caching：组合多个缓存注解；</li>
<li>@CacheConfig：类级别共享缓存相关的公共配置。</li>
</ul>
<p>我们重点讲解：@Cacheable，@CachePut，@CacheEvict三个核心注解。</p>
<h4> 2.2.1 @Cacheable注解</h4>
<p>@Cacheble注解表示这个方法有了缓存的功能。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段里，<code>getUserById</code>方法和缓存<code>user_cache</code> 关联起来，若方法返回的User对象不为空，则缓存起来。第二次相同参数userId调用该方法的时候，直接从缓存中获取数据，并返回。</p>
<p><strong>▍ 缓存key的生成</strong></p>
<p>我们都知道，缓存的本质是<code>key-value</code>存储模式，每一次方法的调用都需要生成相应的Key, 才能操作缓存。</p>
<p>通常情况下，@Cacheable有一个属性key可以直接定义缓存key，开发者可以使用<a href="https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/expressions.html" target="_blank" rel="noopener noreferrer">SpEL</a>语言定义key值。</p>
<p>若没有指定属性key，缓存抽象提供了 <code>KeyGenerator</code>来生成key ，默认的生成器代码见下图：
<img src="https://www.javayong.cn/pics/temp//C4vvh1Bv7s.webp!large" alt=""></p>
<p>它的算法也很容易理解：</p>
<ul>
<li>如果没有参数，则直接返回<strong>SimpleKey.EMPTY</strong>；</li>
<li>如果只有一个参数，则直接返回该参数；</li>
<li>若有多个参数，则返回包含多个参数的<strong>SimpleKey</strong>对象。</li>
</ul>
<p>当然Spring Cache也考虑到需要自定义Key生成方式，需要我们实现<code>org.springframework.cache.interceptor.KeyGenerator</code> 接口。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后指定@Cacheable的keyGenerator属性。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>▍ 缓存条件</strong></p>
<p>有的时候，方法执行的结果是否需要缓存，依赖于方法的参数或者方法执行后的返回值。</p>
<p>注解里可以通过<code>condition</code>属性，通过Spel表达式返回的结果是true 还是false 判断是否需要缓存。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段里，当参数的长度小于32，方法执行的结果才会缓存。</p>
<p>除了condition，<code>unless</code>属性也可以决定结果是否缓存，不过是在执行方法后。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段里，当返回的结果为null则不缓存。</p>
<h4> 2.2.2 @CachePut注解</h4>
<p>@CachePut注解作用于缓存需要被更新的场景，和 @Cacheable 非常相似，但被注解的方法每次都会被执行。</p>
<p>返回值是否会放入缓存，依赖于condition和unless，默认情况下结果会存储到缓存。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当调用updateUser方法时，每次方法都会被执行，但是因为unless属性每次都是true，所以并没有将结果缓存。当去掉unless属性，则结果会被缓存。</p>
<h4> 2.2.3 @CacheEvict注解</h4>
<p>@CacheEvict 注解的方法在调用时会从缓存中移除已存储的数据。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当调用deleteUserById方法完成后，缓存key等于参数id的缓存会被删除，而且方法的返回的类型是Void ，这和@Cacheable明显不同。</p>
<h3> 2.3 缓存配置</h3>
<p>Spring Cache是一个对，它提供了多种存储集成。</p>
<figure><img src="https://www.javayong.cn/pics/temp//OjMqsOn5dA.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>要使用它们，需要简单地声明一个适当的<code>CacheManager</code> - 一个控制和管理<code>Cache</code>的实体。</p>
<p>我们以Spring Cache默认的缓存实现<strong>Simple</strong>例子，简单探索下CacheManager的机制。</p>
<p>CacheManager非常简单：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在CacheConfigurations配置类中，可以看到不同集成类型有不同的缓存配置类。</p>
<figure><img src="https://www.javayong.cn/pics/temp//vk9nmlzIbC.webp!large" alt="" tabindex="0"><figcaption>Simple</figcaption></figure>
<p>通过SpringBoot的自动装配机制，创建CacheManager的实现类<code>ConcurrentMapCacheManager</code>。</p>
<figure><img src="https://www.javayong.cn/pics/temp//GYJeXgi4Il.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>而<code>ConcurrentMapCacheManager</code>的getCache方法，会创建<code>ConcurrentCacheMap</code>。</p>
<figure><img src="https://www.javayong.cn/pics/temp//TTOwUF59LP.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><code>ConcurrentCacheMap</code>实现了<code>org.springframework.cache.Cache</code>接口。</p>
<figure><img src="https://www.javayong.cn/pics/temp//qd2d2wJdJz.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>从Spring Cache的<strong>Simple</strong>的实现，缓存配置需要实现两个接口：</p>
<ul>
<li>
<p><strong>org.springframework.cache.CacheManager</strong></p>
</li>
<li>
<p><strong>org.springframework.cache.Cache</strong></p>
</li>
</ul>
<h2> 3 入门例子</h2>
<p>首先我们先创建一个工程spring-cache-demo。</p>
<figure><img src="https://www.javayong.cn/pics/temp//QOyVUVjie7.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>caffeine和Redisson分别是本地内存和分布式缓存Redis框架中的佼佼者，我们分别演示如何集成它们。</p>
<h3> 3.1 集成caffeine</h3>
<h4> 3.1.1 maven依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.1.2 Caffeine缓存配置</h4>
<p>我们先创建一个缓存配置类MyCacheConfig。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先创建了一个Caffeine对象，该对象标识本地缓存的最大数量是10000条，每个缓存数据在写入60分钟后失效。</p>
<p>另外，MyCacheConfig类上我们添加了注解：<strong>@EnableCaching</strong>。</p>
<h4> 3.1.3 业务代码</h4>
<p>根据<strong>缓存声明</strong>这一节，我们很容易写出如下代码。</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码与硬编码里的代码片段明显精简很多。</p>
<p>当我们在Controller层调用 getUserById方法时，调试的时候，配置mybatis日志级别为DEBUG，方便监控方法是否会缓存。</p>
<p>第一次调用会查询数据库，打印相关日志：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二次调用查询方法的时候，数据库SQL日志就没有出现了， 也就说明缓存生效了。</p>
<h3> 3.2 集成Redisson</h3>
<h4> 3.2.1 maven依赖</h4>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 3.2.2 Redisson缓存配置</h4>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，从Caffeine切换到Redisson，只需要修改缓存配置类，定义<strong>CacheManager</strong> 对象即可。而业务代码并不需要改动。</p>
<p>Controller层调用 getUserById方法，用户ID为1的时候，可以从Redis Desktop Manager里看到： 用户信息已被缓存，user_cache缓存存储是Hash数据结构。</p>
<figure><img src="https://www.javayong.cn/pics/temp//dWCrSBzXSc.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>因为Redisson默认的编解码是<strong>FstCodec</strong>， 可以看到key的名称是： \xF6\x01。</p>
<p>在缓存配置代码里，可以修改编解码器。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次调用 getUserById方法 ，控制台就变成：</p>
<figure><img src="https://www.javayong.cn/pics/temp//Hh80EPVC0Z.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>可以观察到：缓存key已经变成了：["java.lang.Long",1]，改变序列化后key和value已发生了变化。</p>
<h3> 3.3 从列表缓存再次理解缓存抽象</h3>
<p>列表缓存在业务中经常会遇到。通常有两种实现形式：</p>
<ol>
<li>整体列表缓存；</li>
<li>按照每个条目缓存，通过redis，memcached的聚合查询方法批量获取列表，若缓存没有命中，则从数据库重新加载，并放入缓存里。</li>
</ol>
<p>那么Spring cache整合Redisson如何缓存列表数据呢？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行getUserList方法，参数id列表为：[1，3] 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//mOd6M7BgeW.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>执行完成之后，控制台里可以看到：，用户列表缓存和用户条目缓存并<strong>没有共享</strong>，他们是平行的关系。</p>
<p>这种情况下，缓存的颗粒度控制也没有那么细致。</p>
<p>类似这样的思考，很多开发者也向Spring Framework研发团队提过。</p>
<figure><img src="https://www.javayong.cn/pics/temp//UkXRc7g8O2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://www.javayong.cn/pics/temp//XHUWdfuvUv.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>官方的回答也很明确：对于缓存抽象来讲，它并不关心方法返回的数据类型，假如是集合，那么也就意味着需要把集合数据在缓存中保存起来。</p>
<p>还有一位开发者，定义了一个@<strong>CollectionCacheable</strong>注解，并做出了原型，扩展了Spring Cache的列表缓存功能。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>官方也未采纳，因为<strong>缓存抽象并不想引入太多的复杂性</strong>。</p>
<p>写到这里，相信大家对缓存抽象有了更进一步的理解。当我们想实现更复杂的缓存功能时，需要对Spring Cache做一定程度的扩展。</p>
<h2> 4 自定义二级缓存</h2>
<h3> 4.1 应用场景</h3>
<p>笔者曾经在原来的项目，高并发场景下多次使用多级缓存。多级缓存是一个非常有趣的功能点，值得我们去扩展。</p>
<p>多级缓存有如下优势：</p>
<ol>
<li>离用户越近，速度越快；</li>
<li>减少分布式缓存查询频率，降低序列化和反序列化的CPU消耗；</li>
<li>大幅度减少网络IO以及带宽消耗。</li>
</ol>
<p>进程内缓存做为一级缓存，分布式缓存做为二级缓存，首先从一级缓存中查询，若能查询到数据则直接返回，否则从二级缓存中查询，若二级缓存中可以查询到数据，则回填到一级缓存中，并返回数据。若二级缓存也查询不到，则从数据源中查询，将结果分别回填到一级缓存，二级缓存中。</p>
<figure><img src="https://www.javayong.cn/pics/temp//6jIXNdJbHp.webp!large" alt="来自《凤凰架构》缓存篇" tabindex="0"><figcaption>来自《凤凰架构》缓存篇</figcaption></figure>
<p>Spring Cache并没有二级缓存的实现，我们可以实现一个简易的二级缓存DEMO，加深对技术的理解。</p>
<h3> 4.2 设计思路</h3>
<ol>
<li><strong>MultiLevelCacheManager</strong>：多级缓存管理器；</li>
<li><strong>MultiLevelChannel</strong>：封装Caffeine和RedissonClient；</li>
<li><strong>MultiLevelCache</strong>：实现org.springframework.cache.Cache接口；</li>
<li><strong>MultiLevelCacheConfig</strong>：配置缓存过期时间等；</li>
</ol>
<p>MultiLevelCacheManager是最核心的类，需要实现<strong>getCache</strong>和<strong>getCacheNames</strong>两个接口。</p>
<figure><img src="https://www.javayong.cn/pics/temp//MlFyK4WSiF.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>创建多级缓存，第一级缓存是：Caffeine , 第二级缓存是：Redisson。</p>
<figure><img src="https://www.javayong.cn/pics/temp//JoL5oTXi6y.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>二级缓存，为了快速完成DEMO，我们使用Redisson对Spring Cache的扩展类<strong>RedissonCache</strong> 。它的底层是<strong>RMap</strong>，底层存储是Hash。</p>
<figure><img src="https://www.javayong.cn/pics/temp//Z4dbRzEVOa.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们重点看下缓存的「查询」和「存储」的方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>「<strong>查询</strong>」数据的流程：</p>
<ol>
<li>先从本地缓存中查询数据，若能查询到，直接返回；</li>
<li>本地缓存查询不到数据，查询分布式缓存，若可以查询出来，回填到本地缓存，并返回；</li>
<li>若分布式缓存查询不到数据，则默认会执行被注解的方法。</li>
</ol>
<p>下面来看下「<strong>存储</strong>」的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后配置缓存管理器，原有的业务代码不变。</p>
<figure><img src="https://www.javayong.cn/pics/temp//6IEuaPkZ4h.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>执行下getUserById方法，查询用户编号为1的用户信息。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二次执行相同的动作，从日志可用看到从优先会从本地内存中查询出结果。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>等待30s ， 再执行一次，因为本地缓存会失效，所以执行的时候会查询二级缓存</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简易的二级缓存就组装完了。</p>
<h2> 5 什么场景选择Spring Cache</h2>
<p>在做技术选型的时候，需要针对场景选择不同的技术。</p>
<p>笔者认为Spring Cache的功能很强大，设计也非常优雅。特别适合缓存控制没有那么细致的场景。比如门户首页，偏静态展示页面，榜单等等。这些场景的特点是对数据实时性没有那么严格的要求，只需要将数据源缓存下来，过期之后自动刷新即可。 这些场景下，Spring Cache就是神器，能大幅度提升研发效率。</p>
<p>但在高并发大数据量的场景下，精细的缓存颗粒度的控制上，还是需要做功能扩展。</p>
<ol>
<li>多级缓存；</li>
<li>列表缓存；</li>
<li>缓存变更监听器；</li>
</ol>
<p>笔者也在思考这几点的过程，研读了 j2cache , jetcache相关源码，受益匪浅。后续的文章会重点分享下笔者的心得。</p>
<hr>
<p>如果我的文章对你有所帮助，还请帮忙<strong>点赞、在看、转发</strong>一下，你的支持会激励我输出更高质量的文章，非常感谢！</p>
<figure><img src="https://www.javayong.cn/pics/temp//vBrZNjbMur.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
]]></content>
    <category term="cache"/>
    <published>2023-11-16T08:17:07.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 整体架构</title>
    <id>https://javayong.cn/mq/rocketmq4/01RocketMQ4_artch.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/01RocketMQ4_artch.html"/>
    <updated>2023-11-17T07:53:52.000Z</updated>
    <summary type="html"><![CDATA[<h2> 1 专业术语</h2>
<ul>
<li>
<p>Producer 消息生产者，负责产生消息，一般由业务系统负责产生消息。</p>
</li>
<li>
<p>Consumer 消息消费者，负责消费消息，一般是后台系统负责异步消费。</p>
</li>
<li>
<p>PushConsumer
Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。</p>
</li>
<li>
<p>PullConsumer</p>
<p>Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</p>
</li>
<li>
<p>ProducerGroup</p>
<p>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p>
</li>
<li>
<p>ConsumerGroup</p>
<p>一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p>
</li>
<li>
<p>Broker</p>
<p>消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。</p>
</li>
<li>
<p>广播消费</p>
<p>一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以认为在消息划分方面无意义。</p>
</li>
<li>
<p>集群消费</p>
<p>一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个 Consumer Group 有 3 个实例(可能是 3 个进程，或者 3 台机器)，那举每个实例只消费其中的 3 条消息。</p>
</li>
<li>
<p>顺序消息
消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要是指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。</p>
</li>
<li>
<p>Message Queue
在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，理论上在 100 年内不会溢出，另外队列中只保存最近几天的数据，之前的数据会按照过期时间来删除。也可以认为 Message Queue 是一个长度无限的数组，offset 就是下标。</p>
</li>
</ul>]]></summary>
    <content type="html"><![CDATA[<h2> 1 专业术语</h2>
<ul>
<li>
<p>Producer 消息生产者，负责产生消息，一般由业务系统负责产生消息。</p>
</li>
<li>
<p>Consumer 消息消费者，负责消费消息，一般是后台系统负责异步消费。</p>
</li>
<li>
<p>PushConsumer
Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。</p>
</li>
<li>
<p>PullConsumer</p>
<p>Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</p>
</li>
<li>
<p>ProducerGroup</p>
<p>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p>
</li>
<li>
<p>ConsumerGroup</p>
<p>一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p>
</li>
<li>
<p>Broker</p>
<p>消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。</p>
</li>
<li>
<p>广播消费</p>
<p>一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以认为在消息划分方面无意义。</p>
</li>
<li>
<p>集群消费</p>
<p>一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个 Consumer Group 有 3 个实例(可能是 3 个进程，或者 3 台机器)，那举每个实例只消费其中的 3 条消息。</p>
</li>
<li>
<p>顺序消息
消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要是指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。</p>
</li>
<li>
<p>Message Queue
在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，理论上在 100 年内不会溢出，另外队列中只保存最近几天的数据，之前的数据会按照过期时间来删除。也可以认为 Message Queue 是一个长度无限的数组，offset 就是下标。</p>
</li>
</ul>
<h2> 2 核心功能</h2>
<p>本节阐述消息中间件通常需要解决哪些问题，在解决这些问题当中会遇到什么困难，RocketMQ 是否可以解决，规范中如何定义这些问题。</p>
<h3> 2.1 发布订阅</h3>
<p>点对点（P2P）和发布订阅（Pub/Sub）是两种常见的消息队列模式，它们用于满足不同通信需求。</p>
<ol>
<li>点对点（P2P）模式：
<ul>
<li>在点对点模式中，消息发送者（生产者）将消息发送到一个特定的队列，而消息接收者（消费者）从该队列中接收消息。</li>
<li>消息在队列中存储，一旦一个消息被消费者接收，它就从队列中移除，这确保了每个消息只被一个消费者处理。</li>
<li>这种模式适用于一对一的通信，其中一个生产者向一个特定的消费者发送消息，确保消息的可靠传递和处理。</li>
</ul>
</li>
<li>发布订阅（Pub/Sub）模式：
<ul>
<li>在发布订阅模式中，消息发送者将消息发布到一个主题（topic），而消息订阅者则订阅感兴趣的主题。</li>
<li>每个主题可以有多个订阅者，因此消息会被广播到所有订阅了相同主题的消费者。</li>
<li>这种模式适用于一对多或多对多的通信，允许多个消费者同时接收和处理相同主题的消息。</li>
<li>发布订阅模式通常用于构建实时事件处理系统、日志处理、通知系统等，其中多个消费者需要订阅相同类型的消息并进行处理。</li>
</ul>
</li>
</ol>
<p>点对点模式适用于一对一的通信，确保消息的可靠传递给一个特定的消费者，而发布订阅模式适用于一对多或多对多的通信，允许多个消费者同时接收相同主题的消息，用于构建实时事件系统和广播通信。</p>
<h3> 2.2 消息优先级</h3>
<p>规范中描述的优先级是指在一个消息队列中，每条消息都有不同的优先级，一般用整数来描述，优先级高的消 息先投递，如果消息完全在一个内存队列中，那么在投递前可以按照优先级排序，令优先级高的先投递。</p>
<p>由于 RocketMQ 所有消息都是持久化的，所以如果按照优先级来排序，开销会非常大，因此 RocketMQ 没有特意支持消息优先级，但是可以通过变通的方式实现类似功能，即单独配置一个优先级高的队列，和一个普通优先级 的队列， 将不同优先级发送到不同队列即可。</p>
<p>对于优先级问题，可以归纳为 2 类：</p>
<ol>
<li>只要达到优先级目的即可，不是严格意义上的优先级，通常将优先级划分为高、中、低，或者再多几个级别。每个优先级可以用不同的 topic 表示，发消息时，指定不同的 Topic 来表示优先级，这种方式可以解决绝大部分的优先级问题，但是对业务的优先级精确性做了妥协。</li>
<li>严格的优先级，优先级用整数表示，例如 0 ~ 65535，这种优先级问题一般使用不同 topic 解决就非常不合适。如果要让 MQ 解决此问题，会对 MQ 的性能造成非常大的影响。这里要确保一点，业务上是否确实需</li>
</ol>
<p>要这种严格的优先级，如果将优先级压缩成几个，对业务的影响有多大 ?</p>
<h3> 2.3 消息有序</h3>
<p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如:一个订单产生了 3 条消息，分别是订单创 建，订单付款，订单完成。消费时，要按照这个顺序消费才能有意义。但是同时订单之间是可以并行消费的。RocketMQ 可以严格的保证消息有序。</p>
<h3> 2.4 消息过滤</h3>
<ul>
<li>
<p>Broker 端消息过滤
在 Broker 中，按照 Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。 缺点是增加了 Broker 的负担，实现相对复杂。</p>
</li>
<li>
<p>Consumer 端消息过滤</p>
<p>这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到 Consumer 端。</p>
</li>
</ul>
<h3> 2.5 消息持久化</h3>
<p>消息中间件通常采用的几种持久化方式:</p>
<ol>
<li>持久化到数据库，例如 Mysql 。</li>
<li>持久化到 KV 存储，例如 levelDB、伯克利 DB 等 KV 存储系统。</li>
<li>文件记录形式持久化，例如 Kafka，RocketMQ 。</li>
<li>对内存数据做一个持久化镜像，例如 beanstalkd，VisiNotify 。</li>
</ol>
<p>1，2,  3 三种持久化方式都具有将内存队列 Buffer 进行扩展的能力，4 只是一个内存的镜像，作用是当 Broker 挂掉重启后仍然能将之前内存的数据恢复出来。</p>
<p>JMS 与 CORBA Notification 规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个消息中间件 的性能。</p>
<p>RocketMQ 参考了 Kafka 的持久化方式，充分利用 Linux 文件系统内存 cache 来提高性能。</p>
<h3> 2.6 消息可靠性</h3>
<p>影响消息可靠性的几种情况:</p>
<ol>
<li>
<p>Broker 正常关闭</p>
</li>
<li>
<p>Broker 异常 Crash</p>
</li>
<li>
<p>OS Crash</p>
</li>
<li>
<p>机器掉电，但是能立即恢复供电情况。</p>
</li>
</ol>
<ol start="5">
<li>机器无法开机(可能是cpu、主板、内存等关键设备损坏)</li>
<li>磁盘设备损坏。</li>
</ol>
<p>1、2、3、4  四种情况都属于硬件资源可立即恢复情况，RocketMQ 在这四种情况下能保证消息不丢，或者丢失少量数据(依赖刷盘方式是同步还是异步)。</p>
<p>5、6 属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。</p>
<p>RocketMQ 在这两种情况下，通过异步复制，可保证 99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点， 同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与金额相关的应用。</p>
<h3> 2.7 低延迟消费</h3>
<p>在消息不堆积情况下，消息到达 Broker 后，能立刻到达 Consumer。 RocketMQ 使用长轮询 Pull 方式，可保证消息非常实时，消息实时性不低于 Push。</p>
<h3> 2.8 At least Once</h3>
<p>是指每个消息必须投递一次。RocketMQ Consumer 先 pull 消息到本地，消费完成后，才向服务器返回 ack，如果没有消费一定不会 ack 消息， 所以 RocketMQ 可以很好的支持此特性。</p>
<h3> 2.9 Exactly Only Once</h3>
<p>1、发送消息阶段，不允许发送重复的消息。
2、消费消息阶段，不允许消费重复的消息。
只有以上两个条件都满足情况下，才能认为消息是“Exactly Only Once”，而要实现以上两点，在分布式系统环境下，不可避免要产生巨大的开销。所以 RocketMQ 为了追求高性能，并不保证此特性，<strong>要求在业务上进行去重， 也就是说消费消息要做到幂等性</strong>。RocketMQ 虽然不能严格保证不重复，但是正常情况下很少会出现重复发送、消 费情况，只有网络异常，Consumer 启停等异常情况下会出现消息重复。</p>
<p><strong>此问题的本质原因是网络调用存在不确定性，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题。</strong></p>
<h3> 2.10 Broker <strong>的</strong> <strong>Buffer</strong> 满了怎么办?</h3>
<p>Broker 的 Buffer 通常指的是 Broker 中一个队列的内存 Buffer 大小，这类 Buffer 通常大小有限，如果 Buffer 满 了以后怎么办?</p>
<p>下面是 CORBA Notification 规范中处理方式:</p>
<p>(1). RejectNewEvents 拒绝新来的消息，向 Producer 返回 RejectNewEvents 错误码。</p>
<p>(2). 按照特定策略丢弃已有消息</p>
<ol>
<li>
<p><strong>AnyOrder</strong> - Any event may be discarded on overflow. This is the default setting for this property.</p>
</li>
<li>
<p><strong>FifoOrder</strong> - The first event received will be the first discarded.</p>
</li>
<li>
<p><strong>LifoOrder</strong> - The last event received will be the first discarded.</p>
</li>
<li>
<p><strong>PriorityOrder</strong> - Events should be discarded in priority order, such that lower priority events will be discarded before higher priority events.</p>
</li>
<li>
<p><strong>DeadlineOrder</strong> - Events should be discarded in the order of shortest expiry deadline first. RocketMQ 没有内存 Buffer 概念，RocketMQ 的队列都是持久化磁盘，数据定期清除。</p>
</li>
</ol>
<p>对于此问题的解决思路，RocketMQ 同其他 MQ 有非常显著的区别，RocketMQ 的内存 Buffer 抽象成一个无限长度的队列，不管有多少数据进来都能装得下，这个无限是有前提的，Broker 会定期删除过期的数据，例如 Broker 只保存 3 天的消息，那么这个 Buffer 虽然长度无限，但是 3 天前的数据会被从队尾删除。</p>
<h3> 2.11 <strong>回溯消费</strong></h3>
<p>回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于 Consumer 系统故障， 恢复后需要重新消费 1 小时前的数据，那么 Broker 要提供一种机制，可以按照时间维度来回退消费进度。</p>
<p>RocketMQ 支持按照时间回溯消费，时间维度精确到毫秒，可以向前回溯，也可以向后回溯。</p>
<h3> 2.12 消息堆积</h3>
<p>消息中间件的主要功能是异步解耦，还有个重要功能是挡住前端的数据洪峰，保证后端系统的稳定性，这就要 求消息中间件具有一定的消息堆积能力，消息堆积分以下两种情况:</p>
<ol>
<li>消息堆积在内存 Buffer，一旦超过内存 Buffer，可以根据一定的丢弃策略来丢弃消息，如 CORBA Notification 规范中描述。适合能容忍丢弃消息的业务，这种情况消息的堆积能力主要在于内存 Buffer 大小，而且消息堆积后，性能下降不会太大，因为内存中数据多少对于对外提供的访问能力影响有限。</li>
<li>消息堆积到持久化存储系统中，例如 DB ，KV 存储，文件记录形式。
当消息不能在内存 Cache 命中时，要不可避免的访问磁盘，会产生大量读  IO，读 IO 的吞吐量直接决定了 消息堆积后的访问能力。</li>
</ol>
<p>评估消息堆积能力主要有以下四点:</p>
<ol>
<li>
<p>消息能堆积多少条，多少字节 ? 即消息的堆积容量。</p>
</li>
<li>
<p>消息堆积后，发消息的吞吐量大小，是否会受堆积影响 ?</p>
</li>
<li>
<p>消息堆积后，正常消费的 Consumer 是否会受影响 ?</p>
</li>
<li>
<p>消息堆积后，访问堆积在磁盘的消息时，吞吐量有多大 ?</p>
</li>
</ol>
<h3> 2.13 分布式事务</h3>
<p>已知的几个分布式事务规范，如 XA，JTA 等。其中 XA 规范被各大数据库厂商广泛支持，如 Oracle，Mysql 等。 其中 XA 的 TM 实现佼佼者如 Oracle Tuxedo，在金融、电信等领域被广泛应用。</p>
<p>分布式事务涉及到两阶段提交问题，在数据存储方面的方面必然需要 KV 存储的支持，因为第二阶段的提交回滚需要修改消息状态，一定涉及到根据 Key 去查找 Message 的动作。RocketMQ 在第二阶段绕过了根据 Key 去查找 Message 的问题，采用第一阶段发送 Prepared 消息时，拿到了消息的 Offset，第二阶段通过 Offset 去访问消息， 并修改状态，Offset 就是数据的地址。</p>
<p>RocketMQ 这种实现事务方式，没有通过 KV 存储做，而是通过 Offset 方式，存在一个显著缺陷，即通过 Offset 更改数据，会令系统的脏页过多，需要特别关注。</p>
<h3> 2.14 定时消息</h3>
<p>定时消息是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能 被消费。</p>
<p>如果要支持任意的时间精度，在 Broker 层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不 可避免的产生巨大性能开销。</p>
<p>RocketMQ 支持定时消息，但是不支持任意时间精度，支持特定的 level，例如定时 5s，10s，1m 等。</p>
<h3> 2.15 消息重试</h3>
<p>Consumer 消费消息失败后，要提供一种重试机制，令消息再消费一次。</p>
<p>消费失败通常可以认为有以下几种情况</p>
<ol>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理(例如话费充值，当前消息的手机号被注销，无法充值)等。</li>
</ol>
<p>这种错误通常需要跳过这条消息，再消费其他消息，而这条失败的消息即使立刻重试消费，99%也不成功，</p>
<p>所以最好提供一种定时重试机制，即过 10s 秒后再重试。</p>
<ol start="2">
<li>由于依赖的下游应用服务不可用，例如 db 连接不可用，外系统网络不可达等。</li>
</ol>
<p>遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用 sleep 30s ，再消费下一条消息，这样可以减轻 Broker 重试消息的压力。</p>
<h2> 3 架构概览</h2>
<p>我们先对 RocketMQ 4.9.X 架构做一个概览。</p>
<figure><img src="https://www.javayong.cn/pics/temp//WmCfyfFaPD.webp!large.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>整体架构中包含<strong>四种角色</strong> :</p>
<p><strong>1、NameServer</strong></p>
<p>名字服务是是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。它是一个非常简单的 Topic 路由注册中心，其角色类似 Dubbo 中的 zookeeper ，支持 Broker 的动态注册与发现。</p>
<p><strong>2、BrokerServer</strong></p>
<p>Broker 主要负责消息的存储、投递和查询以及服务高可用保证 。</p>
<p><strong>3、Producer</strong></p>
<p>消息发布的角色，Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<p><strong>4、Consumer</strong></p>
<p>消息消费的角色，支持以 push 推，pull 拉两种模式对消息进行消费。</p>
<p>RocketMQ 集群工作流程：</p>
<p>1、<strong>启动 NameServer</strong>，NameServer 起来后监听端口，等待 Broker、Producer 、Consumer 连上来，相当于一个路由控制中心。</p>
<p>2、<strong>Broker 启动</strong>，跟所有的 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker信息( IP+端口等 )以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</p>
<p>3、收发消息前，先<strong>创建 Topic</strong>，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。</p>
<p>4、<strong>Producer 发送消息</strong>，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker 发消息。</p>
<p>5、Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始<strong>消费消息</strong>。</p>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T04:40:45.000Z</published>
  </entry>
  <entry>
    <title type="text">序言</title>
    <id>https://javayong.cn/mq/rocketmq4/00RocketMQ4_introduce.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/00RocketMQ4_introduce.html"/>
    <updated>2023-11-16T13:16:12.000Z</updated>
    <summary type="html"><![CDATA[<p>大家好，我是勇哥 。</p>
<p>20231024 , 程序员节，圆了我一个小小的梦。</p>
<p>花了半年时间，我写了一本电子书 ，书名是：《<strong>RocketMQ4.X设计精要</strong>》，我想在今天分享给各位。</p>
<p>这本书一共包含十五章，接近 10 万字，180 张图，按照 RocketMQ 的知识体系一章一章展开。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/mybook.png?a=23" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>大家好，我是勇哥 。</p>
<p>20231024 , 程序员节，圆了我一个小小的梦。</p>
<p>花了半年时间，我写了一本电子书 ，书名是：《<strong>RocketMQ4.X设计精要</strong>》，我想在今天分享给各位。</p>
<p>这本书一共包含十五章，接近 10 万字，180 张图，按照 RocketMQ 的知识体系一章一章展开。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/mybook.png?a=23" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>很多年前，一位七牛的资深架构师曾经说过这样一句话：</p>
<blockquote>
<p>Nginx+ 业务逻辑层 + 数据库 + 缓存层 + 消息队列 ，这种模型几乎能适配绝大部分的业务场景 。</p>
</blockquote>
<p>这么多年过去了，这句话或深或浅地影响了我的技术选择，以至于后来我花了很多时间去重点学习缓存、消息队列相关的技术。</p>
<p>2014年，是我和 RocketMQ 结缘的一年。</p>
<p>我那时服务于艺龙旅行网，深感自己能力的欠缺，我非常想学习消息队列的知识，但当时互联网上开源的消息队列并不能让我满意。</p>
<p>读了子柳老师的《淘宝技术这十年》后，我搜罗了很多淘宝消息队列的资料，我知道MetaQ 的版本已经升级 MetaQ 3.0，只是开源版本还没有放出来。</p>
<p>2014 年秋 ，当 RocketMQ 开源出来之后 ，我兴奋异常，迫不及待的一睹其风采，至今我都能记得当时内心的雀跃。</p>
<p>我想学网络编程，RocketMQ 的通讯模块 remoting 底层也是 Netty 写的。我学习切入点是 RocketMQ 的通讯模块。</p>
<p>首先我模仿 RocketMQ 的通讯模块写了一个玩具的<code>rpc</code>，在 IDEA 中丝滑打印生产者/消费者的日志，感觉自己充满了能量。</p>
<p>不久之后，艺龙举办技术创新活动，我想想，要不尝试一下用 Netty 改写下 <code>Cobar</code> 的通讯模块。</p>
<p>于是参考 <code>Cobar</code> 的源码花了两周写了个 netty 版的 <code>proxy</code>，其实非常粗糙，很多功能不完善。只是没有想到，活动颁给我一个<strong>鼓励奖</strong>，现在想想既有趣又有点激励。</p>
<p>这就是我学习 RocketMQ 的起点，一个非常美好的起点。</p>
<p>在接下来的职业生涯中 ，我不断在业务中使用 RocketMQ ：</p>
<ol>
<li>直播答题：RocketMQ 广播模式推送题目 ；</li>
<li>参考阿里云 ONS 封装 RocketMQ 框架 ；</li>
<li>使用 RocketMQ 通讯框架实现任务调度系统 ；</li>
<li>使用 RocketMQ 作为短信平台的基座 ;</li>
<li>重构 RocketMQ 控制台支持多集群 。</li>
</ol>
<p>通过 RocketMQ  ，我学习到了很多的编程知识，比如多线程技巧、网络编程 、文件存储，同时面对各种技术问题处理起来也更加从容和自信。</p>
<p>缓存、分库分表、消息队列是高并发解决方案三剑客，是架构师必须掌握的知识点。</p>
<p>我写这本电子书，是想帮助后端工程师快速掌握 RocketMQ 的相关知识点，提升他们的技术认知。</p>
<p><strong>假如朋友们能通过这本电子书，快速成长，那将是一件令我非常快乐的事情。</strong></p>
<p>因为我自己的能力有限，书中肯定存在纰漏和错误之处，欢迎沟通指正，非常感谢 ：）</p>
<figure><img src="https://javayong.cn/pics/shipinhao/gongzhonghaonew.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>微信搜索「勇哥java实战分享」关注后，在后台回复「mq」即可获取《RocketMQ 4.X 设计精要》pdf 。</p>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 网络通讯</title>
    <id>https://javayong.cn/mq/rocketmq4/01RocketMQ4_network.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/01RocketMQ4_network.html"/>
    <updated>2023-11-16T07:55:06.000Z</updated>
    <summary type="html"><![CDATA[<p>RocketMQ 的网络通讯模块负责生产者、消费者与 Broker 之间的网络通信。</p>
<p>笔者学习 RocketMQ 也是从通讯模块源码开始的，并且从源码里汲取了很多营养。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/remotingcode.png?a=2" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 网络协议</h2>
<p>客户端和服务端之间完成数据交互，需要约定数据协议。数据协议如下图：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/remotingprotocol.png" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>RocketMQ 的网络通讯模块负责生产者、消费者与 Broker 之间的网络通信。</p>
<p>笔者学习 RocketMQ 也是从通讯模块源码开始的，并且从源码里汲取了很多营养。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/remotingcode.png?a=2" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 网络协议</h2>
<p>客户端和服务端之间完成数据交互，需要约定数据协议。数据协议如下图：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/remotingprotocol.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>传输内容分为以下四个部分：</p>
<p><strong>1、消息长度：</strong></p>
<p>​	  总长度，四个字节存储，占用一个 int 类型；</p>
<p><strong>2、序列化类型 &amp; 消息头长度：</strong></p>
<p>​	  占用一个 int 类型，第一个字节表示序列化类型，后面三个字节表示消息头长度；</p>
<p><strong>3、消息头数据</strong>：</p>
<p>​	  经过序列化后的消息头数据；</p>
<p><strong>4、消息主体数据：</strong></p>
<p>​	  消息主体的二进制字节数据内容。</p>
<p>消息头数据序列化默认是 <strong>JSON 格式</strong> ，示例如下：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/remotingheaderdemo.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://javayong.cn/pics/rocketmq/remotingheaderprotocol.png" alt="header格式说明" tabindex="0"><figcaption>header格式说明</figcaption></figure>
<p>网络协议设计的原则是<strong>便于编解码</strong>，这里我们温习下 TCP <strong>粘包</strong>和<strong>拆包</strong>的知识点。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/tcp.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>TCP 是面向字节流的协议，它会将应用层发送的数据拆分成 TCP 报文段进行传输，发送端和接收端都会维护一个 buffer ，发送的数据首先会存至缓冲区  buffer ，然后通过网络发送给接收端的 buffer 中。</p>
<ul>
<li><strong>粘包</strong></li>
</ul>
<p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送 。</p>
<ul>
<li><strong>拆包</strong></li>
</ul>
<p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送。</p>
<p>Netty 通过以下几种方式来解决粘包问题：</p>
<p><strong>1、消息定长：FixedLengthFrameDecoder</strong></p>
<p>发送的消息都是固定长度的，接收方根据固定长度来解析消息，这样可以有效避免粘包和拆包问题。</p>
<p><strong>2、特定分隔符：DelimiterBasedFrameDecoder</strong></p>
<p>在消息的末尾添加特定的分隔符，接收方根据分隔符来切分消息。</p>
<p><strong>3、消息头长度：LenghtFieldBasedFrameDecode</strong></p>
<p>在消息的头部添加表示消息长度的字段，接收方先读取消息头部的长度字段，然后根据长度字段的值来读取消息内容，从而正确地解析出完整的消息。</p>
<p>RocketMQ 的解码器就是使用了 <strong>LenghtFieldBasedFrameDecode</strong> 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/nettydecoder.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 2 通讯方式</h2>
<p>客户端通信方式支持<strong>同步 sync</strong> 、<strong>异步 async</strong> 、<strong>单向 oneway</strong> 三种方式 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/clientcode.png?a=12" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3> 2.1 同步 sync</h3>
<p>在同步通信中，客户端发送请求后会一直等待服务器响应，直到接收到响应或者超时。</p>
<p>这意味着：客户端发送线程在发送请求后会被阻塞，直到收到服务器的响应，然后继续执行发送下一个请求。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/sync.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>同步请求的流程：</p>
<p>1、客户端连接服务端，创建 channel ；</p>
<p>2、客户端创建 responseFutrue 对象 ，主要由四个部分组成：<strong>响应结果、请求编号、回调函数、CountDownLatch</strong>。然后将  responseFutrue 对象加入到本地缓存 响应表 reponseTable 里 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/responseFuture.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>3、客户端将请求发送到服务端；</p>
<p>4、服务端解析出请求命令 ；</p>
<ol>
<li>请求命令中包含命令类型、请求编号，服务端根据命令类型选择处理器 ，执行请求命令；</li>
<li>服务端将响应数据返回给客户端；</li>
<li>客户端将响应结果填充到响应表 reponseTable 里，同时因为是同步命令，并调用 countDownLatch 的 countDown 方法 , 这样发送消息线程就不再阻塞（<strong>实现同步请求的精髓</strong>）。</li>
</ol>
<h3> 2.2 异步 async</h3>
<p>异步通信中，客户端发送请求后不会等待服务器的响应，而是继续执行后续代码。客户端会注册一个回调函数或者监听器，用于处理服务器响应。当服务器响应返回时，会触发回调函数的执行。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/asyn.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>异步请求的流程 ：</p>
<p>1、客户端连接服务端，创建 channel ；</p>
<p>2、通过信号量 <code>semaphoreAsync</code> 限制正在进行的异步请求的最大数量 ;</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3、客户端创建 responseFutrue 对象 ，主要由四个部分组成：<strong>响应结果、请求编号、回调函数、CountDownLatch</strong>。然后将  responseFutrue 对象加入到本地缓存 响应表 reponseTable 里 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/responseFuture.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>4、客户端将请求发送到服务端，客户端异步方法结束 。</p>
<p>5、服务端解析出请求命令 ；</p>
<ol>
<li>请求命令中包含命令类型、请求编号，服务端根据命令类型选择处理器 ，执行请求命令；</li>
<li>服务端将响应数据返回给客户端；</li>
</ol>
<p>6、通讯框架收到服务端的响应数据后，通过回调线程执行回调函数。</p>
<h3> 2.3 单向 oneway</h3>
<p>单向通信发起调用后，不关心调用结果，不做超时控制，只要请求已经发出，就完成本次调用。</p>
<p>通常用于可以重试，或者定时通知类的场景，调用过程是有可能因为网络问题，机器故障等原因，导致请求失败。业务场景需要能接受这样的异常场景，才可以使用。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/oneway.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<blockquote>
<p>需要注意的是，单向通信不能保证请求一定能够成功发送到服务器，也无法保证服务器是否正确地接收到了请求。</p>
</blockquote>
<p>oneway 请求的流程 :</p>
<p>1、客户端连接服务端，创建 channel ；</p>
<p>2、通过信号量 <code>semaphoreOneway</code> 限制正在进行的 oneway 请求的最大数量 ;</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3、客户端将请求发送到服务端，客户端 oneway 请求方法结束 。</p>
<p>4、服务端解析出请求命令 , 请求命令中包含命令类型、请求编号，服务端根据命令类型选择处理器 ，执行请求命令 , 并不会将响应数据返回给客户端 ；</p>
<p>下表展示了<strong>同步</strong>、<strong>异步</strong>、<strong>单向</strong>这三种通讯方式的优劣点：</p>
<table>
<thead>
<tr>
<th><strong>方式</strong></th>
<th><strong>发送TPS</strong></th>
<th><strong>发送结果反馈</strong></th>
<th><strong>可靠性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>同步</td>
<td>快</td>
<td>有</td>
<td>不丢失</td>
</tr>
<tr>
<td>异步</td>
<td>快</td>
<td>有</td>
<td>不丢失</td>
</tr>
<tr>
<td>单向</td>
<td>最快</td>
<td>无</td>
<td>可能丢失</td>
</tr>
</tbody>
</table>
<h2> 3 Reactor多线程设计</h2>
<p>RocketMQ 的通信模块采用 Netty 组件作为底层通信库，同样也遵循了 Reactor 多线程模型，同时又在这之上做了一些扩展和优化。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/reactor.png?a=12" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>一个 Reactor 主线程 （ <code>eventLoopGroupBoss</code> ）责监听 TCP网络连接请求，建立好连接，创建 SocketChannel , 并注册到 selector 上。</p>
<p>RocketMQ 源码会自动根据  OS 的类型选择 NIO 和 Epoll ，也可以通过参数配置 ）， 然后监听真正的网络数据。</p>
<p>拿到网络数据后，再丢给 Worker 线程池（eventLoopGroupSelector ），再真正执行业务逻辑之前需要进行 SSL 验证、编解码、空闲检查、网络连接管理，这些工作都交给 defaultEventExecutorGroup 去做。</p>
<p>而业务操作由业务线程池中处理，根据 RemotingCommand 的业务请求编号 requestCode ,  从处理器表 processorTable 这个本地缓存中找到对应的处理器 ， 然后封装成 task 任务后，提交到对应的业务处理器的线程池执行。</p>
<p>从入口到业务逻辑的几个步骤里，线程池一直在增加，这跟每一步步骤逻辑复杂性相关 ，越复杂，需要的并发通道越宽。</p>
<p>RocketMQ 的线程模型如下所示 ：</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程名</th>
<th>线程具体说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>NettyBoss_%d</td>
<td>Reactor 主线程</td>
</tr>
<tr>
<td>N</td>
<td>NettyServerEPOLLSelector_%d_%d</td>
<td>Reactor 线程池</td>
</tr>
<tr>
<td>M1</td>
<td>NettyServerCodecThread_%d</td>
<td>Worker线程池</td>
</tr>
<tr>
<td>M2</td>
<td>RemotingExecutorThread_%d</td>
<td>业务 processor 处理线程池</td>
</tr>
</tbody>
</table>
<h2> 4 写到最后</h2>
<p>通讯模块核心知识点 ：</p>
<p>1、网络协议设计原则便于编解码，Netty 的 LenghtFieldBasedFrameDecode 解码器非常容易得解决 TCP 粘包和拆包的问题；</p>
<p>2、网络通讯框架支持<strong>同步</strong>、<strong>异步</strong>、<strong>单向</strong>这三种通讯方式 ；</p>
<p>3、理解 Reactor 线程模型很关键 。</p>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 名字服务</title>
    <id>https://javayong.cn/mq/rocketmq4/02RocketMQ4_nameserver.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/02RocketMQ4_nameserver.html"/>
    <updated>2023-11-16T07:55:06.000Z</updated>
    <summary type="html"><![CDATA[<p>NameServer 是专为 RocketMQ 设计的<strong>轻量级名字服务</strong>，它的源码非常精简，八个类 ，少于1000行代码。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/nameserver.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>这篇文章， 笔者会从<strong>基础概念</strong>、<strong>Broker发送心跳包</strong>、<strong>NameServer 维护路由</strong>、<strong>Zookeeper vs NameServer</strong> 四个模块揭秘名字服务的设计精髓。</p>]]></summary>
    <content type="html"><![CDATA[<p>NameServer 是专为 RocketMQ 设计的<strong>轻量级名字服务</strong>，它的源码非常精简，八个类 ，少于1000行代码。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/nameserver.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>这篇文章， 笔者会从<strong>基础概念</strong>、<strong>Broker发送心跳包</strong>、<strong>NameServer 维护路由</strong>、<strong>Zookeeper vs NameServer</strong> 四个模块揭秘名字服务的设计精髓。</p>
<h1> 1基础概念</h1>
<figure><img src="https://javayong.cn/pics/rocketmq/rocketmqjiagou.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>NameServer 是一个非常简单的 Topic 路由<strong>注册中心</strong>，其角色类似 Dubbo 中的 zookeeper ，支持 Broker 的动态注册与发现。</p>
<p>RocketMQ 集群工作流程：</p>
<p>1、NameServer 启动服务，监听 TCP 端口 ， 集群多节点之间无任何信息交互，然后等待 Broker、Producer 、Consumer 连上来；</p>
<p>2、Broker 启动后，每隔 30 秒向所有的 NameServer 发送心跳命令 ；</p>
<p>3、NameServer 接收到请求之后，保存路由信息在本地内存里 ，将响应结果返给 Broker 服务；</p>
<p>4、Producer 启动之后，会随机的选择一个 NameServer ，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker 发消息；</p>
<p>5、Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始消费消息。</p>
<h1> 2 Broker发送心跳包</h1>
<p>我们贴一段 Broker 发送心跳命令的源码 ，代码地址位于：<code>org.apache.rocketmq.broker.out.BrokerOuterAPI#registerBrokerAll</code>。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/brokerregister.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>1、Broker 会每隔 30 秒向所有的 NameServer 发送心跳命令 ；</strong></p>
<blockquote>
<p>使用 CountDownLatch 实现多线程同步，可以获取发往所有的 NameServer 的心跳命令的响应结果</p>
</blockquote>
<p><strong>2、心跳命令包含两个部分：请求头和请求体</strong></p>
<figure><img src="https://javayong.cn/pics/rocketmq/brokerheartbeat.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h1> 3 NameServer 维护路由</h1>
<p>NameServer 在接收到 Broker 发送的心跳请求之后，通过默认的处理器来处理请求，保存路由信息成功后，注册成功状态返回给 Broker 服务。</p>
<p>源码中，我们可以看到路由信息保存在 <strong>HashMap</strong> 中 。</p>
<figure><img src="https://javayong.cn/pics/cache/rocketmqhash.webp?" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>1、<strong>topicQueueTable</strong>：Topic 消息队列路由信息，包括 topic 所在的 broker 名称，读队列数量，写队列数量，同步标记等信息，rocketmq 根据 topicQueueTable 的信息进行负载均衡消息发送。</p>
<p>2、<strong>brokerAddrTable</strong>：Broker 节点信息，包括 brokername，所在集群名称，还有主备节点信息。</p>
<p>3、<strong>clusterAddrTable</strong>：Broker 集群信息，存储了集群中所有的 Brokername。</p>
<p>4、<strong>brokerLiveTable</strong>：Broker 状态信息，NameServer 每次收到 Broker 的心跳包就会更新该信息。</p>
<p>当 Broker 向 NameServer 发送心跳包（路由信息），NameServer 需要对 HashMap 进行数据更新，但我们都知道 HashMap 并不是线程安全的，高并发场景下，容易出现 CPU 100% 问题，所以更新 HashMap 时需要加锁，RocketMQ 使用了 JDK 的读写锁 ReentrantReadWriteLock 。</p>
<p>下面我们看下路由信息如何更新和读取：</p>
<p><strong>1、写操作：更新路由信息，操作写锁</strong></p>
<figure><img src="https://javayong.cn/pics/rocketmq/registerbroker.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>2、读操作：查询主题信息，操作读锁</strong></p>
<figure><img src="https://javayong.cn/pics/rocketmq/getalltopiclist.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<hr>
<p>我们可以将 NameServer 实现注册中心的方式总结为： <strong>RPC 服务 + HashMap 存储容器 + 读写锁 + 定时任务</strong> 。</p>
<p>1、NameServer 监听固定的端口，提供 RPC 服务</p>
<p>2、HashMap 作为存储容器</p>
<p>3、读写锁控制锁的颗粒度</p>
<p>4、定时任务</p>
<ul>
<li>每个 Broker 每隔 30 秒注册<strong>主题的路由信息</strong>到所有 NameServer</li>
<li>NameServer 定时任务每隔10 秒清除已宕机的 Broker , 判断宕机的标准是：当前时间减去 Broker 最后一次心跳时间大于2分钟</li>
</ul>
<h1> 4 NameServer vs Zookeeper</h1>
<p>那为什么 RocketMQ 不用 Zookeeper 做为注册中心呢 ？</p>
<p>我们先温习下 CAP 理论。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/cap.png?c=1" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>CAP 理论是分布式架构中重要理论。</p>
<p>1、<strong>一致性( Consistency )</strong> ：所有节点在同一时间具有相同的数据 ;</p>
<p>2、<strong>可用性( Availability )</strong> ：保证每个请求不管成功或者失败都有响应  (某个系统的某个节点挂了，但是并不影响系统的接受或者发出请求) ;</p>
<p>3、<strong>分隔容忍( Partition tolerance )</strong> ：系统中任意信息的丢失或失败不会影响系统的继续运作。  (在整个系统中某个部分，挂掉了，或者宕机了，并不影响整个系统的运作或者说使用) 。</p>
<p>Zookeeper 是一个典型的 CP 注册中心 ，通过使 ZAB 协议来保证节点之间数据的强一致性。</p>
<p>笔者曾经遇到过一起神州专车服务宕机事故，<strong>zookeeper 集群不堪重负，一直在选主</strong> 。 架构负责人修改了 zookeeper 的 jvm 参数，重启集群后 , 才临时解决了问题。</p>
<p>因为 MetaQ 集群和服务治理共用一组 zookeeper 集群 。</p>
<ul>
<li>MetaQ 消费者负载均衡时，会频繁的争抢锁 ，同时也会频繁的提交 offset  ；</li>
<li>专车的注册服务也越来越多，注册信息通过Hession 序列化存储在 zookeeper 的节点。</li>
</ul>
<p>为了减少 zookeeper 集群的性能压力，架构团队将 MetaQ 使用的 zookeeper 集群独立出来。</p>
<p>这次事故让我认识到： Zookeeper 作为 CP 注册中心，大规模使用场景下，它就变得很脆弱，我们要非常小心的使用。</p>
<p>淘宝中间件博客出了一篇文章 :  <strong>阿里巴巴为什么不用 ZooKeeper 做服务发现</strong> ？</p>
<p>文章有两个观点，笔者认为非常有借鉴意义。</p>
<p>1、当数据中心服务规模超过一定数量 ( 服务规模=F{服务 pub 数,服务 sub 数} )，作为注册中心的 ZooKeeper 很快就会像下图的驴子一样不堪重负。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/zookeeper.png?c=1" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>2、<strong>可以使用 ZooKeeper，但是大数据请向左，而交易则向右，分布式协调向左，服务发现向右</strong>。</p>
<p>相比 ZooKeeper ，NameServer 是一个典型的 AP 注册中心，它有如下优点：</p>
<p>1、代码不到 1000 行，实现简单，易于维护 ;</p>
<p>2、性能极好，除了网络消耗，基本都是本地内存操作 ;</p>
<p>3、服务都是无状态，且节点之间并不交互，运维简单；</p>
<p>RocketMQ 的设计者之所以选择自研名字服务，遵循着架构设计的准则，笔者总结为：<strong>简单</strong>、<strong>高效</strong>、<strong>适当妥协</strong>。</p>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 生产者</title>
    <id>https://javayong.cn/mq/rocketmq4/03RocketMQ4_producer.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/03RocketMQ4_producer.html"/>
    <updated>2023-11-17T08:13:01.000Z</updated>
    <summary type="html"><![CDATA[<p>这篇文章，我们从源码的角度探寻 RocketMQ Producer 的实现机制。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/producer.png?b-12" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 基础配置</h2>
<p>我们先展示生产者发送消息的示例代码。</p>
<div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 1. 初始化默认生产者，传递参数生产者组名</span>
<span class="token class-name">DefaultMQProducer</span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultMQProducer</span><span class="token punctuation">(</span><span class="token constant">PRODUCER_GROUP</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2. 设置名字服务地址 </span>
producer<span class="token punctuation">.</span><span class="token function">setNamesrvAddr</span><span class="token punctuation">(</span><span class="token string">"name-server1-ip:9876;name-server2-ip:9876"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3. 启动生产者服务 </span>
producer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 4. 定义消息对象 </span>
<span class="token class-name">Message</span> msg <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token constant">TOPIC</span><span class="token operator">*</span> <span class="token comment">/* Topic */</span><span class="token punctuation">,</span>
        <span class="token operator">*</span><span class="token constant">TAG</span><span class="token operator">*</span> <span class="token comment">/* Tag */</span><span class="token punctuation">,</span>
        <span class="token punctuation">(</span><span class="token string">"Hello RocketMQ "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token class-name">RemotingHelper</span><span class="token punctuation">.</span>*<span class="token constant">DEFAULT_CHARSET</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token comment">/* Message body */</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
msg<span class="token punctuation">.</span><span class="token function">setKeys</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 5. 发送消息</span>
<span class="token comment">// 示例普通消息</span>
<span class="token class-name">SendResult</span> sendResult <span class="token operator">=</span> producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 示例异步回调</span>
producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">SendCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onSuccess</span><span class="token punctuation">(</span><span class="token class-name">SendResult</span> sendResult<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// do something</span>
    <span class="token punctuation">}</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onException</span><span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// do something</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 示例oneway发送</span>
producer<span class="token punctuation">.</span><span class="token function">sendOneway</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></summary>
    <content type="html"><![CDATA[<p>这篇文章，我们从源码的角度探寻 RocketMQ Producer 的实现机制。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/producer.png?b-12" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 基础配置</h2>
<p>我们先展示生产者发送消息的示例代码。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发送流程如下：</p>
<ol>
<li>初始化默认生产者，传递参数生产者组名；</li>
<li>设置名字服务地址 ；</li>
<li>启动生产者服务；</li>
<li>定义消息对象 ；</li>
<li>生产者支持<strong>普通发送</strong>、<strong>oneway 发送</strong>、<strong>异步回调</strong>三种方式发送消息 。</li>
</ol>
<h2> 2 发送消息流程</h2>
<h3> 2.1 构造函数</h3>
<p>下图展示了生产者<code>DefaultMQProducer</code> 类的构造函数，包装类 <code>DefaultMQProducerImpl</code> 是我们这一小节的核心。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/defaultmqproducer.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>构造函数包含两个部分：</p>
<ol>
<li>
<p>初始化实现类 <strong>DefaultMQProducerImpl</strong> ;</p>
</li>
<li>
<p>根据是否开启消息轨迹参数 <code>enableMsgTrace</code> 判断是否增加消息轨迹逻辑 。</p>
</li>
</ol>
<h3> 2.2 启动生产者</h3>
<p><code>DefaultMQProducer</code> 类的 start 方法，本质上是调用包装类 <code>DefaultMQProducerImpl</code> 的 start 方法。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/producerstart.png?a=1" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>进入 <code>DefaultMQProducerImpl</code> 类，查看该类的逻辑 。</p>
<h4> 01 检测配置</h4>
<p>判断生产者组是否合法，生产者名称不能和默认生产者组名称相同。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/producercheckconfig.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h4> 02 创建客户端实例</h4>
<figure><img src="https://javayong.cn/pics/rocketmq/mqclientinstance.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><code>MQClientInstance</code> 对象通过 <code>MQClientManager</code> 这个单例类创建 ，标志着一个客户端实例，是非常核心的类，每一个实例对象有一个唯一的 <code>clientId</code>。</p>
<ul>
<li>生产者表/消费者表引用</li>
</ul>
<figure><img src="https://javayong.cn/pics/rocketmq/clientmap.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<ul>
<li>
<p>路由信息</p>
<figure><img src="https://javayong.cn/pics/rocketmq/instanceroutertable.png" alt="" tabindex="0"><figcaption></figcaption></figure>
</li>
</ul>
<h4> 03 注册本地生产者</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>注册本地生产者的本质是修改客户端实例的生产者表引用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 04 启动客户端实例</h4>
<figure><img src="https://javayong.cn/pics/rocketmq/instancestart.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>实例启动后，会启动通讯模块、定时任务、负载均衡服务、消费者拉取服务。</p>
<p>下图展示了生产者发送消息时，IDEA 里的线程 DUMP 图：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/producerdump.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们需要重点讲讲定时任务 <code>startScheduledTask</code>方法 , 定时任务如下图：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/instanceclientschedule.png?a=2" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们重点关注<strong>发送心跳</strong>和<strong>更新路由</strong>两个任务。</p>
<ul>
<li><strong>发送心跳</strong>： 定时任务每隔 30 秒将客户端信息发送到 Broker 。</li>
</ul>
<figure><img src="https://javayong.cn/pics/rocketmq/HeartbeatData.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>当 Broker 收到心跳请求之后，会通过生产者管理器 <code>ProducerManager</code>、消费者管理器<code>ConsumerManager</code>分别更新生产者客户端缓存、消费者客户端缓存。</p>
<ul>
<li><strong>更新路由</strong></li>
</ul>
<p>对于生产者来讲，它需要知道需要发送消息的主题对应的路由信息 , 因此需要定时更新路由信息。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/updateTopicRouteInfoFromNameServer.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>更新逻辑比较简单，首先从名字服务获取主题路由信息对象 <code>topicRoute</code>，然后更新 <code>DefaultMQProducerImpl</code>的<strong>主题发布信息</strong><code>topicPublishInfoTable</code>对象 。</p>
<h3> 2.3 发送消息</h3>
<p>进入 <code>DefaultMQProducerImpl</code> 类，查看发送消息方法  <code>sendDefaultImpl </code>。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/sendimpl.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>笔者将发送消息流程简化如下：</p>
<ul>
<li>
<p>获取主题发布信息；</p>
</li>
<li>
<p>根据路由算法选择一个消息队列，也就是 <code>selectOneMessageQueue</code>方法；</p>
</li>
<li>
<p>调用 <code>sendKernelImpl</code>发放消息对象，封装成发送结果对象 <code>sendResult</code>。</p>
</li>
</ul>
<h4> 01 尝试获取主题发布信息</h4>
<p>我们知道 <code>MQClientInstance</code> 的定时任务每隔30秒会更新生产者实现类的<code>topicPublishInfoTable  </code>，但若第一次发送消息时，若缓存中无数据时候，还是要重新拉取一次。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/trytofinidtopicpublishinfo.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h4> 02 根据路由算法选择一个消息队列</h4>
<p>RocketMQ 存储模型包含三部分： <strong>数据文件 commitlog</strong> 、<strong>消费文件 consumequeue</strong> 、<strong>索引文件 indexfile</strong>。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/filelogic.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://javayong.cn/pics/rocketmq/filefileoverview.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>因此根据 RocketMQ 的存储模型设计，**对于生产者来讲，发送消息时，必须指定该主题对应的队列。**路由算法，我们会在路由机制这一节重点讲解。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 03 调用实例客户端 API 发送消息</h4>
<p>通过路由机制选择一个 messageQueue 之后，调用实例客户端 API 发送消息。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/kernelimpl.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Broker 端在收到发送消息请求后，调用处理器 <code>SendMessageProcessor</code>处理请求，处理完成后，将响应结果返回给生产者客户端，客户端将接收到的数据组装成 <code>SendResult</code>对象。</p>
<h2> 3 路由机制</h2>
<p>进入<code>DefaultMQProducerImpl#selectOneMessageQueue</code> 方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>路由机制通过调用 <code> MQFaultStrategy</code> 的 <code>selectOneMessageQueue</code> 方法 ，这里有一个 <code>sendLatencyFaultEnable</code>  开关变量，默认为 false 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里有两个逻辑分支 ：</p>
<ol>
<li><code>sendLatencyFaultEnable</code> 为 false ， 通过 <code>TopicPublishInfo</code> 中的 <code> messageQueueList</code>  中选择一个队列（MessageQueue）进行发送消息 ；</li>
<li><code>sendLatencyFaultEnable</code> 为 true ，开启<strong>延迟容错机制</strong>。</li>
</ol>
<h3> 3.1 默认机制</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>默认机制有两个要点：</p>
<ol>
<li>循环遍历该主题下所有的队列 ；</li>
<li>若上一个失败的 Broker 参数值存在，需要过滤掉上一个失败的 Broker 。</li>
</ol>
<h3> 3.2 延迟容错机制</h3>
<p>所谓<strong>延迟容错机制</strong>，是指发送消息时，若某个队列对应的 Broker 宕机了，在默认机制下很可能下一次选择的队列还是在已经宕机的 broker ，没有办法规避故障的broker，因此消息发送很可能会再次失败，重试发送造成了不必要的性能损失。</p>
<p>因此 producer 提供了<strong>延迟容错机制</strong>来规避故障的 Broker 。</p>
<p>当<code> sendLatencyFaultEnable</code>  开关为 true 时，在随机递增取模的基础上，代码逻辑会再去过滤掉 not available 的 Broker 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>所谓的" <code>latencyFaultTolerance</code> "，是指对之前失败的，按一定的时间做退避。</p>
<p>例如，如果上次请求的latency超过 550Lms，就退避 3000Lms；超过1000L，就退避 60000L ；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，<code>latencyFaultTolerance</code> 机制是实现消息发送高可用的核心关键所在。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发送消息时捕捉到异常同样会调用 <code>updateFaultItem</code> 方法：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>endTimestamp - beginTimestampPrev</code>等于消息发送耗时，如果成功发送第三个参数传的是 false ，发送失败传  true。</p>
<p>继续查看 <code>MQFaultStrategy#updateFaultItem </code> 源码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>computeNotAvailableDuration</code>方法会判断当前消息发送耗时，位于哪一个延迟级别，然后选择对应的 duration 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果<code> isolation</code> 为 true，该 broker 会得到一个10分钟规避时长 ，也就是 600000L 毫秒 。</p>
<p>如果 <code>isolation</code> 为 false，假设 currentLatency 为 600L , 那么规避时间 30000L 毫秒。</p>
<p>查看 <code>LatencyFaultToleranceImpl#updateFaultItem </code> 源码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>FaultItem 为存储故障 broker 的类，称为失败条目，每个条目存储了 broker 的名称、消息发送延迟时长、故障规避开始时间。</p>
<p>该方法主要是对失败条目的一些更新操作，如果失败条目已存在，那么更新失败条目，如果失败条目不存在，那么新建失败条目，其中失败条目的<code>startTimestamp</code>为当前系统时间加上规避时长，<code> startTimestamp</code> 是判断 broker 是否可用的时间值：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2> 4 顺序消息</h2>
<p>顺序消息可以保证消息的消费顺序和发送的顺序一致，即先发送的先消费，后发送的后消费，常用于金融证券、电商业务等对消息指令顺序有严格要求的场景。</p>
<h3> 4.1 如何保证顺序消息</h3>
<p>消息的顺序需要由以下三个阶段保证：</p>
<ul>
<li>
<p><strong>消息发送</strong></p>
<p>如上图所示，A1、B1、A2、A3、B2、B3 是订单 A 和订单 B 的消息产生的顺序，业务上要求同一订单的消息保持顺序，例如订单A的消息发送和消费都按照 A1、A2、A3 的顺序。</p>
<p>如果是普通消息，订单A的消息可能会被轮询发送到不同的队列中，不同队列的消息将无法保持顺序，而顺序消息发送时 RocketMQ 支持将 Sharding Key 相同（例如同一订单号）的消息序路由到一个队列中。</p>
<p>RocketMQ 版服务端判定消息产生的顺序性是参照同一生产者发送消息的时序。不同生产者、不同线程并发产生的消息，云消息队列 RocketMQ 版服务端无法判定消息的先后顺序。</p>
<figure><img src="https://www.javayong.cn/pics/temp//wsNXq03SCB.png" alt="" tabindex="0"><figcaption></figcaption></figure>
</li>
<li>
<p><strong>消息存储</strong></p>
<p>顺序消息的 Topic 中，每个逻辑队列对应一个物理队列，当消息按照顺序发送到 Topic 中的逻辑队列时，每个分区的消息将按照同样的顺序存储到对应的物理队列中。</p>
<p>对于 kafka 来讲，1个主题会有多个分区，数据存储在每个分区，分区里文件以 <code>Segment</code> 文件串联起来。</p>
<p>对于 RocketMQ 来讲 ,  存储模型包含三部分： <strong>数据文件 commitlog</strong> 、<strong>消费文件 consumequeue</strong> 、<strong>索引文件 indexfile</strong>。</p>
<p>kafka 和 RocketMQ 文件模型很类似，只不过 kafka 的文件数据都会存储在不同的分区里，而 RocketMQ 的数据都存储在 CommitLog 文件里 ，不同的消息会存储在不同的消费队列文件里，便于提升消费者性能（索引）。</p>
<p>所以我们只需要将特定的消息发送到特定的逻辑队列里，对于 kafka 来讲是分区 partition ，对于 RocketMQ 来讲，就是消费队列 messageQueue 。</p>
</li>
<li>
<p><strong>消息消费</strong></p>
<p>RocketMQ 按照存储的顺序将消息投递给 Consumer，Consumer 收到消息后也不对消息顺序做任何处理，按照接收到的顺序进行消费。</p>
<p>Consumer 消费消息时，同一 Sharding Key 的消息使用单线程消费，保证消息消费顺序和存储顺序一致，最终实现消费顺序和发布顺序的一致。</p>
</li>
</ul>
<h3> 4.2. 生产者发送顺序消息</h3>
<p>下面的代码展示生产者如何发生顺序消息 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发送顺序消息需要定制<code>队列选择器 MessageQueueSelector</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入 <code>DefaultMQProducerImpl#sendSelectImpl  </code>, 查看顺序消费发送的实现逻辑。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的顺序消息发送代码，我们得到两点结论：</p>
<ol>
<li>顺序消息发送时，需要实现 <code> MessageQueueSelector</code> 的 <code>select</code>方法 ；</li>
<li>发送顺序消息时，若发送失败没有重试。</li>
</ol>
<hr>
<p>参考文档：</p>
<blockquote>
<p>https://developer.aliyun.com/article/918025</p>
</blockquote>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 存储模型</title>
    <id>https://javayong.cn/mq/rocketmq4/04RocketMQ4_store.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/04RocketMQ4_store.html"/>
    <updated>2023-11-17T07:53:52.000Z</updated>
    <summary type="html"><![CDATA[<p>RocketMQ 优异的性能表现，必然绕不开其优秀的存储模型 。</p>
<p>这篇文章，笔者按照自己的理解 , 尝试分析 RocketMQ 的存储模型，希望对大家有所启发。</p>
<figure><img src="https://www.javayong.cn/pics/temp//4IBZMyztpU.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 整体概览</h2>
<p>首先温习下 RocketMQ 架构。</p>
<figure><img src="https://www.javayong.cn/pics/temp//XYRrSnhfuT.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>RocketMQ 优异的性能表现，必然绕不开其优秀的存储模型 。</p>
<p>这篇文章，笔者按照自己的理解 , 尝试分析 RocketMQ 的存储模型，希望对大家有所启发。</p>
<figure><img src="https://www.javayong.cn/pics/temp//4IBZMyztpU.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 整体概览</h2>
<p>首先温习下 RocketMQ 架构。</p>
<figure><img src="https://www.javayong.cn/pics/temp//XYRrSnhfuT.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>整体架构中包含四种角色 :</p>
<ul>
<li>
<p>Producer ：消息发布的角色，Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
</li>
<li>
<p>Consumer ：消息消费的角色，支持以 push 推，pull 拉两种模式对消息进行消费。</p>
</li>
<li>
<p>NameServer ：名字服务是一个非常简单的 Topic 路由注册中心，其角色类似 Dubbo 中的 zookeeper ，支持 Broker 的动态注册与发现。</p>
</li>
<li>
<p>BrokerServer ：Broker 主要负责消息的存储、投递和查询以及服务高可用保证 。</p>
</li>
</ul>
<p>本文的重点在于分析 BrokerServer 的消息存储模型。我们先进入 broker 的文件存储目录 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//AWhYeCz1HL.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消息存储和下面三个文件关系非常紧密：</p>
<ol>
<li>
<p><strong>数据文件 commitlog</strong></p>
<p>消息主体以及元数据的存储主体 ；</p>
</li>
<li>
<p><strong>消费文件 consumequeue</strong></p>
<p>消息消费队列，引入的目的主要是提高消息消费的性能 ；</p>
</li>
<li>
<p><strong>索引文件 indexfile</strong></p>
<p>索引文件，提供了一种可以通过 key 或时间区间来查询消息。</p>
</li>
</ol>
<p>RocketMQ 采用的是混合型的存储结构，Broker 单个实例下所有的队列共用一个数据文件（commitlog）来存储。</p>
<p>生产者发送消息至 Broker 端，然后 Broker 端使用同步或者异步的方式对消息刷盘持久化，保存至 commitlog 文件中。只要消息被刷盘持久化至磁盘文件 commitlog 中，那么生产者发送的消息就不会丢失。</p>
<p>Broker 端的后台服务线程会不停地分发请求并异步构建 consumequeue（消费文件）和 indexfile（索引文件）。</p>
<h2> 2 数据文件</h2>
<p>RocketMQ 的消息数据都会写入到数据文件中， 我们称之为 commitlog 。</p>
<p><strong>所有的消息都会顺序写入数据文件，当文件写满了，会写入下一个文件</strong>。</p>
<figure><img src="https://www.javayong.cn/pics/temp//OXCR8q0haW.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>如上图所示，单个文件大小默认 1G , 文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0 ，文件大小为1 G = 1073741824。</p>
<p>当第一个文件写满了，第二个文件为 00000000001073741824，起始偏移量为 1073741824，以此类推。</p>
<figure><img src="https://www.javayong.cn/pics/temp//gzN5dRWsG7.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>从上图中，我们可以看到消息是一条一条写入到文件，每条消息的格式是固定的。</p>
<p>这样设计有三点优势：</p>
<ol>
<li>
<p>顺序写</p>
<p>磁盘的存取速度相对内存来讲并不快，一次磁盘 IO 的耗时主要取决于：寻道时间和盘片旋转时间，提高磁盘 IO 性能最有效的方法就是：减少随机 IO，增加顺序 IO 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//EjZJC7giv1.webp!large" alt="对比随机和顺序读写在内存和磁盘中的表现" tabindex="0"><figcaption>对比随机和顺序读写在内存和磁盘中的表现</figcaption></figure>
<p>《 The Pathologies of Big Data 》这篇文章指出：内存随机读写的速度远远低于磁盘顺序读写的速度。磁盘顺序写入速度可以达到几百兆/s，而随机写入速度只有几百 KB /s，相差上千倍。</p>
</li>
<li>
<p>快速定位</p>
<p>因为消息是一条一条写入到 commitlog 文件 ，写入完成后，我们可以得到这条消息的物理偏移量。</p>
<p>每条消息的物理偏移量是唯一的， commitlog 文件名是递增的，可以根据消息的物理偏移量通过<strong>二分查找</strong>，定位消息位于那个文件中，并获取到消息实体数据。</p>
</li>
<li>
<p>通过消息 offsetMsgId 查询消息数据</p>
<figure><img src="https://www.javayong.cn/pics/temp//xphlePAVT9.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消息 offsetMsgId 是由 Broker 服务端在写入消息时生成的 ，该消息编号包含两个部分：</p>
<ul>
<li>
<p>Broker 服务端 ip + port  8个字节；</p>
</li>
<li>
<p>commitlog 物理偏移量 8个字节 。</p>
</li>
</ul>
<p>我们可以通过消息 offsetMsgId ，定位到 Broker 的 ip 地址 + 端口 ，传递物理偏移量参数 ，即可定位该消息实体数据。</p>
</li>
</ol>
<h2> 3 消费文件</h2>
<p>在介绍 consumequeue 文件之前， 我们先温习下消息队列的传输模型-<strong>发布订阅模型</strong> ， 这也是 RocketMQ 当前的传输模型。</p>
<figure><img src="https://www.javayong.cn/pics/temp//reIMgPJi1b.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>发布订阅模型具有如下特点：</p>
<ul>
<li>消费独立：相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。</li>
<li>一对多通信：基于独立身份的设计，同一个主题内的消息可以被多个订阅组处理，每个订阅组都可以拿到全量消息。因此发布订阅模型可以实现一对多通信。</li>
</ul>
<p>因此，<strong>rocketmq 的文件设计必须满足发布订阅模型的需求。</strong></p>
<p>那么仅仅 commitlog 文件是否可以满足需求吗 ？</p>
<p>假如有一个 consumerGroup 消费者，订阅主题 my-mac-topic ，因为 commitlog 包含所有的消息数据，查询该主题下的消息数据，需要遍历数据文件 commitlog , 这样的效率是极其低下的。</p>
<p>进入 rocketmq 存储目录，显示见下图：</p>
<figure><img src="https://www.javayong.cn/pics/temp//E7tgMi1WhB.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<ol>
<li>消费文件按照主题存储，每个主题下有不同的队列，图中 my-mac-topic 有 16 个队列 ;</li>
<li>每个队列目录下 ，存储 consumequeue 文件，每个 consumequeue 文件也是顺序写入，数据格式见下图。</li>
</ol>
<figure><img src="https://www.javayong.cn/pics/temp//o4BiIVsDSs.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>每个 consumequeue 包含 30 万个条目，每个条目大小是 20 个字节，每个文件的大小是 30 万 * 20 = 60万字节，每个文件大小约5.72M 。和 commitlog 文件类似，consumequeue 文件的名称也是以偏移量来命名的，可以通过消息的逻辑偏移量定位消息位于哪一个文件里。</p>
<p>消费文件按照<strong>主题-队列</strong>来保存 ，这种方式特别适配<strong>发布订阅模型</strong>。</p>
<p>消费者从 broker 获取订阅消息数据时，不用遍历整个 commitlog 文件，只需要根据逻辑偏移量从 consumequeue 文件查询消息偏移量 ,  最后通过定位到 commitlog 文件， 获取真正的消息数据。</p>
<p>这样就可以简化消费查询逻辑，同时因为同一主题下，消费者可以订阅不同的队列或者 tag ，同时提高了系统的可扩展性。</p>
<h2> 4 索引文件</h2>
<p>每个消息在业务层面的唯一标识码要设置到 keys 字段，方便将来定位消息丢失问题。服务器会为每个消息创建索引（哈希索引），应用可以通过 topic、key 来查询这条消息内容，以及消息被谁消费。</p>
<p>由于是哈希索引，请务必保证key尽可能唯一，这样可以避免潜在的哈希冲突。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从开源的控制台中根据主题和 key 查询消息列表：</p>
<figure><img src="https://www.javayong.cn/pics/temp//6OMAGHF1zX.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>进入索引文件目录 ，如下图所以：</p>
<figure><img src="https://www.javayong.cn/pics/temp//03v6Z5ZaES.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>索引文件名 fileName 是以创建时的时间戳命名的，固定的单个 IndexFile 文件大小约为 400 M 。</p>
<p>IndexFile 的文件逻辑结构类似于 JDK 的 HashMap 的<strong>数组加链表</strong>结构。</p>
<figure><img src="https://www.javayong.cn/pics/temp//HBvvQgemjK.webp!large" alt="HashMap数据结构" tabindex="0"><figcaption>HashMap数据结构</figcaption></figure>
<p>索引文件主要由 Header、Slot Table (默认 500 万个条目)、Index Linked List（默认最多包含 2000万个条目）三部分组成 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//iigZg4mGG2.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>假如订单系统发送两条消息 A 和 B , 他们的 key 都是 "1234567890" ，我们依次存储消息 A  ,  消息 B 。</p>
<p>因为这两个消息的 key 的 hash 值相同，它们对应的哈希槽（深黄色）也会相同，哈希槽会保存的最新的消息 B 的索引条目序号 , 序号值是 4 ，也就是第二个深绿色条目。</p>
<p>而消息 B 的索引条目信息的最后 4 个字节会保存上一条消息对应的索引条目序号，索引序号值是 3  , 也就是消息 A 。</p>
<h2> 5 写到最后</h2>
<blockquote>
<p>Databases are specializing – the “one size fits all” approach no longer applies ------ MongoDB设计哲学</p>
</blockquote>
<p>RocketMQ 存储模型设计得非常精巧，笔者觉得每种设计都有其底层思考，这里总结了三点 ：</p>
<ol>
<li>完美适配消息队列发布订阅模型 ；</li>
<li>数据文件，消费文件，索引文件各司其职 ，同时以数据文件为核心，异步构建消费文件 + 索引文件这种模式非常容易扩展到主从复制的架构；</li>
<li>充分考虑业务的查询场景，支持消息 key ，消息 offsetMsgId 查询消息数据。也支持消费者通过 tag 来订阅主题下的不同消息，提升了消费者的灵活性。</li>
</ol>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 消费者</title>
    <id>https://javayong.cn/mq/rocketmq4/06RocketMQ4_consumer.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/06RocketMQ4_consumer.html"/>
    <updated>2023-11-17T08:13:01.000Z</updated>
    <summary type="html"><![CDATA[<p>RocketMQ 是笔者非常喜欢的消息队列，4.9.X 版本是目前使用最广泛的版本，但它的消费逻辑相对较重，很多同学学习起来没有头绪。</p>
<p>这篇文章，笔者梳理了 RocketMQ 的消费逻辑，希望对大家有所启发。</p>
<figure><img src="https://www.javayong.cn/pics/temp//qaRc3GjFlL.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 架构概览</h2>
<p>在展开集群消费逻辑细节前，我们先对 RocketMQ 4.X 架构做一个概览。</p>]]></summary>
    <content type="html"><![CDATA[<p>RocketMQ 是笔者非常喜欢的消息队列，4.9.X 版本是目前使用最广泛的版本，但它的消费逻辑相对较重，很多同学学习起来没有头绪。</p>
<p>这篇文章，笔者梳理了 RocketMQ 的消费逻辑，希望对大家有所启发。</p>
<figure><img src="https://www.javayong.cn/pics/temp//qaRc3GjFlL.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 架构概览</h2>
<p>在展开集群消费逻辑细节前，我们先对 RocketMQ 4.X 架构做一个概览。</p>
<figure><img src="https://www.javayong.cn/pics/temp//WmCfyfFaPD-20231117160806702.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>整体架构中包含<strong>四种角色</strong> :</p>
<p><strong>1、NameServer</strong></p>
<p>名字服务是是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。它是一个非常简单的 Topic 路由注册中心，其角色类似 Dubbo 中的 zookeeper ，支持 Broker 的动态注册与发现。</p>
<p><strong>2、BrokerServer</strong></p>
<p>Broker 主要负责消息的存储、投递和查询以及服务高可用保证 。</p>
<p><strong>3、Producer</strong></p>
<p>消息发布的角色，Producer 通过 MQ 的负载均衡模块选择相应的 Broker 集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
<p><strong>4、Consumer</strong></p>
<p>消息消费的角色，支持以 push 推，pull 拉两种模式对消息进行消费。</p>
<p>RocketMQ 集群工作流程：</p>
<p>1、<strong>启动 NameServer</strong>，NameServer 起来后监听端口，等待 Broker、Producer 、Consumer 连上来，相当于一个路由控制中心。</p>
<p>2、<strong>Broker 启动</strong>，跟所有的 NameServer 保持长连接，定时发送心跳包。心跳包中包含当前 Broker信息( IP+端口等 )以及存储所有 Topic 信息。注册成功后，NameServer 集群中就有 Topic 跟 Broker 的映射关系。</p>
<p>3、收发消息前，先<strong>创建 Topic</strong>，创建 Topic 时需要指定该 Topic 要存储在哪些 Broker 上，也可以在发送消息时自动创建 Topic。</p>
<p>4、<strong>Producer 发送消息</strong>，启动时先跟 NameServer 集群中的其中一台建立长连接，并从 NameServer 中获取当前发送的 Topic 存在哪些 Broker 上，轮询从队列列表中选择一个队列，然后与队列所在的 Broker 建立长连接从而向 Broker 发消息。</p>
<p>5、Consumer 跟 Producer 类似，跟其中一台 NameServer 建立长连接，获取当前订阅 Topic 存在哪些 Broker 上，然后直接跟 Broker 建立连接通道，开始<strong>消费消息</strong>。</p>
<h2> 2 发布订阅</h2>
<p>RocketMQ 的传输模型是：<strong>发布订阅模型</strong> 。</p>
<p>发布订阅模型具有如下特点：</p>
<ul>
<li>
<p><strong>消费独立</strong></p>
<p>相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。</p>
</li>
<li>
<p><strong>一对多通信</strong></p>
<p>基于独立身份的设计，同一个主题内的消息可以被多个订阅组处理，每个订阅组都可以拿到全量消息。因此发布订阅模型可以实现一对多通信。</p>
</li>
</ul>
<p>RocketMQ 支持两种消息模式：<strong>集群消费</strong>（ Clustering ）和<strong>广播消费</strong>（ Broadcasting ）。</p>
<p><strong>集群消费</strong>：<strong>同一 Topic 下的一条消息只会被同一消费组中的一个消费者消费</strong>。也就是说，消息被负载均衡到了同一个消费组的多个消费者实例上。</p>
<figure><img src="https://www.javayong.cn/pics/temp//YB1Famn1EF.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>广播消费</strong>：当使用广播消费模式时，每条消息推送给集群内所有的消费者，保证消息至少被每个消费者消费一次。</p>
<figure><img src="https://www.javayong.cn/pics/temp//32GDhELg1w.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>为了实现这种发布订阅模型 ， RocketMQ 精心设计了它的存储模型。先进入 Broker 的文件存储目录。</p>
<figure><img src="https://www.javayong.cn/pics/temp//AWhYeCz1HL-20231117160806691.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>RocketMQ 采用的是<strong>混合型</strong>的存储结构。</p>
<p><strong>1、Broker 单个实例下所有的队列共用一个数据文件（commitlog）来存储</strong></p>
<p>生产者发送消息至 Broker 端，然后 Broker 端使用同步或者异步的方式对消息刷盘持久化，保存至 commitlog 文件中。只要消息被刷盘持久化至磁盘文件 commitlog 中，那么生产者发送的消息就不会丢失。</p>
<p>单个文件大小默认 1G , 文件名长度为 20 位，左边补零，剩余为起始偏移量，比如 00000000000000000000 代表了第一个文件，起始偏移量为 0 ，文件大小为1 G = 1073741824 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//OXCR8q0haW-20231117160806755.webp!large" alt=" commitlog 目录" tabindex="0"><figcaption> commitlog 目录</figcaption></figure>
<p>这种设计有两个优点：</p>
<ul>
<li>
<p>充分利用顺序写，大大提升写入数据的吞吐量；</p>
</li>
<li>
<p>快读定位消息。</p>
<p>因为消息是一条一条写入到 commitlog 文件 ，写入完成后，我们可以得到这条消息的<strong>物理偏移量</strong>。</p>
<p>每条消息的物理偏移量是唯一的， commitlog 文件名是递增的，可以根据消息的物理偏移量通过<strong>二分查找</strong>，定位消息位于那个文件中，并获取到消息实体数据。</p>
</li>
</ul>
<p><strong>2、Broker 端的后台服务线程会不停地分发请求并异步构建 consumequeue（消费文件）和 indexfile（索引文件）</strong></p>
<p>进入消费文件存储目录 ：</p>
<figure><img src="https://www.javayong.cn/pics/temp//E7tgMi1WhB-20231117160806719.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>1、消费文件按照主题存储，每个主题下有不同的队列，图中主题 my-mac-topic 有 16 个队列 (0 到 15) ;</p>
<p>2、每个队列目录下 ，存储 consumequeue 文件，每个 consumequeue 文件也是顺序写入，数据格式见下图。</p>
<figure><img src="https://www.javayong.cn/pics/temp//1y4ZNBbc3K.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>每个 consumequeue 文件包含 30 万个条目，每个条目大小是 20 个字节，每个文件的大小是 30 万 * 20 = 60万字节，每个文件大小约 5.72M 。</p>
<p>和 commitlog 文件类似，consumequeue 文件的名称也是以偏移量来命名的，可以通过消息的逻辑偏移量定位消息位于哪一个文件里。</p>
<p>消费文件按照<strong>主题-队列</strong>来保存 ，这种方式特别适配<strong>发布订阅模型</strong>。</p>
<p>消费者从 Broker 获取订阅消息数据时，不用遍历整个 commitlog 文件，只需要根据逻辑偏移量从 consumequeue 文件查询消息偏移量 , 最后通过定位到 commitlog 文件， 获取真正的消息数据。</p>
<p>要实现发布订阅模型，还需要一个重要文件：<strong>消费进度</strong>文件。原因有两点：</p>
<ul>
<li>
<p>不同消费组之间相互独立，不会相互影响 ；</p>
</li>
<li>
<p>消费者下次拉取数据时，需要知道从哪个进度开始拉取 ，就像我们小时候玩单机游戏存盘一样。</p>
</li>
</ul>
<p>因此消费进度文件需要保存消费组所订阅主题的消费进度。</p>
<p>我们浏览下集群消费场景下的 Broker 端的消费进度文件 <strong>consumerOffset.json</strong> 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//KdhMCdYePf.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://www.javayong.cn/pics/temp//jpfI145dyQ.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>在进度文件 consumerOffset.json 里，数据以 key-value 的结构存储，key 表示：主题@消费者组 ， value 是 consumequeue 中每个队列对应的逻辑偏移量 。</p>
<p>写到这里，我们<strong>粗糙模拟</strong>下 RocketMQ <strong>存储模型如何满足发布订阅模型</strong> 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//cnRQMAQDa2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>1、<strong>发送消息</strong>：生产者发送消息到 Broker ；</p>
<p>2、<strong>保存消息</strong>：Broker 将消息存储到 commitlog 文件 ，异步线程会构建消费文件 consumequeue ；</p>
<p>3、<strong>消费流程</strong>：消费者启动后，会通过负载均衡分配对应的队列，然后向 Broker 发送拉取消息请求。Broker 收到消费者拉取请求之后，根据订阅组，消费者编号，主题，队列名，逻辑偏移量等参数 ，从该主题下的 consumequeue 文件查询消息消费条目，然后从 commitlog 文件中获取消息实体。消费者在收到消息数据之后，执行消费监听器，消费完消息；</p>
<p>4、<strong>保存进度</strong>：消费者将消费进度提交到 Broker ，Broker 会将该消费组的消费进度存储在进度文件里。</p>
<h2> 3 消费流程</h2>
<p>我们重点讲解下集群消费的消费流程 ，因为<strong>集群消费是使用最普遍的消费模式</strong>，理解了集群消费，广播消费也就能顺理成章的掌握了。</p>
<figure><img src="https://www.javayong.cn/pics/temp//JMHeWL51md.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>集群消费示例代码里，启动消费者，我们需要配置三个核心属性：<strong>消费组名</strong>、<strong>订阅主题</strong>、<strong>消息监听器</strong>，最后调用 start 方法启动。</p>
<p>首先进入 <code>DefaultMQPushConsumerImpl</code> 类的 <code>start</code> 方法 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//pushconsumerstart.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费者启动后，我们可以将整个流程简化成：</p>
<figure><img src="https://www.javayong.cn/pics/temp//consumerliucheng.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 4 负载均衡</h2>
<p>消费端的负载均衡是指<strong>将 Broker 端中多个队列按照某种算法分配给同一个消费组中的不同消费者，负载均衡是客户端开始消费的起点</strong>。</p>
<p>RocketMQ 负载均衡的<strong>核心设计理念</strong>是</p>
<ul>
<li>
<p>消费队列在同一时间只允许被同一消费组内的一个消费者消费</p>
</li>
<li>
<p>一个消费者能同时消费多个消息队列</p>
</li>
</ul>
<p>负载均衡是每个<strong>客户端独立进行计算</strong>，那么何时触发呢 ？</p>
<figure><img src="https://www.javayong.cn/pics/temp//yxd8EaU0qS.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<ul>
<li>
<p>消费端启动时，立即进行负载均衡；</p>
</li>
<li>
<p>消费端定时任务每隔 20 秒触发负载均衡；</p>
</li>
<li>
<p>消费者上下线，Broker 端通知消费者触发负载均衡。</p>
</li>
</ul>
<p>负载均衡流程如下：</p>
<p><strong>1、发送心跳</strong></p>
<p>消费者启动后，它就会通过定时任务不断地向 RocketMQ 集群中的所有 Broker 实例发送心跳包（<strong>消息消费分组名称</strong>、<strong>订阅关系集合</strong>、<strong>消息通信模式</strong>和<strong>客户端实例编号</strong>等信息）。</p>
<p>Broker 端在收到消费者的心跳消息后，会将它维护在 ConsumerManager 的本地缓存变量 consumerTable，同时并将封装后的客户端网络<strong>通道信息</strong>保存在本地缓存变量 channelInfoTable 中，为之后做消费端的负载均衡提供可以依据的元数据信息。</p>
<p><strong>2、启动负载均衡服务</strong></p>
<p>负载均衡服务会根据消费模式为”广播模式”还是“集群模式”做不同的逻辑处理，这里主要来看下集群模式下的主要处理流程：</p>
<p>(1) 获取该主题下的消息消费队列集合；</p>
<p>(2) 查询 Broker 端获取该消费组下消费者 Id 列表；</p>
<p>(3) 先对 Topic 下的消息消费队列、消费者 Id 排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列；</p>
<figure><img src="https://www.javayong.cn/pics/temp//iYLyVcUAt4.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://www.javayong.cn/pics/temp//4OHEa2jquR.webp!large" alt="平均分配算法" tabindex="0"><figcaption>平均分配算法</figcaption></figure>
<p>这里的平均分配算法，类似于分页的算法，将所有 MessageQueue 排好序类似于记录，将所有消费端排好序类似页数，并求出每一页需要包含的平均 size 和每个页面记录的范围 range ，最后遍历整个 range 而计算出当前消费端应该分配到的记录。</p>
<p>(4) 分配到的消息队列集合与 processQueueTable 做一个过滤比对操作。</p>
<figure><img src="https://www.javayong.cn/pics/temp//xs0dDuzfwc.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费者实例内 ，processQueueTable 对象存储着当前负载均衡的队列 ，以及该队列的处理队列 processQueue (消费快照)。</p>
<ol>
<li>
<p>标红的 Entry 部分表示与分配到的消息队列集合互不包含，则需要将这些红色队列 Dropped 属性为 true , 然后从 processQueueTable 对象中移除。</p>
</li>
<li>
<p>绿色的 Entry 部分表示与分配到的消息队列集合的交集，processQueueTable 对象中已经存在该队列。</p>
</li>
<li>
<p>黄色的 Entry 部分表示这些队列需要添加到 processQueueTable 对象中，为每个分配的新队列创建一个消息拉取请求 <code>pullRequest</code> , 在消息拉取请求中保存一个处理队列 <code>processQueue</code> （队列消费快照），内部是红黑树（<code>TreeMap</code>），用来保存拉取到的消息。</p>
</li>
</ol>
<p>最后创建拉取消息请求列表，并<strong>将请求分发到消息拉取服务，进入拉取消息环节</strong>。</p>
<h2> 5 长轮询</h2>
<p>在负载均衡这一小节，我们已经知道<strong>负载均衡触发了拉取消息的流程</strong>。</p>
<p>消费者启动的时候，会创建一个<strong>拉取消息服务 PullMessageService</strong> ，它是一个单线程的服务。</p>
<figure><img src="https://www.javayong.cn/pics/temp//9lQ0kqqgMV.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>核心流程如下：</p>
<p>1、负载均衡服务将消息拉取请求放入到拉取请求队列 pullRequestQueue , 拉取消息服务从队列中获取<strong>拉取消息请求</strong> ；</p>
<p>2、拉取消息服务向 Brorker 服务发送拉取请求 ，拉取请求的通讯模式是<strong>异步回调模式</strong> ;</p>
<figure><img src="https://www.javayong.cn/pics/temp//wU7kAPifpi.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费者的拉取消息服务本身就是一个单线程，使用异步回调模式，发送拉取消息请求到 Broker 后，<strong>拉取消息线程并不会阻塞</strong> ，可以继续处理队列 pullRequestQueue 中的其他拉取任务。</p>
<p>3、Broker 收到消费者拉取消息请求后，从存储中查询出消息数据，然后返回给消费者；</p>
<p>4、消费者的网络通讯层会执行<strong>拉取回调函数</strong>相关逻辑，首先会将消息数据存储在队列消费快照 processQueue 里；</p>
<p>消费快照使用<strong>红黑树 msgTreeMap</strong> 存储拉取服务拉取到的消息 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//XdYYK2Hqk2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>5、回调函数将<strong>消费请求</strong>提交到<strong>消息消费服务</strong> ，而消息消费服务会<strong>异步</strong>的消费这些消息；</p>
<p>6、回调函数会将处理中队列的拉取请放入到定时任务中；</p>
<p>7、定时任务再次将消息拉取请求放入到队列 pullRequestQueue 中，<strong>形成了闭环</strong>：负载均衡后的队列总会有任务执行拉取消息请求，不会中断。</p>
<p>细心的同学肯定有疑问：<strong>既然消费端是拉取消息，为什么是长轮询呢</strong> ？</p>
<p>虽然拉模式的主动权在消费者这一侧，但是缺点很明显。</p>
<p>因为消费者并不知晓 Broker 端什么时候有新的消息 ，所以会不停地去 Broker 端拉取消息，但拉取频率过高， Broker 端压力就会很大，频率过低则会导致消息延迟。</p>
<p>所以<strong>要想消费消息的延迟低，服务端的推送必不可少</strong>。</p>
<p>下图展示了 RocketMQ 如何通过长轮询减小拉取消息的延迟。</p>
<figure><img src="https://www.javayong.cn/pics/temp//c53QfosbB2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>核心流程如下：</p>
<p>1、Broker 端接收到消费者的拉取消息请求后，拉取消息处理器开始处理请求，根据拉取请求查询消息存储 ；</p>
<p>2、从消息存储中获取消息数据 ，若存在新消息 ，则将消息数据通过网络返回给消费者。若无新消息，则将拉取请求放入到<strong>拉取请求表 pullRequestTable</strong> 。</p>
<p>3、<strong>长轮询请求管理服务</strong> pullRequestHoldService 每隔 5 秒从拉取请求表中判断拉取消息请求的队列是否有新的消息。</p>
<p>判定标准是：拉取消息请求的偏移量是否小于当前消费队列最大偏移量，如果条件成立则说明有新消息了。</p>
<p>若存在新的消息 , <strong>长轮询请求管理服务</strong>会触发拉取消息处理器重新处理该拉取消息请求。</p>
<p>4、当 commitlog 中新增了新的消息，消息分发服务会构建消费文件和索引文件，并且会通知<strong>长轮询请求管理服务</strong>，触发<strong>拉取消息处理器重新处理该拉取消息请求</strong>。</p>
<h2> 6 消费消息</h2>
<p>在拉取消息的流程里， Broker 端返回消息数据，消费者的通讯框架层会执行回调函数。</p>
<p>回调线程会将数据存储在队列消费快照 processQueue（内部使用<strong>红黑树 msgTreeMap</strong>）里，然后将消息提交到消费消息服务，消费消息服务会异步消费这些消息。</p>
<figure><img src="https://www.javayong.cn/pics/temp//aWJXs9ZF6L.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消息消费服务有两种类型：<strong>并发消费服务</strong>和<strong>顺序消费服务</strong> 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//FC4h3oP2zB.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h3> 6.1 并发消费</h3>
<p>并发消费是指<strong>消费者将并发消费消息，消费的时候可能是无序的</strong>。</p>
<p>消费消息并发服务启动后，会初始化三个组件：<strong>消费线程池</strong>、<strong>清理过期消息定时任务</strong>、<strong>处理失败消息定时任务</strong>。</p>
<figure><img src="https://www.javayong.cn/pics/temp//7ZT6DQW1K1.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>核心流程如下：</p>
<p><strong>0、通讯框架回调线程会将数据存储在消费快照里，然后将消息列表 msgList 提交到消费消息服务</strong></p>
<p><strong>1、 消息列表 msgList 组装成消费对象</strong></p>
<p><strong>2、将消费对象提交到消费线程池</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//B1tBLvh3fV.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>我们看到10 条消息被组装成三个消费请求对象，不同的消费线程会执行不同的消费请求对象。</p>
<p><strong>3、消费线程执行消息监听器</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//CK2wsCfJg3.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>执行完消费监听器，会返回消费结果。</p>
<figure><img src="https://www.javayong.cn/pics/temp//m2OC0khwGU.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>4、处理异常消息</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//V4g5vXlLc7.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>当消费异常时，异常消息将重新发回 Broker 端的重试队列（ RocketMQ 会为每个 topic 创建一个重试队列，以 %RETRY% 开头），达到重试时间后将消息投递到重试队列中进行消费重试。</p>
<blockquote>
<p>我们将在<strong>重试机制</strong>这一节重点讲解 RocketMQ 如何实现延迟消费功能 。</p>
</blockquote>
<p>假如异常的消息发送到 Broker 端失败，则重新将这些失败消息通过<strong>处理失败消息定时任务</strong>重新提交到消息消费服务。</p>
<p><strong>5、更新本地消费进度</strong></p>
<p>消费者消费一批消息完成之后，需要保存消费进度到进度管理器的本地内存。</p>
<figure><img src="https://www.javayong.cn/pics/temp//4UWT3ECS5W.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>首先我们会从队列消费快照 processQueue 中移除消息，返回消费快照 msgTreeMap 第一个偏移量 ，然后调用消费消息进度管理器 offsetStore 更新消费进度。</p>
<p><strong>待更新的偏移量</strong>是如何计算的呢？</p>
<figure><img src="https://www.javayong.cn/pics/temp//Br4RznOnaN.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<ul>
<li>
<p>场景1：快照中1001（消息1）到1010（消息10）消费了，快照中没有了消息，返回已消费的消息最大偏移量 + 1 也就是1011。</p>
<figure><img src="https://www.javayong.cn/pics/temp//5Nhp8CddxY.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
</li>
<li>
<p>场景2：快照中1001（消息1）到1008（消息8）消费了，快照中只剩下两条消息了，返回最小的偏移量 1009。</p>
</li>
</ul>
<figure><img src="https://www.javayong.cn/pics/temp//kdKZew4JsR.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<ul>
<li>场景3：1001（消息1）在消费对象中因为某种原因一直没有被消费，即使后面的消息1005-1010都消费完成了，返回的最小偏移量是1001。</li>
</ul>
<figure><img src="https://www.javayong.cn/pics/temp//1N0EP94TWG.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>在场景3，RocketMQ 为了保证消息肯定被消费成功，消费进度只能维持在1001（消息1），直到1001也被消费完，本地的消费进度才会一下子更新到1011。</p>
<p>假设1001（消息1）还没有消费完成，消费者实例<strong>突然退出（机器断电，或者被 kill ）</strong>，就存在重复消费的风险。</p>
<p>因为队列的消费进度还是维持在1001，当队列重新被分配给新的消费者实例的时候，新的实例从 Broker 上拿到的消费进度还是维持在1001，这时候就会又从1001开始消费，1001-1010这批消息实际上已经被消费过还是会投递一次。</p>
<p>所以<strong>业务必须要保证消息消费的幂等性</strong>。</p>
<p>写到这里，我们会有一个疑问：<strong>假设1001（消息1）因为加锁或者消费监听器逻辑非常耗时，导致极长时间没有消费完成，那么消费进度就会一直卡住 ，怎么解决呢 ？</strong></p>
<p>RocketMQ 提供两种方式一起配合解决：</p>
<ul>
<li>
<p><strong>拉取服务根据并发消费间隔配置限流</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//1h0U1AjiN1.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>拉取消息服务在拉取消息时候，会判断当前队列的 processQueue 消费快照里消息的最大偏移量 - 消息的最小偏移量大于消费并发间隔（2000）的时候 , 就会触发流控 , 这样就可以避免消费者无限循环的拉取新的消息。</p>
</li>
<li>
<p><strong>清理过期消息</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//MvanDXLXjS.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费消息并发服务启动后，会定期扫描所有消费的消息，若当前时间减去开始消费的时间大于消费超时时间，首先会将过期消息发送 sendMessageBack 命令发送到 Broker ，然后从快照中删除该消息。</p>
</li>
</ul>
<h3> 6.2 顺序消费</h3>
<p>顺序消息是指对于一个指定的 Topic ，消息严格按照先进先出（FIFO）的原则进行消息发布和消费，即先发布的消息先消费，后发布的消息后消费。</p>
<p>顺序消息分为<strong>分区顺序消息</strong>和<strong>全局顺序消息</strong>。</p>
<p><strong>1、分区顺序消息</strong></p>
<p>对于指定的一个 Topic ，所有消息根据 Sharding Key 进行区块分区，同一个分区内的消息按照严格的先进先出（FIFO）原则进行发布和消费。同一分区内的消息保证顺序，不同分区之间的消息顺序不做要求。</p>
<ul>
<li>
<p>适用场景：适用于性能要求高，以 Sharding Key 作为分区字段，在同一个区块中严格地按照先进先出（FIFO）原则进行消息发布和消费的场景。</p>
</li>
<li>
<p>示例：电商的订单创建，以订单 ID 作为 Sharding Key ，那么同一个订单相关的创建订单消息、订单支付消息、订单退款消息、订单物流消息都会按照发布的先后顺序来消费。</p>
</li>
</ul>
<p><strong>2、全局顺序消息</strong></p>
<p>对于指定的一个 Topic ，所有消息按照严格的先入先出（FIFO）的顺序来发布和消费。</p>
<ul>
<li>
<p>适用场景：适用于性能要求不高，所有的消息严格按照 FIFO 原则来发布和消费的场景。</p>
</li>
<li>
<p>示例：在证券处理中，以人民币兑换美元为 Topic，在价格相同的情况下，先出价者优先处理，则可以按照 FIFO 的方式发布和消费全局顺序消息。</p>
</li>
</ul>
<blockquote>
<p>全局顺序消息实际上是一种特殊的分区顺序消息，即 Topic 中只有一个分区，因此<strong>全局顺序和分区顺序的实现原理相同</strong>。</p>
<p>因为分区顺序消息有多个分区，所以<strong>分区顺序消息比全局顺序消息的并发度和性能更高</strong>。</p>
</blockquote>
<figure><img src="https://www.javayong.cn/pics/temp//wsNXq03SCB.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消息的顺序需要由两个阶段保证：</p>
<ul>
<li>
<p><strong>消息发送</strong></p>
<p>如上图所示，A1、B1、A2、A3、B2、B3 是订单 A 和订单 B 的消息产生的顺序，业务上要求同一订单的消息保持顺序，例如订单 A 的消息发送和消费都按照 A1、A2、A3 的顺序。</p>
<p>如果是普通消息，订单A 的消息可能会被轮询发送到不同的队列中，不同队列的消息将无法保持顺序，而顺序消息发送时 RocketMQ 支持将 Sharding Key 相同（例如同一订单号）的消息序路由到同一个队列中。</p>
<p>下图是生产者发送顺序消息的封装，原理是发送消息时，实现 MessageQueueSelector 接口， <strong>根据 Sharding Key 使用 Hash 取模法来</strong>选择待发送的队列。</p>
<figure><img src="https://www.javayong.cn/pics/temp//zmZRavOqOB.webp!large" alt="生产者顺序发送消息封装" tabindex="0"><figcaption>生产者顺序发送消息封装</figcaption></figure>
</li>
<li>
<p><strong>消息消费</strong></p>
<p>消费者消费消息时，需要保证<strong>单线程</strong>消费每个队列的消息数据，从而实现消费顺序和发布顺序的一致。</p>
</li>
</ul>
<p>顺序消费服务的类是 <strong>ConsumeMessageOrderlyService</strong> ，在负载均衡阶段，并发消费和顺序消费并没有什么大的差别。</p>
<p>最大的差别在于：<strong>顺序消费会向 Borker 申请锁</strong> 。消费者根据分配的队列 messageQueue ，向 Borker 申请锁 ，如果申请成功，则会拉取消息，如果失败，则定时任务每隔20秒会重新尝试。</p>
<figure><img src="https://www.javayong.cn/pics/temp//RYjgvNzqYU.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>顺序消费核心流程如下：</p>
<p><strong>1、 组装成消费对象</strong></p>
<p><strong>2、 将请求对象提交到消费线程池</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//L0Fg8TEUfu.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>和并发消费不同的是，这里的消费请求包含消费快照 processQueue ，消息队列 messageQueue 两个对象，并不对消息列表做任何处理。</p>
<p><strong>3、 消费线程内，对消费队列加锁</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//BSgV66dvT9.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>顺序消费也是通过线程池消费的，synchronized 锁用来保证同一时刻对于同一个队列只有一个线程去消费它</strong></p>
<p><strong>4、 从消费快照中取得待消费的消息列表</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//fw62aVv3ei.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费快照 processQueue 对象里，创建了一个红黑树对象 consumingMsgOrderlyTreeMap 用于临时存储的待消费的消息。</p>
<p><strong>5、 执行消息监听器</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//htlZQC5Egi.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费快照的<strong>消费锁 consumeLock</strong> 的作用是：防止负载均衡线程把当前消费的 MessageQueue 对象移除掉。</p>
<p><strong>6、 处理消费结果</strong></p>
<p>消费成功时，首先计算需要提交的偏移量，然后更新本地消费进度。</p>
<figure><img src="https://www.javayong.cn/pics/temp//05kFcsIfVN.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费失败时，分两种场景：</p>
<ul>
<li>
<p>假如已消费次数小于最大重试次数，则将对象 consumingMsgOrderlyTreeMap 中临时存储待消费的消息，重新加入到消费快照<strong>红黑树 msgTreeMap</strong> 中，然后使用定时任务尝试重新消费。</p>
</li>
<li>
<p>假如已消费次数大于等于最大重试次数，则将失败消息发送到 Broker ，Broker 接收到消息后，会加入到死信队列里 , 最后计算需要提交的偏移量，然后更新本地消费进度。</p>
</li>
</ul>
<p>我们做一个关于顺序消费的总结 ：</p>
<ol>
<li>
<p>顺序消费需要由两个阶段<strong>消息发送</strong>和<strong>消息消费</strong>协同配合，底层支撑依靠的是 RocketMQ 的存储模型；</p>
</li>
<li>
<p>顺序消费服务启动后，队列的数据都会被消费者实例单线程的执行消费；</p>
</li>
<li>
<p>假如消费者扩容，消费者重启，或者 Broker 宕机 ，顺序消费也会有一定几率较短时间内乱序，所以消费者的业务逻辑还是要<strong>保障幂等</strong>。</p>
</li>
</ol>
<h2> 7 保存进度</h2>
<p>RocketMQ 消费者消费完一批数据后， 会将队列的进度保存在本地内存，但还需要将队列的消费进度持久化。</p>
<p><strong>1、 集群模式</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//lIlhh7LCc4.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>集群模式下，分两种场景：</p>
<ul>
<li>
<p>拉取消息服务会在拉取消息时，携带该队列的消费进度，提交给 Broker 的<strong>拉取消息处理器</strong>。</p>
</li>
<li>
<p>消费者定时任务，每隔5秒将本地缓存中的消费进度提交到 Broker 的<strong>消费者管理处理器</strong>。</p>
</li>
</ul>
<p>Broker 的这两个处理器都调用消费者进度管理器 consumerOffsetManager 的 commitOffset 方法，定时任务异步将消费进度持久化到消费进度文件 consumerOffset.json 中。</p>
<figure><img src="https://www.javayong.cn/pics/temp//jpfI145dyQ.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>2、 广播模式</strong></p>
<p>广播模式消费进度存储在消费者本地，定时任务每隔 5 秒通过 LocalFileOffsetStore 持久化到本地文件<code>offsets.json</code> ，数据格式为 <code>MessageQueue:Offset</code>。</p>
<figure><img src="https://www.javayong.cn/pics/temp//VDuc9BZwz3.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>广播模式下，消费进度和消费组没有关系，本地文件 <code>offsets.json</code> 存储在配置的目录，文件中包含订阅主题中所有的队列以及队列的消费进度。</p>
<h2> 8 重试机制</h2>
<p>集群消费下，<strong>重试机制</strong>的本质是 RocketMQ 的延迟消息功能。</p>
<p>消费消息失败后，消费者实例会通过 <strong>CONSUMER_SEND_MSG_BACK</strong> 请求，将失败消息发回到 Broker 端。</p>
<p>Broker 端会为每个 topic 创建一个<strong>重试队列</strong> ，队列名称是：%RETRY% + 消费者组名 ，达到重试时间后将消息投递到重试队列中进行消费重试（消费者组会自动订阅重试 Topic）。最多重试消费 16 次，重试的时间间隔逐渐变长，若达到最大重试次数后消息还没有成功被消费，则消息将被投递至死信队列。</p>
<table>
<thead>
<tr>
<th>第几次重试</th>
<th>与上次重试的间隔时间</th>
<th>第几次重试</th>
<th>与上次重试的间隔时间</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>10 秒</td>
<td>9</td>
<td>7 分钟</td>
</tr>
<tr>
<td>2</td>
<td>30 秒</td>
<td>10</td>
<td>8 分钟</td>
</tr>
<tr>
<td>3</td>
<td>1 分钟</td>
<td>11</td>
<td>9 分钟</td>
</tr>
<tr>
<td>4</td>
<td>2 分钟</td>
<td>12</td>
<td>10 分钟</td>
</tr>
<tr>
<td>5</td>
<td>3 分钟</td>
<td>13</td>
<td>20 分钟</td>
</tr>
<tr>
<td>6</td>
<td>4 分钟</td>
<td>14</td>
<td>30 分钟</td>
</tr>
<tr>
<td>7</td>
<td>5 分钟</td>
<td>15</td>
<td>1 小时</td>
</tr>
<tr>
<td>8</td>
<td>6 分钟</td>
<td>16</td>
<td>2 小时</td>
</tr>
</tbody>
</table>
<figure><img src="https://www.javayong.cn/pics/temp//a4AW6Gxhxm.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>开源 RocketMQ 4.X 支持延迟消息，默认支持18 个 level 的延迟消息，这是通过 broker 端的 messageDelayLevel 配置项确定的，如下：</p>
<figure><img src="https://www.javayong.cn/pics/temp//JcmLurnXsq.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Broker 在启动时，内部会创建一个内部主题：SCHEDULE_TOPIC_XXXX，根据延迟 level 的个数，创建对应数量的队列，也就是说18个 level 对应了18个队列。</p>
<p>我们先梳理下延迟消息的实现机制。</p>
<p><strong>1、生产者发送延迟消息</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、Broker端存储延迟消息</strong></p>
<p>延迟消息在 RocketMQ Broker 端的流转如下图所示：</p>
<figure><img src="https://www.javayong.cn/pics/temp//JLBtkWlUdG.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>第一步：修改消息 Topic 名称和队列信息</strong></p>
<p>Broker 端接收到生产者的写入消息请求后，首先都会将消息写到 commitlog 中。假如是正常非延迟消息，MessageStore 会根据消息中的 Topic 信息和队列信息，将其转发到目标 Topic 的指定队列 consumequeue 中。</p>
<p>但由于消息一旦存储到 consumequeue 中，消费者就能消费到，而延迟消息不能被立即消费，所以 RocketMQ 将 Topic 的名称修改为SCHEDULE_TOPIC_XXXX，并根据延迟级别确定要投递到哪个队列下。</p>
<p>同时，还会将消息原来要发送到的目标 Topic 和队列信息存储到消息的属性中。</p>
<figure><img src="https://www.javayong.cn/pics/temp//s4kZohhZun.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>第二步：构建 consumequeue 文件时，计算并存储投递时间</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//LgKhMaqAvc.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://www.javayong.cn/pics/temp//NfFXmlG1DS.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>上图是 consumequeue 文件一条消息的格式，最后 8 个字节存储 Tag 的哈希值，此时存储消息的投递时间。</p>
<p><strong>第三步：定时调度服务启动</strong></p>
<p>ScheduleMessageService 类是一个定时调度服务，读取 SCHEDULE_TOPIC_XXXX 队列的消息，并将消息投递到目标 Topic 中。</p>
<p>定时调度服务启动时，创建一个定时调度线程池 ，并根据延迟级别的个数，启动对应数量的 HandlePutResultTask ，每个 HandlePutResultTask 负责一个延迟级别的消费与投递。</p>
<figure><img src="https://www.javayong.cn/pics/temp//ywsgDHPRc2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>第四步：投递时间到了，将消息数据重新写入到 commitlog</strong></p>
<p>消息到期后，需要投递到目标 Topic 。第一步已经记录了原来的 Topic 和队列信息，这里需要重新设置，再存储到 commitlog 中。</p>
<p><strong>第五步：将消息投递到目标 Topic 中</strong></p>
<p>Broker 端的后台服务线程会不停地分发请求并异步构建 consumequeue（消费文件）和 indexfile（索引文件）。因此消息会直接投递到目标 Topic 的 consumequeue 中，之后消费者就可以消费到这条消息。</p>
<hr>
<p>回顾了延迟消息的机制，消费消息失败后，消费者实例会通过 <strong>CONSUMER_SEND_MSG_BACK</strong> 请求，将失败消息发回到 Broker 端。</p>
<p>Broker 端 SendMessageProcessor 处理器会调用 asyncConsumerSendMsgBack 方法。</p>
<figure><img src="https://www.javayong.cn/pics/temp//zdjbfFwN0S.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>首先判断消息的当前重试次数是否大于等于最大重试次数，如果达到最大重试次数，或者配置的重试级别小于0，则重新创建 Topic ，规则是 <strong>%DLQ% + consumerGroup</strong>，后续处理消息发送到死信队列。</p>
<p>正常的消息会进入 else 分支，对于首次重试的消息，默认的 delayLevel 是 0 ，RocketMQ 会将 delayLevel + 3，也就是加到 3 ，这就是说，如果没有显示的配置延时级别，消息消费重试首次，是延迟了第三个级别发起的重试，也就是距离首次发送 10s 后重试，其主题的默认规则是 <strong>%RETRY% + consumerGroup</strong>。</p>
<p>当延时级别设置完成，刷新消息的重试次数为当前次数加 1 ，Broker 端将该消息刷盘，逻辑如下：</p>
<figure><img src="https://www.javayong.cn/pics/temp//E3CYBrG5AY.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>延迟消息写入到 commitlog 里 ，这里其实和延迟消息机制的第一步类似，后面按照延迟消息机制的流程执行即可（第二步到第六步）。</p>
<h2> 9 总结</h2>
<p>下图展示了集群模式下消费者并发消费流程 ：</p>
<figure><img src="https://www.javayong.cn/pics/temp//ASwgqxnuB7.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>核心流程如下：</p>
<ol>
<li>
<p>消费者启动后，触发负载均衡服务 ，负载均衡服务为消费者实例分配对应的队列 ；</p>
</li>
<li>
<p>分配完队列后，负载均衡服务会为每个分配的新队列创建一个消息拉取请求 <code>pullRequest</code> , 拉取请求保存一个处理队列 <code>processQueue</code>，内部是红黑树（<code>TreeMap</code>），用来保存拉取到的消息 ；</p>
</li>
<li>
<p>拉取消息服务单线程从拉取请求队列 <code>pullRequestQueue</code> 中弹出拉取消息，执行拉取任务 ，拉取请求是异步回调模式，将拉取到的消息放入到处理队列；</p>
</li>
<li>
<p>拉取请求在一次拉取消息完成之后会复用，重新被放入拉取请求队列 <code>pullRequestQueue</code> 中 ；</p>
</li>
<li>
<p>拉取完成后，调用消费消息服务 <code>consumeMessageService</code> 的 <code>submitConsumeRequest</code> 方法 ，消费消息服务内部有一个消费线程池；</p>
</li>
<li>
<p>消费线程池的消费线程从消费任务队列中获取消费请求，执行消费监听器 <code>listener.consumeMessage</code> ；</p>
</li>
<li>
<p>消费完成后，若消费成功，则更新偏移量 <code>updateOffset</code>，先更新到内存 <code>offsetTable</code>，定时上报到 Broker ；若消费失败，则将失败消费发送到 Broker 。</p>
</li>
<li>
<p>Broker 端接收到请求后， 调用消费进度管理器的 <code>commitOffset</code> 方法修改内存的消费进度，定时刷盘到 <code>consumerOffset.json</code>。</p>
</li>
</ol>
<p>RocketMQ 4.9.X 的消费逻辑有两个非常明显的特点：</p>
<ol>
<li>
<p><strong>客户端代码逻辑较重</strong>。假如要支持一种新的编程语言，那么客户端就必须实现完整的负载均衡逻辑，此外还需要实现拉消息、位点管理、消费失败后将消息发回 Broker 重试等逻辑。这给多语言客户端的支持造成很大的阻碍。</p>
</li>
<li>
<p><strong>保证幂等非常重要</strong>。当客户端升级或者下线时，或者 Broker 宕机，都要进行负载均衡操作，可能造成消息堆积，同时有一定几率造成重复消费。</p>
</li>
</ol>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 广播消费</title>
    <id>https://javayong.cn/mq/rocketmq4/07RocketMQ4_broadcast_consumer.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/07RocketMQ4_broadcast_consumer.html"/>
    <updated>2023-11-16T07:55:06.000Z</updated>
    <summary type="html"><![CDATA[<p>这篇文章我们聊聊广播消费，因为广播消费在某些场景下真的有奇效。笔者会从<strong>基础概念</strong>、<strong>实现机制</strong>、<strong>实战案例</strong>三个方面一一展开，希望能帮助到大家。</p>
<h1> 1 基础概念</h1>
<p>RocketMQ 支持两种消息模式：<code>集群消费</code>（ Clustering ）和<code>广播消费</code>（ Broadcasting ）。</p>
<p><strong>集群消费</strong>：</p>
<p>同一 Topic 下的一条消息只会被同一消费组中的一个消费者消费。也就是说，消息被负载均衡到了同一个消费组的多个消费者实例上。</p>]]></summary>
    <content type="html"><![CDATA[<p>这篇文章我们聊聊广播消费，因为广播消费在某些场景下真的有奇效。笔者会从<strong>基础概念</strong>、<strong>实现机制</strong>、<strong>实战案例</strong>三个方面一一展开，希望能帮助到大家。</p>
<h1> 1 基础概念</h1>
<p>RocketMQ 支持两种消息模式：<code>集群消费</code>（ Clustering ）和<code>广播消费</code>（ Broadcasting ）。</p>
<p><strong>集群消费</strong>：</p>
<p>同一 Topic 下的一条消息只会被同一消费组中的一个消费者消费。也就是说，消息被负载均衡到了同一个消费组的多个消费者实例上。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/cluster.png?a=1" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>广播消费</strong>：</p>
<p>当使用广播消费模式时，每条消息推送给集群内所有的消费者，保证消息至少被每个消费者消费一次。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/broadcast.png?b=3" alt="" tabindex="0"><figcaption></figcaption></figure>
<h1> 2 源码解析</h1>
<p>首先下图展示了广播消费的代码示例。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>和集群消费不同的点在于下面的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，我们从源码角度来看看广播消费和集群消费有哪些差异点 ？</p>
<p>首先进入 <code>DefaultMQPushConsumerImpl</code> 类的 <code>start</code> 方法 , 分析启动流程中他们两者的差异点：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/pushconsumerstart.png?a=341" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>▍ 差异点1：拷贝订阅关系</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在集群模式下，会自动订阅重试队列，而广播模式下，并没有这段代码。也就是说<strong>广播模式下，不支持消息重试</strong>。</p>
<p><strong>▍ 差异点2：本地进度存储</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到消费进度存储的对象是： <code>LocalFileOffsetStore</code> , 进度文件存储在如下的主目录<code> /{用户主目录}/.rocketmq_offsets</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进度文件是 <code>/mqClientId/{consumerGroupName}/offsets.json</code> 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>笔者创建了一个主题 <code>mytest</code> , 包含4个队列，进度文件内容如下：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/broadcastoffset.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费者启动后，我们可以将整个流程简化如下图，并继续整理差异点：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/consumerbroadcastliucheng.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>▍ 差异点3：负载均衡消费该主题的所有 MessageQueue</strong></p>
<p>进入负载均衡抽象类 <code>RebalanceImpl</code> 的<code>rebalanceByTopic</code>方法 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面代码我们可以看到消息模式为广播消费模式时，消费者会消费该主题下所有的队列，这一点也可以从本地的进度文件 <code>offsets.json</code> 得到印证。</p>
<p><strong>▍ 差异点4：不支持顺序消息</strong></p>
<p>我们知道<strong>消费消息顺序服务会向 Borker 申请锁</strong> 。消费者根据分配的队列 messageQueue ，向 Borker 申请锁 ，如果申请成功，则会拉取消息，如果失败，则定时任务每隔 20 秒会重新尝试。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是从上面的代码，我们发现只有在集群消费的时候才会定时申请锁，这样就会导致广播消费时，无法为负载均衡的队列申请锁，导致拉取消息服务一直无法获取消息数据。</p>
<p>笔者修改消费例子，在消息模式为广播模式的场景下，将消费模式从并发消费修改为顺序消费。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://javayong.cn/pics/rocketmq/broadcastcantorder.gif" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>通过 IDEA DEBUG 图，笔者观察到因为负载均衡后的队列无法获取到锁，所以拉取消息的线程无法发起拉取消息请求到 Broker , 也就不会走到消费消息的流程。</p>
<p>因此，<strong>广播消费模式并不支持顺序消息</strong>。</p>
<p><strong>▍ 差异点5：并发消费消费失败时，没有重试</strong></p>
<p>进入并发消息消费类<code>ConsumeMessageConcurrentlyService</code> 的处理消费结果方法 <code>processConsumeResult</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费消息失败后，集群消费时，消费者实例会通过 <strong>CONSUMER_SEND_MSG_BACK</strong> 请求，将失败消息发回到 Broker 端。</p>
<p>但在广播模式下，仅仅是打印了消息信息。因此，<strong>广播模式下，并没有消息重试</strong>。</p>
<h1> 3 实战案例</h1>
<p>广播消费主要用于两种场景：<strong>消息推送</strong>和<strong>缓存同步</strong>。</p>
<h2> 3.1 消息推送</h2>
<p>笔者第一次接触广播消费的业务场景是神州专车司机端的消息推送。</p>
<p>用户下单之后，订单系统生成专车订单，派单系统会根据相关算法将订单派给某司机，司机端就会收到派单推送。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/drivercarpush.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>推送服务是一个 TCP 服务（自定义协议），同时也是一个消费者服务，消息模式是广播消费。</p>
<p>司机打开司机端 APP 后，APP 会通过负载均衡和推送服务创建长连接，推送服务会保存 TCP 连接引用 （比如司机编号和 TCP channel 的引用）。</p>
<p>派单服务是生产者，将派单数据发送到 MetaQ ,  每个推送服务都会消费到该消息，推送服务判断本地内存中是否存在该司机的 TCP channel ， 若存在，则通过 TCP 连接将数据推送给司机端。</p>
<p>肯定有同学会问：假如网络原因，推送失败怎么处理 ？有两个要点：</p>
<ol>
<li>
<p>司机端 APP 定时主动拉取派单信息；</p>
</li>
<li>
<p>当推送服务没有收到司机端的 ACK 时 ，也会一定时限内再次推送，达到阈值后，不再推送。</p>
</li>
</ol>
<h2> 3.2 缓存同步</h2>
<p>高并发场景下，很多应用使用本地缓存，提升系统性能 。</p>
<p>本地缓存可以是 HashMap 、ConcurrentHashMap ，也可以是缓存框架 Guava Cache 或者 Caffeine cache 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/broadcastcachepush.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>如上图，应用A启动后，作为一个 RocketMQ 消费者，消息模式设置为广播消费。为了提升接口性能，每个应用节点都会将字典表加载到本地缓存里。</p>
<p>当字典表数据变更时，可以通过业务系统发送一条消息到 RocketMQ ，每个应用节点都会消费消息，刷新本地缓存。</p>
<h1> 4 总结</h1>
<p>集群消费和广播消费模式下，各功能的支持情况如下：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>集群消费</th>
<th>广播消费</th>
</tr>
</thead>
<tbody>
<tr>
<td>顺序消息</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>重置消费位点</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>消息重试</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>消费进度</td>
<td>服务端维护</td>
<td>客户端维护</td>
</tr>
</tbody>
</table>
<br>
<p>广播消费主要用于两种场景：<strong>消息推送</strong>和<strong>缓存同步</strong>。</p>
<hr>
<p>参考资料 ：</p>
<blockquote>
<p>https://www.51cto.com/article/714277.html</p>
<p>https://ost.51cto.com/posts/21100</p>
</blockquote>
<hr>
<p>如果我的文章对你有所帮助，还请帮忙<strong>点赞、在看、转发</strong>一下，你的支持会激励我输出更高质量的文章，非常感谢！</p>
<figure><img src="https://javayong.cn/pics/zhihu/gongzhonghao.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 主从同步</title>
    <id>https://javayong.cn/mq/rocketmq4/08RocketMQ4_masterslave.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/08RocketMQ4_masterslave.html"/>
    <updated>2023-11-17T08:13:01.000Z</updated>
    <summary type="html"><![CDATA[<p>RocketMQ 主从复制是 RocketMQ 高可用机制之一，数据可以从主节点复制到一个或多个从节点。</p>
<p>这篇文章，我们聊聊 RocketMQ 的主从复制，希望大家读完之后，能够理解主从复制的精髓。</p>
<figure><img src="https://www.javayong.cn/pics/temp//NlcPeBacCl.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 同步与异步</h2>
<p>在 RocketMQ 的集群模式中，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master。</p>]]></summary>
    <content type="html"><![CDATA[<p>RocketMQ 主从复制是 RocketMQ 高可用机制之一，数据可以从主节点复制到一个或多个从节点。</p>
<p>这篇文章，我们聊聊 RocketMQ 的主从复制，希望大家读完之后，能够理解主从复制的精髓。</p>
<figure><img src="https://www.javayong.cn/pics/temp//NlcPeBacCl.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 同步与异步</h2>
<p>在 RocketMQ 的集群模式中，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master。</p>
<p>每个 Broker 与 Name Server 集群中的所有节点建立长连接，定时注册 Topic 信息到所有 Name Server。</p>
<figure><img src="https://www.javayong.cn/pics/temp//XYRrSnhfuT-20231117160830289.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Master 节点负责接收客户端的写入请求，并将消息持久化到磁盘上。而 Slave 节点则负责从 Master 节点复制消息数据，并保持与 Master 节点的同步。</p>
<p><strong>1、同步复制</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//9OihpRQCeY.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>每个 Master 配置一个 Slave ，有多对 Master-Slave ，HA 采用同步双写方式，即只有主备都写成功，才向应用返回成功。</p>
<p>这种模式的优缺点如下：</p>
<ul>
<li>
<p>优点：数据与服务都无单点故障，Master宕机情况下，消息无延迟，服务可用性与数据可用性都非常高；</p>
</li>
<li>
<p>缺点：性能比异步复制模式略低（大约低10%左右），发送单个消息的 RT 会略高，且目前版本在主节点宕机后，备机不能自动切换为主机。</p>
</li>
</ul>
<p><strong>2、异步复制</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//aeuWWwwVF6.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>每个 Master 配置一个 Slave ，有多对 Master-Slave ，HA 采用异步复制方式，主备有短暂消息延迟（毫秒级），这种模式的优缺点如下：</p>
<ul>
<li>
<p>优点：即使磁盘损坏，消息丢失的非常少，且消息实时性不会受影响，同时Master宕机后，消费者仍然可以从Slave消费，而且此过程对应用透明，不需要人工干预，性能同多 Master 模式几乎一样；</p>
</li>
<li>
<p>缺点：Master 宕机，磁盘损坏情况下会丢失少量消息 。</p>
</li>
</ul>
<p>复制流程分为两个部分：<strong>元数据复制</strong>和<strong>消息数据复制</strong>。</p>
<ul>
<li>主从服务器同步主题，消费者进度，延迟消费进度，消费者配置数据</li>
<li>主从服务器同步消息数据</li>
</ul>
<h2> 2 元数据复制</h2>
<p>Slave Broker 定时任务每隔 10 秒会同步元数据，包括<strong>主题</strong>，<strong>消费进度</strong>，<strong>延迟消费进度</strong>，<strong>消费者配置</strong>。</p>
<figure><img src="https://www.javayong.cn/pics/temp//UlZOjOQHKC.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>同步主题时, Slave Broker 向 Master Broker 发送 RPC 请求，返回数据后，首先加入本地缓存里，然后持久化到本地。</p>
<figure><img src="https://www.javayong.cn/pics/temp//同步rpc.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 3 消息数据复制</h2>
<p>下图是 Master 和 Slave 消息数据同步的流程图。</p>
<figure><img src="https://www.javayong.cn/pics/temp//消息数据复制.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>1、Master 启动后监听指定端口；</strong></p>
<p>Master 启动后创建 AcceptSocketService 服务  ,  用来创建客户端到服务端的 TCP 链接。</p>
<figure><img src="https://www.javayong.cn/pics/temp//master监听端口.webp" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>RocketMQ 抽象了链接对象 HAConnection , HAConnection 会启动两个线程，分别用于读服务和写服务：</p>
<ul>
<li>读服务：处理 Slave 发送的请求</li>
<li>写服务：用于向 Slave 传输数据</li>
</ul>
<figure><img src="https://www.javayong.cn/pics/temp//L9VeTg1Q1b.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>2、Slave 启动后，尝试连接 Master ，建立 TCP 连接；</strong></p>
<p>HAClient 是客户端 Slave 的核心类 ，负责和 Master 创建连接和数据交互。</p>
<figure><img src="https://www.javayong.cn/pics/temp//FdlRK75VMA.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>客户端在启动后，首先尝试连接 Master , 查询当前消息存储中最大的物理偏移量 ，并存储在变量 currentReportedOffset 里。</p>
<p><strong>3、Slave 向 Master 汇报拉取消息偏移量；</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//tT8zDrnRDf.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>上报进度的数据格式是一个 Long 类型的 Offset ,  8个字节 ,  非常简洁 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//jTVTgyPKmh.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>发送到 Socket 缓冲区后 ,  修改最后一次的写时间 lastWriteTimestamp 。</p>
<p><strong>4、Master 解析请求偏移量，从消息文件中检索该偏移量后的所有消息；</strong></p>
<p>当 Slave 上报数据到 Master 时，<strong>触发 SelectionKey.OP_READ 事件</strong>，Master 将请求交由 ReadSocketService 服务处理：</p>
<figure><img src="https://www.javayong.cn/pics/temp//Q1VaKEvY5a.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>当 Slave Broker 传递了自身 commitlog 的 maxPhyOffset 时，Master 会马上中断 <code>selector.select(1000) </code>，执行 <code>processReadEvent</code> 方法。</p>
<figure><img src="https://www.javayong.cn/pics/temp//p6dZ2wKxCi.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>processReadEvent 方法的核心逻辑是设置 Slave 的当前进度 offset ，然后通知复制线程当前的复制进度。</p>
<p>写服务 WriteSocketService 从消息文件中检索该偏移量后的所有消息（传输批次数据大小限制），并将消息数据发送给 Slave。</p>
<figure><img src="https://www.javayong.cn/pics/temp//V6JxwPbZYw.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong>5、Slave 接收到数据，将消息数据 append 到消息文件 commitlog 里 。</strong></p>
<figure><img src="https://www.javayong.cn/pics/temp//zSWojrUdMO.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>首先 HAClient 类中调用 dispatchReadRequest 方法 ， 解析出消息数据 ；</p>
<figure><img src="https://www.javayong.cn/pics/temp//hso6cZvs8w.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>然后将消息数据 append 到本地的消息存储。</p>
<figure><img src="https://www.javayong.cn/pics/temp//Lp9XW6snxn.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 4 同步的实现</h2>
<p>从数据复制流程图，我们发觉数据复制本身就是一个异步执行的，但是同步是如何实现的呢？</p>
<p>Master Broker 接收到写入消息的请求后 ，调用 Commitlog 的 aysncPutMessage 方法写入消息。</p>
<figure><img src="https://www.javayong.cn/pics/temp//sBPU66GFD1.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>这段代码中，当 commitLog 执行完 appendMessage 后， 需要执行<strong>刷盘任务</strong>和<strong>同步复制</strong>两个任务。</p>
<p>但这两个任务并不是同步执行，而是异步的方式，<strong>使用了 CompletableFuture 这个异步神器</strong>。</p>
<p>当 HAConnection 读服务接收到 Slave 的进度反馈，发现消息数据复制成功，则唤醒 future 。</p>
<figure><img src="https://www.javayong.cn/pics/temp//uATvF8ZCew.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>最后 Broker 组装响应命令 ，并将响应命令返回给客户端。</p>
<h2> 5 总结</h2>
<p>RocketMQ 主从复制的实现思路非常简单，Slave 启动一个线程，不断从 Master 拉取 Commit Log 中的数据，然后在异步 build 出 Consume Queue 数据结构。</p>
<p>核心要点如下：</p>
<p><strong>1、主从复制包含元数据复制和消息数据复制两个部分；</strong></p>
<p><strong>2、元数据复制</strong></p>
<p>​	  Slave Broker 定时任务每隔 10 秒向 Master Broker 发送 RPC 请求，将元数据同步到缓存后，然后持久化到磁盘里；</p>
<p><strong>3、消息数据复制</strong></p>
<ol>
<li>
<p>Master 启动监听指定端口</p>
</li>
<li>
<p>Slave  启动 HaClient 服务，和 Master 创建 TCP 链接</p>
</li>
<li>
<p>Slave 向 Master 上报存储进度</p>
</li>
<li>
<p>Master 接收进度，消息文件中检索该偏移量后的所有消息，并传输给 Slave</p>
</li>
<li>
<p>Slave 接收到数据后，将消息数据 append 到本地的消息存储。</p>
</li>
</ol>
<p><strong>4、同步的实现</strong></p>
<p>​	当 commitLog 执行完 appendMessage 后， 需要执行<strong>刷盘任务</strong>和<strong>同步复制</strong>两个任务，这里用到了 CompletableFuture 这个异步神器。
​	当 HAConnection 读服务接收到 Slave 的进度反馈，发现消息数据复制成功，则唤醒 future 。最后 Broker 组装响应命令 ，并将响应命令	返回给客户端 。</p>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 事务原理</title>
    <id>https://javayong.cn/mq/rocketmq4/10RocketMQ4_transaction.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/10RocketMQ4_transaction.html"/>
    <updated>2023-11-16T13:37:25.000Z</updated>
    <summary type="html"><![CDATA[<p>事务消息是 RocketMQ 的高级特性之一，相信很多同学都对于其实现机制很好奇。</p>
<p>这篇文章，笔者会从<strong>应用场景</strong>、<strong>功能原理</strong>、<strong>实战例子</strong>、<strong>实现细节</strong>四个模块慢慢为你揭开事务消息的神秘面纱。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/rocketmqcategory.png" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>事务消息是 RocketMQ 的高级特性之一，相信很多同学都对于其实现机制很好奇。</p>
<p>这篇文章，笔者会从<strong>应用场景</strong>、<strong>功能原理</strong>、<strong>实战例子</strong>、<strong>实现细节</strong>四个模块慢慢为你揭开事务消息的神秘面纱。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/rocketmqcategory.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h2> 1 应用场景</h2>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionchangjing.png?d=14" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>以电商交易场景为例，<strong>用户支付订单</strong>这一核心操作的同时会涉及到下游物流发货、积分变更、购物车状态清空等多个子系统的变更。</p>
<p>当前业务的处理分支包括：</p>
<ul>
<li>主分支订单系统状态更新：由未支付变更为支付成功。</li>
<li>物流系统状态新增：新增待发货物流记录，创建订单物流记录。</li>
<li>积分系统状态变更：变更用户积分，更新用户积分表。</li>
<li>购物车系统状态变更：清空购物车，更新用户购物车记录。</li>
</ul>
<p><strong>1、传统XA事务方案：性能不足</strong></p>
<p>为了保证上述四个分支的执行结果一致性，典型方案是基于 XA 协议的分布式事务系统来实现。将四个调用分支封装成包含四个独立事务分支的大事务。基于 XA 分布式事务的方案可以满足业务处理结果的正确性，但最大的缺点是多分支环境下资源锁定范围大，并发度低，随着下游分支的增加，系统性能会越来越差。</p>
<p><strong>2、基于普通消息方案：一致性保障困难</strong></p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionnormalmessage.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>该方案中消息下游分支和订单系统变更的主分支很容易出现不一致的现象，例如：</p>
<ul>
<li>消息发送成功，订单没有执行成功，需要回滚整个事务。</li>
<li>订单执行成功，消息没有发送成功，需要额外补偿才能发现不一致。</li>
<li>消息发送超时未知，此时无法判断需要回滚订单还是提交订单变更。</li>
</ul>
<p><strong>3、基于 RocketMQ 分布式事务消息：支持最终一致性</strong></p>
<p>上述普通消息方案中，普通消息和订单事务无法保证一致的原因，本质上是由于普通消息无法像单机数据库事务一样，具备提交、回滚和统一协调的能力。</p>
<p>而基于 RocketMQ 实现的分布式事务消息功能，在普通消息基础上，支持二阶段的提交能力。将二阶段提交和本地事务绑定，实现全局提交结果的一致性。</p>
<h2> 2 功能原理</h2>
<p>RocketMQ 事务消息是支持在分布式场景下<strong>保障消息生产和本地事务的最终一致性</strong>。交互流程如下图所示：</p>
<figure><img src="https://www.javayong.cn/pics/rocketmq/transactionyuanli.png?a" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>1、生产者将消息发送至 Broker 。</p>
<p>2、Broker 将消息持久化成功之后，向生产者返回 Ack 确认消息已经发送成功，此时消息被标记为"<strong>暂不能投递</strong>"，这种状态下的消息即为<strong>半事务消息</strong>。</p>
<p>3、生产者开始<strong>执行本地事务逻辑</strong>。</p>
<p>4、生产者根据本地事务执行结果向服务端<strong>提交二次确认结果</strong>（ Commit 或是 Rollback ），Broker 收到确认结果后处理逻辑如下：</p>
<ul>
<li>二次确认结果为 Commit ：Broker 将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为 Rollback ：Broker 将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
<p>5、在断网或者是生产者应用重启的特殊情况下，若 Broker 未收到发送者提交的二次确认结果，或 Broker 收到的二次确认结果为 Unknown 未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起<strong>消息回查</strong>。</p>
<ol>
<li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>生产者根据检查到的本地事务的最终状态<strong>再次提交二次确认</strong>，服务端仍按照步骤4对半事务消息进行处理。</li>
</ol>
<h2> 3 实战例子</h2>
<p>为了便于大家理解事务消息 ，笔者新建一个工程用于模拟<strong>支付订单创建</strong>、<strong>支付成功</strong>、<strong>赠送积分</strong>的流程。</p>
<p>首先，我们创建一个真实的订单主题：<strong>order-topic</strong> 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactiontopic.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>然后在数据库中创建三张表 <strong>订单表</strong>、<strong>事务日志表</strong>、<strong>积分表</strong>。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactiondemotables.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>最后我们创建一个 Demo 工程，生产者模块用于创建支付订单、修改支付订单成功，消费者模块用于新增积分记录。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionprojectdemo.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>接下来，我们展示事务消息的实现流程。</p>
<p><strong style="font-size: 15px;line-height: inherit;color: black;">1、创建支付订单</strong></p>
<p>调用订单生产者服务创建订单接口 ，在 t_order 表中插入一条支付订单记录。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactioncreateorder.png?" alt="" tabindex="0"><figcaption></figcaption></figure>
<p><strong style="font-size: 15px;line-height: inherit;color: black;">2、调用生产者服务修改订单状态接口</strong></p>
<p>接口的逻辑就是执行事务生产者的 <code> sendMessageInTransaction</code>  方法。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionupdatepayordersuccess.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>生产者端需要配置<strong>事务生产者</strong>和<strong>事务监听器</strong>。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionrocketmqconfig.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>发送事务消息的方法内部包含三个步骤 ：</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionupdateorderliucheng.png?a" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>事务生产者首先<strong>发送半事务消息</strong>，发送成功后，生产者才开始<strong>执行本地事务逻辑</strong>。</p>
<p>事务监听器实现了两个功能：<strong>执行本地事务</strong>和<strong>供 Broker 回查事务状态</strong> 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionlistenerimpl.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>执行本地事务的逻辑内部就是执行<code> orderService.updateOrder</code> 方法。</p>
<p>方法执行成功则返回 <code>LocalTransactionState.COMMIT_MESSAGE</code> , 若执行失败则返回 <code> LocalTransactionState.ROLLBACK_MESSAGE</code> 。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionupdateorder.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>需要注意的是：<code> orderService.updateOrder</code> 方法添加了事务注解，并将修改订单状态和插入事务日志表放进一个事务内，避免订单状态和事务日志表的数据不一致。</p>
<p>最后，生产者根据本地事务执行结果向 Broker <strong>提交二次确认结果</strong>。</p>
<p>Broker 收到生产者确认结果后处理逻辑如下：</p>
<ul>
<li>二次确认结果为 Commit ：Broker 将半事务消息标记为可投递，并投递给消费者。</li>
<li>二次确认结果为 Rollback ：Broker 将回滚事务，不会将半事务消息投递给消费者。</li>
</ul>
<p><strong style="font-size: 15px;line-height: inherit;color: black;">3、积分消费者消费消息，添加积分记录</strong></p>
<p>当 Broker 将半事务消息标记为可投递时，积分消费者就可以开始消费主题 order-topic 的消息了。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionconsumerconfig.png?a=1" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>积分消费者服务，我们定义了<strong>消费者组名</strong>，以及<strong>订阅主题</strong>和<strong>消费监听器</strong>。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionconsumerjifen.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>在消费监听器逻辑里，<code>幂等非常重要</code> 。当收到订单信息后，首先判断该订单是否有积分记录，若没有记录，才插入积分记录。</p>
<p>而且我们在创建积分表时，订单编号也是唯一键，数据库中也必然不会存在相同订单的多条积分记录。</p>
<h2> 4 实现细节</h2>
<p><strong style="font-size: 16px;line-height: inherit;color: black;">1、事务 half 消息对用户不可见</strong></p>
<p>下图展示了 RocketMQ 的存储模型，RocketMQ 采用的是混合型的存储结构，Broker 单个实例下所有的队列共用一个日志数据文件（即为 CommitLog ）来存储。</p>
<p>消息数据写入到 commitLog 后，通过分发线程异步构建 ConsumeQueue（逻辑消费队列）和 IndexFile（索引文件）数据。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/rocketmqstoredemo.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Broker 在接受到发送消息请求后，如果消息是 half 消息，先备份原消息的主题与消息消费队列，然后改变主题为 <code>RMQ_SYS_TRANS_HALF_TOPIC</code> 。</p>
<p>而该主题并不被消费者订阅，所以对于消费者是不可见的。</p>
<p>然后 RocketMQ 会开启一个定时任务，从 Topic 为 <code>RMQ_SYS_TRANS_HALF_TOPIC</code> 中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
<blockquote>
<p>改变消息主题是 RocketMQ 的常用“套路”，延时消息的实现机制也是如此。</p>
</blockquote>
<p><strong style="font-size: 16px;line-height: inherit;color: black;">2、Commit 和 Rollback 操作</strong></p>
<p>RocketMQ 事务消息方案中引入了 <strong>Op 消息</strong>的概念，用 Op 消息标识事务消息已经确定的状态（ Commit 或者 Rollback ）, Op 消息对应的主题是： <code>RMQ_SYS_TRANS_OP_HALF_TOPIC</code>  。</p>
<p>如果一条事务消息没有对应的 Op 消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/endtransactionopmessage.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>引入 Op 消息后，事务消息无论是 Commit 或者 Rollback 都会记录一个 Op 操作。</p>
<ul>
<li>
<p><strong>Commit</strong></p>
<p>Broker 写入 OP 消息，OP 消息的 body 指定 Commit 消息的 queueOffset，标记之前 Half 消息已被删除；同时，Broker 读取原 Half 消息，把 Topic 还原，重新写入 CommitLog，消费者则可以拉取消费；</p>
</li>
<li>
<p><strong>Rollback</strong></p>
<p>Broker 同样写入 OP 消息，流程和 Commit 一样。但后续不会读取和还原 Half 消息。这样消费者就不会消费到该消息。</p>
</li>
</ul>
<p><strong style="font-size: 16px;line-height: inherit;color: black;">3、事务消息状态回查</strong></p>
<p>若生产者根据本地事务执行结果向 Broker <strong>提交二次确认结果</strong>时，出现网络问题导致提交失败，那么需要通过一定的策略使这条消息最终被 Commit 或者 Rollback 。</p>
<p>Broker 采用了一种补偿机制，称为“状态回查”。</p>
<p>Broker 端对未确定状态的消息发起回查，将消息发送到对应的 Producer 端（同一个 Group 的 Producer ），由 Producer 根据消息来检查本地事务的状态，进而执行 Commit 或者 Rollback 。</p>
<p>Broker 端通过对比 Half 消息和 Op 消息进行事务消息的回查并且推进 CheckPoint（记录那些事务消息的状态是确定的）。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/transactionbrokerchecklogic.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>事务消息 check 流程扫描当前的 OP 消息队列，读取已经被标记删除的 Half 消息的 queueOffset 。如果发现某个 Half 消息没有 OP 消息对应标记，并且已经超时（ transactionTimeOut 默认 6 秒），则读取该 Half 消息重新写入 half 队列，并且发送 check 命令到原发送方检查事务状态；如果没有超时，则会等待后读取 OP 消息队列，获取新的 OP 消息。</p>
<p>值得注意的是，Broker 并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，Broker 默认回滚该消息。</p>
<h2> 5 总结</h2>
<p>我们理解了事务消息的原理，编写一个实战例子并不复杂。</p>
<p>笔者需要强调的是，事务消息也具备一定的局限性：</p>
<p>1、事务生产者和消费者共同协作才能保证最终一致性；</p>
<p>2、事务生产者需要实现事务监听器，并且保存事务的执行结果（比如事务日志表） ；</p>
<p>3、消费者要保证幂等。消费失败时，通过<strong>重试</strong>、<strong>告警+人工介入</strong>等手段保证消费结果正确。</p>
<p>同时，由于事务消息的机制原因，我们在使用 RocketMQ 事务功能时，也需要注意如下两点：</p>
<p>1、避免大量未决事务导致超时</p>
<p>Broker 在事务提交阶段异常的情况下会发起事务回查，从而保证事务一致性。但生产者应该尽量避免本地事务返回未知结果，大量的事务检查会导致系统性能受损，容易导致事务处理延迟。</p>
<p>2、事务超时机制</p>
<p>半事务消息被生产者发送 Broker 后，如果在指定时间内服务端无法确认提交或者回滚状态，则消息默认会被回滚。</p>
<hr>
<p>实战代码地址：</p>
<blockquote>
<p>https://github.com/makemyownlife/rocketmq4-learning</p>
</blockquote>
<figure><img src="https://javayong.cn/pics/rocketmq/rocketmq4-learning.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>参考资料：</p>
<blockquote>
<p>阿里云云栖号：https://zhuanlan.zhihu.com/p/554481474</p>
</blockquote>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 消息轨迹</title>
    <id>https://javayong.cn/mq/rocketmq4/11RocketMQ4_messagetrack.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/11RocketMQ4_messagetrack.html"/>
    <updated>2023-11-16T07:55:06.000Z</updated>
    <summary type="html"><![CDATA[<p>这篇文章，我们聊一聊 RocketMQ 的<strong>消息轨迹</strong>设计思路。</p>
<p>查询消息轨迹可作为生产环境中排查问题强有力的数据支持 ，也是研发同学解决线上问题的重要武器之一。</p>
<h1> 1 基础概念</h1>
<p>消息轨迹是指一条消息从生产者发送到 Broker , 再到消费者消费，整个过程中的各个相关节点的时间、状态等数据汇聚而成的完整链路信息。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/rocketmqtrack.png?a=1" alt="" tabindex="0"><figcaption></figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>这篇文章，我们聊一聊 RocketMQ 的<strong>消息轨迹</strong>设计思路。</p>
<p>查询消息轨迹可作为生产环境中排查问题强有力的数据支持 ，也是研发同学解决线上问题的重要武器之一。</p>
<h1> 1 基础概念</h1>
<p>消息轨迹是指一条消息从生产者发送到 Broker , 再到消费者消费，整个过程中的各个相关节点的时间、状态等数据汇聚而成的完整链路信息。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/rocketmqtrack.png?a=1" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>当我们需要查询消息轨迹时，需要明白一点：<strong>消息轨迹数据是存储在 Broker 服务端，我们需要定义一个主题，在生产者，消费者端定义轨迹钩子</strong>。</p>
<h1> 2 开启轨迹</h1>
<h2> 2.1 修改 Broker 配置文件</h2>
<div class="language-properties line-numbers-mode" data-ext="properties"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2> 2.2 生产者配置</h2>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在生产者的构造函数里，有两个核心参数：</p>
<ul>
<li><strong>enableMsgTrace</strong>：是否开启消息轨迹</li>
<li><strong>customizedTraceTopic</strong>：记录消息轨迹的 Topic  , 默认是：<code> RMQ_SYS_TRACE_TOPIC</code> 。</li>
</ul>
<p>执行如下的生产者代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>在生产者代码中，我们指定了消息的 key 属性， 便于对于消息进行高性能检索。</p>
</blockquote>
<p>执行成功之后，我们从控制台查看轨迹信息。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/dashboardtrack.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<figure><img src="https://javayong.cn/pics/rocketmq/traceproducer.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>从图中可以看到，消息轨迹中存储了消息的<code> 存储时间</code> 、<code> 存储服务器IP</code>  、<code>发送耗时</code> 。</p>
<h2> 2.3 消费者配置</h2>
<p>和生产者类似，消费者的构造函数可以传递轨迹参数：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行如下的消费者代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://javayong.cn/pics/rocketmq/consumertrack.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h1> 3 实现原理</h1>
<p>轨迹的实现原理主要是在生产者发送、消费者消费时添加相关的钩子。 因此，我们只需要了解钩子的实现逻辑即可。</p>
<p>下面的代码是 <code>DefaultMQProducer </code> 的构造函数。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当是否<strong>开启轨迹开关</strong>打开时，创建<strong>异步轨迹分发器</strong> <code>AsyncTraceDispatcher</code> ，然后给默认的生产者实现类在发送消息的钩子 <code>SendMessageTraceHookImpl</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>我们把生产者发送消息的流程简化如下代码 ：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>进入<code>SendMessageTraceHookImpl</code> 类 ，该类主要有两个方法 <code>sendMessageBefore</code> 和 <code> sendMessageAfter</code> 。</p>
<p><strong>1、sendMessageBefore 方法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>发送消息之前，先收集消息的 topic 、tag、key 、存储 Broker 的 IP 地址、消息体的长度等基础信息，并将消息轨迹数据存储在调用上下文中。</p>
<p><strong>2、sendMessageAfter 方法</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>跟踪对象里会保存 <code>costTime</code> (消息发送时间)、<code>success</code> （是否发送成功）、<code>regionId</code> (发送到 Broker 所在的分区) 、 <code>msgId</code> (消息 ID，全局唯一)、<code>offsetMsgId</code> (消息物理偏移量) ，<code>storeTime</code> (存储时间 ) 。</p>
<blockquote>
<p>存储时间并没有取消息的实际存储时间，而是估算出来的：客户端发送时间的一般的耗时表示消息的存储时间。</p>
</blockquote>
<p>最后将跟踪上下文添加到本地轨迹分发器：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>下面我们分析下轨迹分发器的原理：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码展示了分发器的构造函数和启动方法，构造函数创建了一个发送消息的线程池 <code>traceExecutor</code> ，启动 start 后会启动一个 <code>worker线程</code>。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>worker 启动后，会从轨迹上下文队列 traceContextQueue 中不断的取出轨迹上下文，并将上下文转换成轨迹数据片段  <code>TraceDataSegment </code>。</p>
<p>为了提升系统的性能，并不是每一次从队列中获取到数据就直接发送到 MQ ，而是积累到一定程度的临界点才触发这个操作，我们可以简单的理解为<strong>批量操作</strong>。</p>
<p>这里面有两个维度 :</p>
<ol>
<li>
<p>轨迹数据片段的数据大小大于某个数据大小阈值。笔者认为这段 RocketMQ 4.9.4 版本代码存疑，因为最新的 5.0 版本做了优化。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>当前时间 - 轨迹数据片段的首次存储时间 是否大于刷新时间 ，也就是每500毫秒刷新一次。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<p>轨迹数据存储的格式如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下图展示了事务轨迹消息数据，每个数据字段是按照 <code>CONTENT_SPLITOR</code> 分隔。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/tracedatademo.png" alt="轨迹消息数据" tabindex="0"><figcaption>轨迹消息数据</figcaption></figure>
<blockquote>
<p>注意：</p>
<p>分隔符  CONTENT_SPLITOR  = (char) 1  它在内存中的值是：00000001 , 但是 char i = '1' 它在内存中的值是 49 ，即 00110001。</p>
</blockquote>
<hr>
<p>参考资料：</p>
<blockquote>
<p>阿里云文档：</p>
<p>https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-4-x-series/user-guide/query-a-message-trace</p>
<p>石臻臻:</p>
<p>https://mp.weixin.qq.com/s/saYD3mG9F1z-oAU6STxewQ</p>
</blockquote>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 消息堆积</title>
    <id>https://javayong.cn/mq/rocketmq4/12RocketMQ4_messagecumulate.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/12RocketMQ4_messagecumulate.html"/>
    <updated>2023-11-16T07:55:06.000Z</updated>
    <summary type="html"><![CDATA[<p>很多同学都在使用 RocketMQ 时，经常会遇到消息堆积的问题。这篇文章，我们聊聊消息堆积的概念，以及如何应对消息堆积。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/messageduiji.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h1> 1 基础概念</h1>
<p>消费者在消费的过程中，消费的速度跟不上服务端的发送速度，未处理的消息会越来越多，消息出现堆积进而会造成消息消费延迟。</p>
<p>虽然笔者经常讲：RocketMQ 、Kafka 具备堆积的能力，但是以下场景需要重点关注消息堆积和延迟的问题：</p>]]></summary>
    <content type="html"><![CDATA[<p>很多同学都在使用 RocketMQ 时，经常会遇到消息堆积的问题。这篇文章，我们聊聊消息堆积的概念，以及如何应对消息堆积。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/messageduiji.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<h1> 1 基础概念</h1>
<p>消费者在消费的过程中，消费的速度跟不上服务端的发送速度，未处理的消息会越来越多，消息出现堆积进而会造成消息消费延迟。</p>
<p>虽然笔者经常讲：RocketMQ 、Kafka 具备堆积的能力，但是以下场景需要重点关注消息堆积和延迟的问题：</p>
<ol>
<li>
<p>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</p>
</li>
<li>
<p>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消息延迟也无法接受。</p>
</li>
</ol>
<h1> 2 消费原理</h1>
<figure><img src="https://javayong.cn/pics/rocketmq/pullmessageandconsume.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>客户端使用 <code>Push 模式 </code>启动后，消费消息时，分为以下两个阶段：</p>
<ul>
<li>
<p>阶段一：<strong>拉取消息</strong></p>
<p>客户端通过长轮询批量拉取的方式从 Broker 服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。</p>
<p>客户端批量拉取消息，常见内网环境下都会有很高的吞吐量，例如：1个单线程单分区的低规格机器（4C8GB）可以达到几万 TPS ，如果是多个分区可以达到几十万 TPS 。所以这一阶段一般不会成为消息堆积的瓶颈。</p>
</li>
<li>
<p>阶段二：<strong>消费消息</strong></p>
<p>提交消费线程，客户端将本地缓存的消息提交到消费线程中，使用业务消费逻辑进行处理。</p>
<p>此时客户端的消费能力就完全依赖于业务逻辑的复杂度（<strong>消费耗时</strong>）和消费逻辑<strong>并发度</strong>了。如果业务处理逻辑复杂，处理单条消息耗时都较长，则整体的消息吞吐量肯定不会高，此时就会导致客户端本地缓冲队列达到上限，停止从服务端拉取消息。</p>
</li>
</ul>
<p>通过以上客户端消费原理可以看出，消息堆积的主要瓶颈在于本地客户端的消费能力，即<strong>消费耗时</strong>和<strong>消费并发度</strong>。</p>
<p>想要避免和解决消息堆积问题，必须合理的控制消费耗时和消息并发度，其中消费耗时的优先级高于消费并发度，必须先保证消费耗时的合理性，再考虑消费并发度问题。</p>
<h1> 3 消费瓶颈</h1>
<h2> 3.1 消费耗时</h2>
<p>影响消费耗时的消费逻辑主要分为 CPU 内存计算和外部 I/O 操作，通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部 I/O 操作来说几乎可以忽略。</p>
<p>外部 I/O 操作通常包括如下业务逻辑：</p>
<ul>
<li>读写外部数据库，例如 MySQL 数据库读写。</li>
<li>读写外部缓存等系统，例如 Redis 读写。</li>
<li>下游系统调用，例如 Dubbo 调用或者下游 HTTP 接口调用。</li>
</ul>
<p>这类外部调用的逻辑和系统容量需要提前梳理，掌握每个调用操作预期的耗时，这样才能判断消费逻辑中I/O操作的耗时是否合理。</p>
<p>通常消费堆积都是由于这些下游系统出现了服务异常、容量限制导致的消费耗时增加。</p>
<p>例如：某业务消费逻辑中需要调用下游 Dubbo 接口 ，单次消费耗时为 20 ms，平时消息量小未出现异常。业务侧进行大促活动时，下游 Dubbo 服务未进行优化，消费单条消息的耗时增加到 200 ms，业务侧可以明显感受到消费速度大幅下跌。此时，通过提升消费并行度并不能解决问题，需要大幅提高下游 Dubbo 服务性能才行。</p>
<h2> 3.2 消费并发度</h2>
<p>绝大部分消息消费行为都属于 IO 密集型，即可能是操作数据库，或者调用 RPC，这类消费行为的消费速度在于后端数据库或者外系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。</p>
<p>所以，应用必须要设置合理的并行度。 如下有几种修改消费并行度的方法：</p>
<ul>
<li>同一个 ConsumerGroup 下，通过增加 Consumer 实例数量来提高并行度（需要注意的是超过订阅队列数的 Consumer 实例无效）。可以通过加机器，或者在已有机器启动多个进程的方式。</li>
<li>提高单个 Consumer 实例的消费并行线程，通过修改参数 consumeThreadMin、consumeThreadMax 实现。</li>
</ul>
<h1> 4 解决策略</h1>
<p>当面对消息堆积问题时，我们需要明确到底哪个环节出现问题了，不要慌张，也不要贸然动手。</p>
<h2> 4.1 确认消息的消费耗时是否合理</h2>
<p>首先，我们需要查看<strong>消费耗时</strong>，确认消息的消费耗时是否合理。查看消费耗时一般来讲有两种方式：</p>
<p><strong>1、打印日志</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、查看消息轨迹</strong></p>
<figure><img src="https://javayong.cn/pics/rocketmq/consumertrackcosttime.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>当确定好消费耗时后，可以根据耗时大小，采取不同的措施。</p>
<ul>
<li>若查看到消费耗时较长，则需要查看客户端堆栈信息排查具体业务逻辑，需查看客户端 JVM 的堆栈 。</li>
<li>若查看到消费耗时正常，则有可能是因为消费并发度不够导致消息堆积，需要逐步调大消费线程或扩容节点来解决。</li>
</ul>
<h2> 4.2 查看客户端 JVM 的堆栈</h2>
<p><strong>假如消费耗时非常高，需要查看 Consumer 实例 JVM 的堆栈 。</strong></p>
<ol>
<li>
<p>通过 <code>jps -m</code> 或者 <code>ps -ef | grep java</code> 命令获取当前正在运行的 Java 程序，通过启动主类即可获得应用的进程 pid ;</p>
</li>
<li>
<p>通过 <code>jstack pid &gt; stack.log</code> 命令获取线程的堆栈。</p>
</li>
<li>
<p>执行以下命令，查看 <code>ConsumeMessageThread</code> 的信息 。</p>
</li>
</ol>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常见的异常堆栈信息如下：</p>
<ul>
<li>
<p>示例1：<strong>空闲无堆积的堆栈</strong> 。</p>
<p>消费空闲情况下消费线程都会处于 <code>WAITING</code> 状态等待从消费任务队里中获取消息。</p>
</li>
</ul>
<figure><img src="https://javayong.cn/pics/rocketmq/waiting.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<ul>
<li>
<p>示例2：<strong>消费逻辑有抢锁休眠等待等情况</strong> 。</p>
<p>消费线程阻塞在内部的一个睡眠等待上，导致消费缓慢。</p>
</li>
</ul>
<figure><img src="https://javayong.cn/pics/rocketmq/time_waiting.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<ul>
<li>
<p>示例3：<strong>消费逻辑操作数据库等外部存储卡住</strong> 。</p>
<p>消费线程阻塞在外部的 HTTP 调用上，导致消费缓慢。</p>
<figure><img src="https://javayong.cn/pics/rocketmq/runnable.png" alt="" tabindex="0"><figcaption></figcaption></figure>
</li>
</ul>
<h1> 5 总结</h1>
<p>客户端使用 <code>Push模式 </code>启动后，消费消息时，分为以下两个阶段：<strong>拉取消息</strong>和<strong>消费消息</strong>。</p>
<p>客户端消费原理可以看出，消息堆积的主要瓶颈在于本地客户端的消费能力，即<strong>消费耗时</strong>和<strong>消费并发度</strong>。</p>
<p>当遇到堆积问题，首先分析消费耗时，然后根据耗时大小，采取不同的措施。</p>
<ul>
<li>若查看到消费耗时较长，则需要查看客户端堆栈信息排查具体业务逻辑，需查看客户端 JVM 的堆栈 。</li>
<li>若查看到消费耗时正常，则有可能是因为消费并发度不够导致消息堆积，需要逐步调大消费线程或扩容节点来解决。</li>
</ul>
<hr>
<p>参考文档：</p>
<blockquote>
<p>万字长文讲透RocketMQ 消费逻辑：</p>
<p>https://mp.weixin.qq.com/s/mlqhXCHfhEht7je8n0rArA</p>
<p>阿里云官方文档：</p>
<p>https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-4-x-series/use-cases/message-accumulation-and-latency#concept-2004064</p>
</blockquote>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">RocketMQ 订阅关系保持一致</title>
    <id>https://javayong.cn/mq/rocketmq4/13RocketMQ4_subscribe_consistent.html</id>
    <link href="https://javayong.cn/mq/rocketmq4/13RocketMQ4_subscribe_consistent.html"/>
    <updated>2023-11-17T08:13:01.000Z</updated>
    <summary type="html"><![CDATA[<p>这篇文章，笔者想聊聊 RocketMQ 最佳实践之一：<strong>保证订阅关系一致</strong>。</p>
<p>订阅关系一致指的是同一个消费者 Group ID 下所有 Consumer 实例所订阅的 Topic 、Tag 必须完全一致。</p>
<p>如果订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>
<h2> 1 订阅关系演示</h2>
<p>首先我们展示正确的订阅关系：多个 Group ID 订阅了多个 Topic，并且每个 Group ID 里的多个消费者的订阅关系保持了一致。</p>
<figure><img src="https://www.javayong.cn/pics/temp//5rMR9gIPHK.png" alt="正确的订阅关系" tabindex="0"><figcaption>正确的订阅关系</figcaption></figure>]]></summary>
    <content type="html"><![CDATA[<p>这篇文章，笔者想聊聊 RocketMQ 最佳实践之一：<strong>保证订阅关系一致</strong>。</p>
<p>订阅关系一致指的是同一个消费者 Group ID 下所有 Consumer 实例所订阅的 Topic 、Tag 必须完全一致。</p>
<p>如果订阅关系不一致，消息消费的逻辑就会混乱，甚至导致消息丢失。</p>
<h2> 1 订阅关系演示</h2>
<p>首先我们展示正确的订阅关系：多个 Group ID 订阅了多个 Topic，并且每个 Group ID 里的多个消费者的订阅关系保持了一致。</p>
<figure><img src="https://www.javayong.cn/pics/temp//5rMR9gIPHK.png" alt="正确的订阅关系" tabindex="0"><figcaption>正确的订阅关系</figcaption></figure>
<p>接下来，我们展示错误的订阅关系。</p>
<figure><img src="https://www.javayong.cn/pics/temp//YlPFIv5qG4.png" alt="错误的订阅关系" tabindex="0"><figcaption>错误的订阅关系</figcaption></figure>
<p>从上图中，单个 Group ID 订阅了多个 Topic，但是该 Group ID 里的多个消费者的订阅关系并没有保持一致。</p>
<p>代码逻辑角度来看，<strong>每个消费者实例内订阅方法的主题、 TAG、监听逻辑都需要保持一致</strong>。</p>
<figure><img src="https://www.javayong.cn/pics/temp//yXSu2AdWE0.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>接下来，我们实验相同消费组，两种不正确的场景，看看消费者和 Broker 服务有什么异常。</p>
<ul>
<li>订阅主题不同，标签相同</li>
<li>订阅主题相同，标签不同</li>
</ul>
<h2> 2 订阅主题不同，标签相同</h2>
<figure><img src="https://www.javayong.cn/pics/temp//p149T2PspM.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>当我们启动两个消费者后，消费者组名：<code>myconsumerGroup</code>。C1消费者订阅主题 <code>TopicTest</code> , C2消费者订阅主题 <code>mytest</code>。</p>
<p>在 Broker 端的日志里，会不停的打印拉取消息失败的日志 ：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>那么在这种情况下，C1 消费者是不可能拉取到消息，也就不可能消费到最新的消息。</p>
<p>为什么呢 ？ 我们知道客户端会定时的发送心跳包到 Broker 服务，心跳包中会包含<strong>消费者订阅信息</strong>，数据格式样例如下：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Broker 服务会调用 <code>ClientManageProcessor</code> 的 <code>heartBeat</code>方法处理心跳请求。</p>
<p>最终跟踪到代码： <code>org.apache.rocketmq.broker.client.ConsumerManager#registerConsumer</code></p>
<figure><img src="https://www.javayong.cn/pics/temp//jeyu9ERNJh.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>Broker 服务的会保存消费者信息，消费者信息存储在消费者表 <code>consumerTable</code> 。消费者表以消费组名为 key , 值为消费者组信息 <code>ConsumerGroupInfo</code> 。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果消费组的消费者信息 ConsumerGroupInfo 为空，则新建新的对象。</p>
<p>更新订阅信息时，订阅信息是按照消费组存放的，这步骤就会导致同一个消费组内的各个消费者客户端的订阅信息相互被覆盖。</p>
<p>回到消费者客户端，当消费者拉取消息时，Broker 服务会调用 <code>PullMessageProcessor</code> 的 <code>processRequest </code>方法 。</p>
<p>首先会进行前置判断，查询当前的主题的订阅信息若该主题的订阅信息为空，则打印告警日志，并返回异常的响应结果。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过调研 Broker 端的代码，我们发现：<strong>相同消费组的订阅信息必须保持一致 , 否则同一个消费组内的各个消费者客户端的订阅信息相互被覆盖，从而导致某个消费者客户端无法拉取到新的消息</strong>。</p>
<p>C1消费者无法消费主题 <code>TopicTest</code> 的消息数据，那么 C2 消费者订阅主题 <code>mytest</code>，消费会正常吗 ？</p>
<figure><img src="https://www.javayong.cn/pics/temp//ayW5Bjyplu.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>从上图来看，依然有问题。 主题 mytest 有四个队列，但只有两个队列被分配了， 另外两个队列的消息就没有办法消费了。</p>
<p>要解释这个问题，我们需要重新温习<strong>负载均衡</strong>的原理。</p>
<hr>
<p>负载均衡服务会根据消费模式为”广播模式”还是“集群模式”做不同的逻辑处理，这里主要来看下集群模式下的主要处理流程：</p>
<p>(1) 获取该主题下的消息消费队列集合；</p>
<p>(2) 查询 Broker 端获取该消费组下消费者 Id 列表；</p>
<p>(3) 先对 Topic 下的消息消费队列、消费者 Id 排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列；</p>
<figure><img src="https://www.javayong.cn/pics/temp//iYLyVcUAt4-20231117160818531.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>这里的平均分配算法，类似于分页的算法，将所有 MessageQueue 排好序类似于记录，将所有消费端排好序类似页数，并求出每一页需要包含的平均 size 和每个页面记录的范围 range ，最后遍历整个 range 而计算出当前消费端应该分配到的记录。</p>
<p>(4) 分配到的消息队列集合与 processQueueTable 做一个过滤比对操作。</p>
<figure><img src="https://www.javayong.cn/pics/temp//xs0dDuzfwc-20231117160818528.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>消费者实例内 ，processQueueTable 对象存储着当前负载均衡的队列 ，以及该队列的处理队列 processQueue (消费快照)。</p>
<ol>
<li>
<p>标红的 Entry 部分表示与分配到的消息队列集合互不包含，则需要将这些红色队列 Dropped 属性为 true , 然后从 processQueueTable 对象中移除。</p>
</li>
<li>
<p>绿色的 Entry 部分表示与分配到的消息队列集合的交集，processQueueTable 对象中已经存在该队列。</p>
</li>
<li>
<p>黄色的 Entry 部分表示这些队列需要添加到 processQueueTable 对象中，为每个分配的新队列创建一个消息拉取请求 <code>pullRequest</code> , 在消息拉取请求中保存一个处理队列 <code>processQueue</code> （队列消费快照），内部是红黑树（<code>TreeMap</code>），用来保存拉取到的消息。</p>
</li>
</ol>
<p>最后创建拉取消息请求列表，并<strong>将请求分发到消息拉取服务，进入拉取消息环节</strong>。</p>
<hr>
<p>通过上面的介绍 ，通过负载均衡的原理推导，原因就显而易见了。</p>
<figure><img src="https://www.javayong.cn/pics/temp//UFkBIMqRuE.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>C1消费者被分配了队列 0、队列 1 ，但是 C1消费者本身并没有订阅主题 mytest , 所以无法消费该主题的数据。</p>
<p>从本次实验来看，C1消费者无法消费主题 <code>TopicTest</code> 的消息数据 , C2 消费者只能部分消费主题 <code>mytest</code>的消息数据。</p>
<p>但是因为在 Broker 端，同一个消费组内的各个消费者客户端的订阅信息相互被覆盖，所以这种消费状态非常混乱，偶尔也会切换成：C1消费者可以部分消费主题 <code>TopicTest</code> 的消息数据 , C2消费者无法消费主题 <code>mytest</code>的消息数据。</p>
<h2> 3 订阅主题相同，标签不同</h2>
<figure><img src="https://www.javayong.cn/pics/temp//MLEOohsjbL.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>如图，C1 消费者和 C2 消费者订阅主题 <code>TopicTest</code> ，但两者的标签 TAG 并不相同。</p>
<p>启动消费者服务之后，从控制台观察，负载均衡的效果也如预期一般正常。</p>
<figure><img src="https://www.javayong.cn/pics/temp//kGvVrHStP7.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>笔者在 Broker 端打印埋点日志，发现主题 <code>TopicTest</code> 的订阅信息为 ：</p>
<div class="language-json line-numbers-mode" data-ext="json"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么这种状态，消费正常吗 ？笔者做了一组实验，消费依然混乱：</p>
<p><strong>C1 消费者无法消费 TAG 值为 A 的消息 ，C2 消费者只能消费部分 TAG 值为 B 的消息。</strong></p>
<p>想要理解原因，我们需要梳理消息过滤机制。</p>
<p>首先 ConsumeQueue 文件的格式如下 ：</p>
<figure><img src="https://www.javayong.cn/pics/temp//o4BiIVsDSs-20231117160818552.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>
<ol>
<li>Broker 端在接收到拉取请求后，根据请求参数定位 ConsumeQueue 文件，然后遍历 ConsumeQueue 待检索的条目， 判断条目中存储 Tag 的 hashcode 是否和订阅信息中 TAG 的 hashcode 是否相同，若不符合，则跳过，继续对比下一个， 符合条件的聚合后返回给消费者客户端。</li>
<li>消费者在收到过滤后的消息后，也要执行过滤机制，只不过过滤的是 TAG 字符串的值，而不是 hashcode 。</li>
</ol>
<p>我们模拟下消息过滤的过程：</p>
<figure><img src="https://www.javayong.cn/pics/temp//aGylJz255T.png" alt="" tabindex="0"><figcaption></figcaption></figure>
<p>首先，生产者将不同的消息发送到 Broker 端，不同的 TAG 的消息会发送到保存的不同的队列中。</p>
<p>C1 消费者从队列 0 ，队列 1 中拉取消息时，因为 Broker 端该主题的订阅信息中 TAG 值为 B ，经过服务端过滤后， C1 消费者拉取到的消息的 TAG 值都是 B  , 但消费者在收到过滤的消息后，也需要进行客户端过滤，A 并不等于 B ，所以 C1 消费者无法消费 TAG 值为 A 的消息。</p>
<p>C2 消费者从队列 2， 队列 3 中拉取消息，整个逻辑链路是正常的 ，但是因为负载均衡的缘故，它无法消费队列 0 ，队列 1的消息。</p>
<h2> 4 总结</h2>
<p>什么是消费组 ？消费同一类消息且消费逻辑一致 。</p>
<p><strong>RocketMQ 4.X 源码实现就是为了和消费组的定义保持一致</strong> ，假如订阅关系不一致，那么代码执行逻辑就会出现混乱。</p>
<p>规避订阅关系不一致这个问题有两种方式:</p>
<ul>
<li><strong>合理定义好主题和标签</strong></li>
</ul>
<p>当我们定义好主题和标签后，需要添加新的标签时，是否可以换一个思路：换一个新的消费组或者新建一个主题。</p>
<ul>
<li><strong>严格规范上线流程</strong></li>
</ul>
<p>在上线之前，梳理好相关依赖服务，梳理好上线流程，做好上线评审，并严格按照流程执行。</p>
<p>最后的思考：</p>
<p>假如从基础架构层面来思考，将订阅关系信息中心化来设计，应该也可以实现 ，但成本较高，对于中小企业来讲，并不合算。</p>
<hr>
<p>参考资料：</p>
<blockquote>
<p>RocketMQ为什么要保证订阅关系的一致性 :</p>
<p>https://cloud.tencent.com/developer/article/1474885</p>
<p>RocketMQ最佳实践之坑？</p>
<p>https://mp.weixin.qq.com/s/Ypk-U8uVu4aZKMinbfU3xQ</p>
<p>源码分析RocketMQ消息过滤机制</p>
<p>https://blog.csdn.net/prestigeding/article/details/79255328</p>
</blockquote>
]]></content>
    <category term="RocketMQ"/>
    <published>2023-11-16T02:18:17.000Z</published>
  </entry>
  <entry>
    <title type="text">阅读目录</title>
    <id>https://javayong.cn/home.html</id>
    <link href="https://javayong.cn/home.html"/>
    <updated>2023-11-20T07:15:36.000Z</updated>
    <summary type="html"><![CDATA[<hr>
<h2> 缓存实战</h2>
<ul>
<li><a href="/cache/00localandclustercache.html" target="blank">聊聊本地缓存和分布式缓存</a></li>
<li><a href="/cache/01fourJDKlocalcache.html" target="blank">四种强大的JDK本地缓存</a></li>
<li><a href="/cache/02pagelistcache.html" target="blank">聊聊分页列表缓存</a></li>
<li><a href="/cache/05boolfilter.html" target="blank">详解布隆过滤器</a></li>
<li><a href="/cache/07Redistransaction.html" target="blank">聊聊Redis事务</a></li>
<li><a href="/cache/09SpringCache.html" target="blank">品味SpringCache设计之美</a></li>
</ul>]]></summary>
    <content type="html"><![CDATA[<hr>
<h2> 缓存实战</h2>
<ul>
<li><a href="/cache/00localandclustercache.html" target="blank">聊聊本地缓存和分布式缓存</a></li>
<li><a href="/cache/01fourJDKlocalcache.html" target="blank">四种强大的JDK本地缓存</a></li>
<li><a href="/cache/02pagelistcache.html" target="blank">聊聊分页列表缓存</a></li>
<li><a href="/cache/05boolfilter.html" target="blank">详解布隆过滤器</a></li>
<li><a href="/cache/07Redistransaction.html" target="blank">聊聊Redis事务</a></li>
<li><a href="/cache/09SpringCache.html" target="blank">品味SpringCache设计之美</a></li>
</ul>
<h2> 消息队列</h2>
<h3> RocketMQ4.X设计精要</h3>
<ul>
<li><a href="/mq/rocketmq4/00RocketMQ4_introduce.html" target="blank">序言</a></li>
<li><a href="/mq/rocketmq4/01RocketMQ4_artch.html" target="blank">RocketMQ整体架构</a></li>
<li><a href="/mq/rocketmq4/01RocketMQ4_network.html" target="blank">RocketMQ网络通讯</a></li>
<li><a href="/mq/rocketmq4/02RocketMQ4_nameserver.html" target="blank">RocketMQ名字服务</a></li>
<li><a href="/mq/rocketmq4/03RocketMQ4_producer.html" target="blank">RocketMQ生产者</a></li>
<li><a href="/mq/rocketmq4/04RocketMQ4_store.html" target="blank">RocketMQ存储模型</a></li>
<li><a href="/mq/rocketmq4/06RocketMQ4_consumer.html" target="blank">RocketMQ消费者</a></li>
<li><a href="/mq/rocketmq4/07RocketMQ4_broadcast_consumer.html" target="blank">RocketMQ广播消费</a></li>
<li><a href="/mq/rocketmq4/08RocketMQ4_masterslave.html" target="blank">RocketMQ主从同步</a></li>
<li><a href="/mq/rocketmq4/10RocketMQ4_transaction.html" target="blank">RocketMQ事务原理</a></li>
<li><a href="/mq/rocketmq4/11RocketMQ4_messagetrack.html" target="blank">RocketMQ消息轨迹</a></li>
<li><a href="/mq/rocketmq4/13RocketMQ4_subscribe_consistent.html" target="blank">RocketMQ订阅关系保证一致</a></li>
</ul>
<h2> 技术人生</h2>
<ul>
<li><a href="/codelife/runningforcode.html" target="blank">追源码的平凡之路</a></li>
<li><a href="/codelife/messagequeuecareer.html" target="blank">我与消息队列的八年情缘</a></li>
<li><a href="/codelife/howtolearnopenproject.html" target="blank">聊聊如何学习开源项目</a></li>
<li><a href="/codelife/guotuxuexistorm.html" target="blank">聊聊我与流式计算的故事</a></li>
</ul>
<h2> 公众号</h2>
<p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号“<strong>勇哥java实战分享</strong>”。</p>
<figure><img src="https://javayong.cn/pics/shipinhao/gongzhonghaonew.png" alt="" tabindex="0"><figcaption></figcaption></figure>
]]></content>
    <published>2023-06-29T07:18:23.000Z</published>
  </entry>
</feed>