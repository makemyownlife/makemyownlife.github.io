import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e as p}from"./app-1c1562ff.js";const t={},e=p(`<p>开源中国的红薯哥写了很多关于缓存的文章，其中多级缓存思路，分页列表缓存这些知识点给了我很大的启发性。</p><p>写这篇文章，我们聊聊<strong>分页列表缓存</strong>，希望能帮助大家提升缓存技术认知。</p><h2 id="_1-直接缓存分页列表结果" tabindex="-1"><a class="header-anchor" href="#_1-直接缓存分页列表结果" aria-hidden="true">#</a> 1 直接缓存分页列表结果</h2><p>显而易见，这是最简单易懂的方式。</p><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536756-1162415241.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>我们按照不同的分页条件来缓存分页结果 ，伪代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span> <span class="token function">getPageList</span><span class="token punctuation">(</span><span class="token class-name">String</span> param<span class="token punctuation">,</span><span class="token keyword">int</span> page<span class="token punctuation">,</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token string">&quot;productList:page:&quot;</span> <span class="token operator">+</span> page <span class="token operator">+</span> ”size<span class="token operator">:</span>“ <span class="token operator">+</span> size <span class="token operator">+</span> 
               <span class="token string">&quot;param:&quot;</span> <span class="token operator">+</span> param <span class="token punctuation">;</span>
  <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span> dataList <span class="token operator">=</span> cacheUtils<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>dataList <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> dataList<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  dataList <span class="token operator">=</span> <span class="token function">queryFromDataBase</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span>page<span class="token punctuation">,</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>dataList <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       cacheUtils<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key <span class="token punctuation">,</span> dataList <span class="token punctuation">,</span> <span class="token class-name">Constants<span class="token punctuation">.</span>ExpireTime</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种方案的优点是工程简单，性能也快，但是有一个非常明显的缺陷基因：<strong>列表缓存的颗粒度非常大</strong>。</p><p>假如列表中数据发生增删，为了保证数据的一致性，需要修改分页列表缓存。</p><p>有两种方式 ：</p><p>1、依靠缓存过期来惰性的实现 ，但业务场景必须包容；</p><p>2、使用 Redis 的 keys 找到该业务的分页缓存，执行删除指令。 但 keys 命令对性能影响很大，会导致 Redis 很大的延迟 。</p><h2 id="_2-查询对象id列表-再缓存每个对象条目" tabindex="-1"><a class="header-anchor" href="#_2-查询对象id列表-再缓存每个对象条目" aria-hidden="true">#</a> 2 查询对象ID列表，再缓存每个对象条目</h2><p>缓存分页结果虽然好用，但缓存的颗粒度太大，保证数据一致性比较麻烦。</p><p>所以我们的目标是<strong>更细粒度的控制缓存</strong> 。</p><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535770-925522893.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>我们查询出商品分页对象ID列表，然后为每一个商品对象创建缓存 , 通过商品ID和商品对象缓存聚合成列表返回给前端。</p><p>伪代码如下：<img src="https://www.javayong.cn/pics/cache//2487169-20230523161536367-1808772045.png" alt=""></p><p>核心流程：</p><p><strong>1、从数据库中查询分页 ID 列表</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 从数据库中查询分页商品 ID 列表</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> productIdList <span class="token operator">=</span> <span class="token function">queryProductIdListFromDabaBase</span><span class="token punctuation">(</span>
                           param<span class="token punctuation">,</span> 
                           page<span class="token punctuation">,</span> 
                           size<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对应的 SQL 类似：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> products
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> id 
<span class="token keyword">LIMIT</span> <span class="token punctuation">(</span>page <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> size <span class="token punctuation">,</span> size 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、批量从缓存中获取商品对象</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span> cachedProductMap <span class="token operator">=</span> cacheUtils<span class="token punctuation">.</span><span class="token function">mget</span><span class="token punctuation">(</span>productIdList<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>假如我们使用本地缓存，直接一条一条从本地缓存中聚合也极快。</p><p>假如我们使用分布式缓存，Redis 天然支持批量查询的命令 ，比如 mget ，hmget 。</p><p><strong>3、组装没有命中的商品ID</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> noHitIdList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>cachedProductMap<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Long</span> productId <span class="token operator">:</span> productIdList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cachedProductMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         noHitIdList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为缓存中可能因为过期或者其他原因导致缓存没有命中的情况，所以我们需要找到哪些商品没有在缓存里。</p><p><strong>4、批量从数据库查询未命中的商品信息列表，重新加载到缓存</strong></p><p>首先从数据库里<strong>批量</strong>查询出未命中的商品信息列表 ，请注意是<strong>批量</strong>。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span> noHitProductList <span class="token operator">=</span> <span class="token function">batchQuery</span><span class="token punctuation">(</span>noHitIdList<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数是未命中缓存的商品ID列表，组装成对应的 SQL，这样性能更快 ：</p><div class="language-SQL line-numbers-mode" data-ext="SQL"><pre class="language-SQL"><code>SELECT * FROM products WHERE id IN
                         (1,
                          2,
                          3,
                          4);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后这些未命中的商品信息存储到缓存里 , 使用 Redis 的 mset 命令。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//将没有命中的商品加入到缓存里</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">,</span> <span class="token class-name">Product</span><span class="token punctuation">&gt;</span></span> noHitProductMap <span class="token operator">=</span>
         noHitProductList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
         <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>
           <span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token class-name">Product</span><span class="token operator">::</span><span class="token function">getId</span><span class="token punctuation">,</span> <span class="token class-name">Function</span><span class="token punctuation">.</span><span class="token function">identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
         <span class="token punctuation">)</span><span class="token punctuation">;</span>
cacheUtils<span class="token punctuation">.</span><span class="token function">mset</span><span class="token punctuation">(</span>noHitProductMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//将没有命中的商品加入到聚合map里</span>
cachedProductMap<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>noHitProductMap<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>5、 遍历商品ID列表，组装对象列表</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Long</span> productId <span class="token operator">:</span> productIdList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Product</span> product <span class="token operator">=</span> cachedProductMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>productId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>product <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>product<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当前方案里，缓存都有命中的情况下，经过两次网络 IO ，第一次数据库查询 IO ，第二次 Redis 查询 IO , 性能都会比较好。</p><p>所有的操作都是批量操作，就算有缓存没有命中的情况，整体速度也较快。</p><p>”<strong>查询对象ID列表，再缓存每个对象条目</strong>“ 这个方案比较灵活，当我们<strong>查询对象ID列表</strong>，可以不限于数据库，还可以是搜索引擎，Redis 等等。</p><p>下图是开源中国的搜索流程：</p><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535579-752010347.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>精髓在于：<strong>搜索的分页结果只包含业务对象 ID ，对象的详细资料需要从缓存 + MySQL 中获取。</strong></p><h2 id="_3-缓存对象id列表-同时缓存每个对象条目" tabindex="-1"><a class="header-anchor" href="#_3-缓存对象id列表-同时缓存每个对象条目" aria-hidden="true">#</a> 3 缓存对象ID列表,同时缓存每个对象条目</h2><p>笔者曾经重构过类似朋友圈的服务，进入班级页面 ，瀑布流的形式展示班级成员的所有动态。</p><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536234-1479945726.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>我们使用推模式将每一条动态 ID 存储在 Redis ZSet 数据结构中 。Redis ZSet 是一种类型为有序集合的数据结构，它由多个有序的唯一的字符串元素组成，每个元素都关联着一个浮点数分值。</p><p>ZSet 使用的是 member -&gt; score 结构 ：</p><ul><li>member : 被排序的标识，也是默认的第二排序维度（ score 相同时，Redis 以 member 的字典序排列）</li><li>score : 被排序的分值，存储类型是 double</li></ul><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536124-570559847.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>如上图所示：<strong>ZSet 存储动态 ID 列表 , member 的值是动态编号 , score 值是创建时间</strong>。</p><p>通过 ZSet 的 <strong>ZREVRANGE 命令</strong>就可以实现分页的效果。</p><p>ZREVRANGE 是 Redis 中用于有序集合（sorted set）的命令之一，它用于按照成员的分数从大到小返回有序集合中的指定范围的成员。</p><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535893-748949994.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>为了达到分页的效果，传递如下的分页参数 ：</p><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161535058-1294698241.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>通过 ZREVRANGE 命令，我们可以查询出动态 ID 列表。</p><p>查询出动态 ID 列表后，还需要缓存每个动态对象条目，动态对象包含了详情，评论，点赞，收藏这些功能数据 ，我们需要为这些数据提供单独做缓存配置。</p><figure><img src="https://www.javayong.cn/pics/cache/2487169-20230523161536578-881577270.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>无论是查询缓存，还是重新写入缓存，为了提升系统性能，批量操作效率更高。</p><p>若**缓存对象结构简单，使用 mget 、hmget 命令；若结构复杂，可以考虑使用 pipleline，Lua 脚本模式 。**笔者选择的批量方案是 Redis 的 pipleline 功能。</p><p>我们再来模拟获取动态分页列表的流程：</p><ol><li>使用 ZSet 的 ZREVRANGE 命令 ，传入分页参数，查询出动态 ID 列表 ；</li><li>传递动态 ID 列表参数，通过 Redis 的 pipleline 功能从缓存中批量获取动态的详情，评论，点赞，收藏这些功能数据 ，组装成列表 。</li></ol><h2 id="_4-总结" tabindex="-1"><a class="header-anchor" href="#_4-总结" aria-hidden="true">#</a> 4 总结</h2><p>本文介绍了实现分页列表缓存的三种方式：</p><ol><li><p>直接缓存分页列表结果</p></li><li><p>查询对象ID列表，只缓存每个对象条目</p></li><li><p>缓存对象ID列表，同时缓存每个对象条目</p></li></ol><p>这三种方式是一层一层递进的，要诀是：</p><p><strong>细粒度的控制缓存</strong>和<strong>批量加载对象</strong>。</p>`,70),c=[e];function o(i,l){return s(),a("div",null,c)}const d=n(t,[["render",o],["__file","02pagelistcache.html.vue"]]);export{d as default};
