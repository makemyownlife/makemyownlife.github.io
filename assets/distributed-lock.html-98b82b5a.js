const t=JSON.parse('{"key":"v-dff0fe32","path":"/distributed-system/distributed-lock.html","title":"分布式锁介绍","lang":"zh-CN","frontmatter":{"title":"分布式锁介绍","category":"分布式","description":"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。 这篇文章我们先介绍一下分布式锁的基本概念。 为什么需要分布式锁？ 在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。 举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况： 线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。 线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。 线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。 线程 1 继续执行，将库存数量减少 1 个，然后返回成功。 线程 2 继续执行，将库存数量减少 1 个，然后返回成功。 此时就发生了超卖问题，导致商品被多卖了一份。","head":[["meta",{"property":"og:url","content":"https://javaguide.cn/distributed-system/distributed-lock.html"}],["meta",{"property":"og:site_name","content":"勇哥Java实战"}],["meta",{"property":"og:title","content":"分布式锁介绍"}],["meta",{"property":"og:description","content":"网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。 这篇文章我们先介绍一下分布式锁的基本概念。 为什么需要分布式锁？ 在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。 举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况： 线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。 线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。 线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。 线程 1 继续执行，将库存数量减少 1 个，然后返回成功。 线程 2 继续执行，将库存数量减少 1 个，然后返回成功。 此时就发生了超卖问题，导致商品被多卖了一份。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-06-29T07:18:23.000Z"}],["meta",{"property":"article:author","content":"Guide"}],["meta",{"property":"article:modified_time","content":"2023-06-29T07:18:23.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式锁介绍\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-06-29T07:18:23.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Guide\\",\\"url\\":\\"https://javaguide.cn/article/\\"}]}"]]},"headers":[{"level":2,"title":"为什么需要分布式锁？","slug":"为什么需要分布式锁","link":"#为什么需要分布式锁","children":[]},{"level":2,"title":"分布式锁应该具备哪些条件？","slug":"分布式锁应该具备哪些条件","link":"#分布式锁应该具备哪些条件","children":[]},{"level":2,"title":"分布式锁的常见实现方式有哪些？","slug":"分布式锁的常见实现方式有哪些","link":"#分布式锁的常见实现方式有哪些","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1688023103000,"updatedTime":1688023103000,"contributors":[{"name":"zhangyong","email":"zhangyong7120180@163.com","commits":1}]},"readingTime":{"minutes":5.7,"words":1711},"filePathRelative":"distributed-system/distributed-lock.md","localizedDate":"2023年6月29日","excerpt":"<p>网上有很多分布式锁相关的文章，写了一个相对简洁易懂的版本，针对面试和工作应该够用了。</p>\\n<p>这篇文章我们先介绍一下分布式锁的基本概念。</p>\\n<h2> 为什么需要分布式锁？</h2>\\n<p>在多线程环境中，如果多个线程同时访问共享资源（例如商品库存、外卖订单），会发生数据竞争，可能会导致出现脏数据或者系统问题，威胁到程序的正常运行。</p>\\n<p>举个例子，假设现在有 100 个用户参与某个限时秒杀活动，每位用户限购 1 件商品，且商品的数量只有 3 个。如果不对共享资源进行互斥访问，就可能出现以下情况：</p>\\n<ul>\\n<li>线程 1、2、3 等多个线程同时进入抢购方法，每一个线程对应一个用户。</li>\\n<li>线程 1 查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>\\n<li>线程 2 也执行查询用户已经抢购的数量，发现当前用户尚未抢购且商品库存还有 1 个，因此认为可以继续执行抢购流程。</li>\\n<li>线程 1 继续执行，将库存数量减少 1 个，然后返回成功。</li>\\n<li>线程 2 继续执行，将库存数量减少 1 个，然后返回成功。</li>\\n<li>此时就发生了超卖问题，导致商品被多卖了一份。</li>\\n</ul>","copyright":{"author":"Guide"},"autoDesc":true}');export{t as data};
