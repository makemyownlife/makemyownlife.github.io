import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,e as t}from"./app-1c1562ff.js";const p={},n=t('<p>这篇文章，笔者想聊聊那些在业务系统中较少被使用，但却活跃于中间件或者框架里，强大却又低调的缓存，<strong>笔者愿称他们为缓存世界的扫地僧</strong>。</p><figure><img src="https://javayong.cn/pics/cache/cachesaodisheng.png" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="_1-hashmap-concurrenthashmap-配置缓存" tabindex="-1"><a class="header-anchor" href="#_1-hashmap-concurrenthashmap-配置缓存" aria-hidden="true">#</a> 1 HashMap/ConcurrentHashMap 配置缓存</h2><p>HashMap 是一种基于哈希表的集合类，它提供了快速的插入、查找和删除操作。</p><p>HashMap 是很多程序员接触的第一种缓存 , 因为现实业务场景里，我们可能需要给缓存添加<strong>缓存统计</strong>、<strong>过期失效</strong>、<strong>淘汰策略</strong>等功能，HashMap 的功能就显得孱弱 ，所以 HashMap 在业务系统中使用得并不算多。</p><p>但 <strong>HashMap 在中间件中却是香饽饽</strong>，我们消息中间件 RocketMQ 为例。</p><figure><img src="https://javayong.cn/pics/cache/rocketmq架构.webp" alt="" tabindex="0"><figcaption></figcaption></figure><p>上图是 RocketMQ 的集群模式 ，Broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master 。</p><p>每个 Broker 与 Name Server 集群中的所有节点建立长连接，定时每隔 30 秒注册 <strong>主题的路由信息</strong>到所有 Name Server。</p><p>消息发送者、消息消费者，在同一时间只会连接 Name Server 集群中的一台服务器，并且会每隔 30s 会定时更新 Topic 的路由信息。</p><p>我们可以理解 Name Server 集群的作用就是<strong>注册中心</strong>，注册中心会保存<strong>路由信息</strong>（主题的读写队列数、操作权限等），路由信息就是保存在 <strong>HashMap</strong> 中 。</p><figure><img src="https://javayong.cn/pics/cache/rocketmqhash.webp?" alt="" tabindex="0"><figcaption></figcaption></figure><p>路由信息通过几个 HashMap 来保存，当 Broker 向 Nameserver 发送心跳包（路由信息），Nameserver 需要对 HashMap 进行数据更新，但我们都知道 HashMap 并不是线程安全的，高并发场景下，容易出现 CPU 100% 问题，所以更新 HashMap 时需要加锁，RocketMQ 使用了 JDK 的读写锁 ReentrantReadWriteLock 。</p><p>下面我们看下路由信息如何更新和读取：</p><p><strong>1、写操作：更新路由信息，操作写锁</strong></p><figure><img src="https://javayong.cn/pics/cache/读写锁.webp" alt="" tabindex="0"><figcaption></figcaption></figure><p><strong>2、读操作：查询主题信息，操作读锁</strong></p><figure><img src="https://javayong.cn/pics/cache/readlock.webp?" alt="" tabindex="0"><figcaption></figcaption></figure><p>同时，我们需要注意 Name Server 维护路由信息还需要定时任务的支撑。</p><ul><li>每个 Broker 定时每隔 30 秒注册 <strong>主题的路由信息</strong>到所有 Name Server</li><li>Name Server 定时任务每隔10 秒清除已宕机的 Broker</li></ul><p>我们做一个小小的总结，Name Server 维护路由的模式是： <strong>HashMap + 读写锁 + 定时任务更新</strong>。</p><ul><li>HashMap 作为存储容器</li><li>读写锁控制锁的颗粒度</li><li>定时任务定时更新缓存</li></ul><p>写到这里，我们不禁想到 ConcurrentHashMap 。</p><p>ConcurrentHashMap 可以保证线程安全，JDK1.7 之前使用<strong>分段锁机制</strong>实现，JDK1.8 则使用<strong>数组+链表+红黑树</strong>数据结构和<strong>CAS原子操作</strong>实现。</p><p>Broker 使用不同的 ConcurrentHashMap 分别用来存储消费组、消费进度、消息过滤信息等。</p><p>那么名字服务为什么不使用 ConcurrentHashMap 作为存储容器呢 ？</p><p>最核心的原因在于：路由信息由多个 HashMap 组成，通过每次写操作可能要操作多个对象 ，为了保证其一致性，所以才需要加读写锁。</p><h2 id="_2-linkedhashmap-最近最少使用缓存" tabindex="-1"><a class="header-anchor" href="#_2-linkedhashmap-最近最少使用缓存" aria-hidden="true">#</a> 2 LinkedHashMap 最近最少使用缓存</h2><p>LinkedHashMap 是 HashMap 的子类，但是内部还有一个双向链表维护键值对的顺序，每个键值对既位于哈希表中，也位于双向链表中。</p><p>LinkedHashMap 支持两种顺序<strong>插入顺序 、 访问顺序</strong>。</p><ul><li><strong>插入顺序</strong>：先添加的在前面，后添加的在后面，修改操作并不影响顺序</li><li><strong>访问顺序</strong>：问指的是 get/put 操作，对一个键执行 get/put 操作后，其对应的键值对会移动到链表末尾，所以最末尾的是最近访问的，最开始的是最久没有被访问的，这就是访问顺序。</li></ul><p>LinkedHashMap 经典的用法是作为 LruCache (最近最少使用缓存) ，而 MyBatis 的二级缓存的淘汰机制就是使用的 LinkedHashMap 。</p><p>MyBatis 的二级缓存是使用<strong>责任链</strong>+ <strong>装饰器</strong>的设计模式实现的。</p><figure><img src="https://javayong.cn/pics/cache/mybatisjar.webp" alt="" tabindex="0"><figcaption></figcaption></figure><p>上图中，装饰器包目录下 Cache 接口有不同的实现类，比如<strong>过期淘汰</strong>、<strong>日志记录</strong>等。</p><figure><img src="https://javayong.cn/pics/cache/lrucache.webp" alt="" tabindex="0"><figcaption></figcaption></figure><p>LruCache 使用了装饰器模式 ，使用 LinkedHashMap 默认保存 1024 个缓存 key ，当 key 最久未被访问，并且 keyMap 的大小超过 1024 时 ，记录最老的 key ，当下次添加缓存对象时，删除最老的 key。</p><p>使用 LinkedHashMap 重点需要做到<strong>使用访问顺序模式</strong>和<strong>重写 removeEldestEntry 方法</strong>。 因为 LinkedHashMap 并不是线程安全的，Mybatis 二级缓存责任链中 SynchronizedCache 对象可以实现线程安全的对缓存读写。</p><h2 id="_3-treemap-排序对象缓存" tabindex="-1"><a class="header-anchor" href="#_3-treemap-排序对象缓存" aria-hidden="true">#</a> 3 TreeMap 排序对象缓存</h2><p>TreeMap 是一种基于红黑树的有序 Map，它可以按照键的顺序进行遍历。</p><p>TreeMap 有两种应用场景让笔者印象极为深刻 ，他们分别是一致性哈希算法和 RocketMQ 消费快照 。</p><p>本文重点介绍 TreeMap 在一致性哈希算法中的应用。</p><p>一致性哈希（Consistent Hashing）算法被广泛应用于缓存系统、分布式数据库、负载均衡器等分布式系统中，以实现高性能和高可用性。它解决了传统哈希算法在动态环境下扩展性和负载均衡性能的问题。</p><p>一致性哈希的主要优点是在节点增减时，只有少量的数据需要重新映射，因为只有那些直接或间接与新增或删除节点相邻的数据项需要迁移。这大大减少了系统的迁移开销和影响，使得系统更具扩展性和可伸缩性。</p><p>TreeMap 在一致性哈希中可以用作节点/虚拟节点的存储结构，用来维护节点在哈希环上的位置和键的有序性。</p><p><strong>1、我们定义一个 TreeMap 存储节点/虚拟节点 。</strong></p><figure><img src="https://javayong.cn/pics/cache/consistenttreemap.png?" alt="" tabindex="0"><figcaption></figcaption></figure><p><strong>2、初始化节点</strong></p><p>构造函数包含三个部分：物理节点集合、每个物理节点对应的虚拟节点个数、哈希函数 。</p><figure><img src="https://javayong.cn/pics/cache/consistentainit.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>我们重点看下添加节点逻辑：</p><figure><img src="https://javayong.cn/pics/cache/consistentaddnode.png?a=123" alt="" tabindex="0"><figcaption></figcaption></figure><p><strong>3、按照 key 查询节点</strong></p><p>添加完节点之后，节点分布类似下图：</p><figure><img src="https://javayong.cn/pics/cache/hashring0.png" alt="" tabindex="0"><figcaption></figcaption></figure><figure><img src="https://javayong.cn/pics/cache/consistentroute.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>当需要定位某个 key 属于哪个节点时，先通过哈希函数计算 key 的哈希值，并在环上顺时针方向找到第一个大于等于该哈希值的节点位置。该节点即为数据的归属节点 。</p><p>我们添加一个新的节点 node5 , 从下图中，我们可以看到，影响的范围（深黄色）并不大 ，这也就是一致性哈希算法的优势。</p><figure><img src="https://javayong.cn/pics/cache/hashring1.png?" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="_4-bytebuffer-网络编程缓冲池" tabindex="-1"><a class="header-anchor" href="#_4-bytebuffer-网络编程缓冲池" aria-hidden="true">#</a> 4 ByteBuffer 网络编程缓冲池</h2><p>ByteBuffer 是字节缓冲区，主要用于用户读取和缓存字节数据，多用于网络编程、文件 IO 处理等。</p><p>笔者第一次接触 ByteBuffer 是在分库分表中间件 Cobar 中 。在网络编程里，经常需要分配内存，在高并发场景下，性能压力比较大。</p><p>Cobar 抽象了一个 NIOProcessor 类用来处理网络请求，每个处理器初始化的时候都会创建一个缓冲池 BufferPool 。 BufferPool 用于池化 ByteBuffer ，这和我们平常使用的数据库连接池的思路是一致的。</p><figure><img src="https://javayong.cn/pics/cache/cobarbufferpool.png?a=1" alt="" tabindex="0"><figcaption></figcaption></figure><p>下图展示了缓冲池 BufferPool 的源码：</p><figure><img src="https://javayong.cn/pics/cache/cobarbytebuffer.png?b=2" alt="" tabindex="0"><figcaption></figcaption></figure><p>缓冲池 BufferPool 的核心功能是<strong>分配缓存</strong>和<strong>回收缓存</strong> ，通过将缓存池化，可以大大提升系统的性能。</p><p>如今 ，Netty 内置了更为强大的内存池化工具 ByteBuf ，我们会在后面的文章里详聊。</p><h2 id="_5-写到最后" tabindex="-1"><a class="header-anchor" href="#_5-写到最后" aria-hidden="true">#</a> 5 写到最后</h2><p>这篇文章，笔者总结了四种<strong>强大且低调</strong>的缓存。</p><p>1、HashMap/ConcurrentHashMap 经常用于配置缓存，对于 HashMap 来讲，<strong>HashMap + 读写锁 + 定时任务更新</strong>是常用的模式。而 ConcurrentHashMap 广泛存在于各种中间件，线程安全且灵活易用。</p><p>2、LinkedHashMap 经常被用于创建最近最少使用缓存 LruCache 。推荐学习 Mybatis 二级缓存的设计，它使用<strong>责任链</strong>+ <strong>装饰器</strong>的设计模式，内置 LruCache 的实现就是使用 LinkedHashMap 。</p><p>3、TreeMap 是一种基于红黑树的有序 Map 。TreeMap 在一致性哈希中可以用作节点/虚拟节点的存储结构，用来维护节点在哈希环上的位置和键的有序性。</p><p>4、ByteBuffer 是字节缓冲区，主要用于用户读取和缓存字节数据，多用于网络编程、文件 IO 处理等。分库分表中间件 Cobar 在网络请求处理中，创建了缓冲池 BufferPool 用于池化 ByteBuffer ，从而大大提升系统的性能。</p>',74),i=[n];function s(o,c){return e(),r("div",null,i)}const f=a(p,[["render",s],["__file","01fourJDKlocalcache.html.vue"]]);export{f as default};
