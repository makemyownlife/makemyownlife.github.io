import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as c,o as l,c as u,a as s,d as n,b as e,w as p,e as a}from"./app-9277c8b6.js";const r={},d=a(`<p>最近负责教育类产品的架构工作，两位研发同学建议：“团队封装的<strong>Redis</strong>客户端可否适配<strong>Spring Cache</strong>，这样加缓存就会方便多了” 。</p><p>于是边查阅文档边实战，收获颇丰，写这篇文章，想和大家分享笔者学习的过程，一起品味Spring Cache设计之美。</p><figure><img src="https://www.javayong.cn/pics/temp//RK8gWPf7o2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="_1-硬编码" tabindex="-1"><a class="header-anchor" href="#_1-硬编码" aria-hidden="true">#</a> 1 硬编码</h2><p>在学习Spring Cache之前，笔者经常会硬编码的方式使用缓存。</p><p>举个例子，为了提升用户信息的查询效率，我们对用户信息使用了缓存，示例代码如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>  <span class="token annotation punctuation">@Autowire</span>
  <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>
  <span class="token annotation punctuation">@Autowire</span>
  <span class="token keyword">private</span> <span class="token class-name">StringCommand</span> stringCommand<span class="token punctuation">;</span>
  <span class="token comment">//查询用户</span>
  <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token class-name">String</span> cacheKey <span class="token operator">=</span> <span class="token string">&quot;userId_&quot;</span> <span class="token operator">+</span> userId<span class="token punctuation">;</span>
   <span class="token class-name">User</span> user<span class="token operator">=</span>stringCommand<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> user<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    stringCommand<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cacheKey，user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> user<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">//修改用户</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">updateUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">{</span>
    userMapper<span class="token punctuation">.</span><span class="token function">updateUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> cacheKey <span class="token operator">=</span> <span class="token string">&quot;userId_&quot;</span> <span class="token operator">+</span> userId<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stringCommand<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>cacheKey <span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token comment">//删除用户</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span><span class="token punctuation">{</span>
     userMapper<span class="token punctuation">.</span><span class="token function">deleteUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token class-name">String</span> cacheKey <span class="token operator">=</span> <span class="token string">&quot;userId_&quot;</span> <span class="token operator">+</span> userId<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     stringCommand<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>cacheKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相信很多同学都写过类似风格的代码，这种风格符合面向过程的编程思维，非常容易理解。但它也有一些缺点：</p><ol><li><p>代码不够优雅。业务逻辑有四个典型动作：<strong>存储</strong>，<strong>读取</strong>，<strong>修改</strong>，<strong>删除</strong>。每次操作都需要定义缓存Key ，调用缓存命令的API，产生较多的<strong>重复代码</strong>；</p></li><li><p>缓存操作和业务逻辑之间的代码<strong>耦合度高</strong>，对业务逻辑有较强的侵入性。</p><p>侵入性主要体现如下两点：</p><ul><li>开发联调阶段，需要去掉缓存，只能注释或者临时删除缓存操作代码，也容易出错；</li><li>某些场景下，需要更换缓存组件，每个缓存组件有自己的API，更换成本颇高。</li></ul></li></ol><h2 id="_2-缓存抽象" tabindex="-1"><a class="header-anchor" href="#_2-缓存抽象" aria-hidden="true">#</a> 2 缓存抽象</h2>`,10),k=s("strong",null,"Cache Abstraction",-1),g=a(`<figure><img src="https://www.javayong.cn/pics/temp//ZewikIryyK.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><h3 id="_2-1-spring-aop" tabindex="-1"><a class="header-anchor" href="#_2-1-spring-aop" aria-hidden="true">#</a> 2.1 Spring AOP</h3><p>Spring AOP是基于代理模式（<strong>proxy-based</strong>）。</p><p>通常情况下，定义一个对象，调用它的方法的时候，方法是直接被调用的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token class-name">Pojo</span> pojo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SimplePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 pojo<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://www.javayong.cn/pics/temp//9PtqLGrXss.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>将代码做一些调整，pojo对象的引用修改成代理类。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">ProxyFactory</span> factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProxyFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimplePojo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
factory<span class="token punctuation">.</span><span class="token function">addInterface</span><span class="token punctuation">(</span><span class="token class-name">Pojo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
factory<span class="token punctuation">.</span><span class="token function">addAdvice</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RetryAdvice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">Pojo</span> pojo <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Pojo</span><span class="token punctuation">)</span> factory<span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//this is a method call on the proxy!</span>
pojo<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://www.javayong.cn/pics/temp//y2L0WUBAkn.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>调用pojo的foo方法的时候，实际上是动态生成的代理类调用foo方法。</p><p>代理类在方法调用前可以获取方法的参数，当调用方法结束后，可以获取调用该方法的返回值，通过这种方式就可以实现缓存的逻辑。</p><h3 id="_2-2-缓存声明" tabindex="-1"><a class="header-anchor" href="#_2-2-缓存声明" aria-hidden="true">#</a> 2.2 缓存声明</h3><p>缓存声明，也就是标识需要缓存的方法以及<strong>缓存策略</strong>。</p><p>Spring Cache 提供了五个注解。</p><ul><li>@Cacheable：根据方法的请求参数对其结果进行缓存，下次同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法；</li><li>@CachePut：根据方法的请求参数对其结果进行缓存，它每次都会触发真实方法的调用；</li><li>@CacheEvict：根据一定的条件删除缓存；</li><li>@Caching：组合多个缓存注解；</li><li>@CacheConfig：类级别共享缓存相关的公共配置。</li></ul><p>我们重点讲解：@Cacheable，@CachePut，@CacheEvict三个核心注解。</p><h4 id="_2-2-1-cacheable注解" tabindex="-1"><a class="header-anchor" href="#_2-2-1-cacheable注解" aria-hidden="true">#</a> 2.2.1 @Cacheable注解</h4><p>@Cacheble注解表示这个方法有了缓存的功能。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;user_cache&quot;</span><span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token string">&quot;#userId&quot;</span><span class="token punctuation">,</span> unless<span class="token operator">=</span><span class="token string">&quot;#result == null&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">getUserById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段里，<code>getUserById</code>方法和缓存<code>user_cache</code> 关联起来，若方法返回的User对象不为空，则缓存起来。第二次相同参数userId调用该方法的时候，直接从缓存中获取数据，并返回。</p><p><strong>▍ 缓存key的生成</strong></p><p>我们都知道，缓存的本质是<code>key-value</code>存储模式，每一次方法的调用都需要生成相应的Key, 才能操作缓存。</p>`,22),v={href:"https://docs.spring.io/spring-framework/docs/4.3.x/spring-framework-reference/html/expressions.html",target:"_blank",rel:"noopener noreferrer"},m=a(`<p>若没有指定属性key，缓存抽象提供了 <code>KeyGenerator</code>来生成key ，默认的生成器代码见下图： <img src="https://www.javayong.cn/pics/temp//C4vvh1Bv7s.webp!large" alt=""></p><p>它的算法也很容易理解：</p><ul><li>如果没有参数，则直接返回<strong>SimpleKey.EMPTY</strong>；</li><li>如果只有一个参数，则直接返回该参数；</li><li>若有多个参数，则返回包含多个参数的<strong>SimpleKey</strong>对象。</li></ul><p>当然Spring Cache也考虑到需要自定义Key生成方式，需要我们实现<code>org.springframework.cache.interceptor.KeyGenerator</code> 接口。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Object</span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> params<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后指定@Cacheable的keyGenerator属性。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Cacheable(value=&quot;user_cache&quot;, keyGenerator=&quot;myKeyGenerator&quot;, unless=&quot;#result == null&quot;)
public User getUserById(Long userId) 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>▍ 缓存条件</strong></p><p>有的时候，方法执行的结果是否需要缓存，依赖于方法的参数或者方法执行后的返回值。</p><p>注解里可以通过<code>condition</code>属性，通过Spel表达式返回的结果是true 还是false 判断是否需要缓存。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>cacheNames<span class="token operator">=</span><span class="token string">&quot;book&quot;</span><span class="token punctuation">,</span> condition<span class="token operator">=</span><span class="token string">&quot;#name.length() &lt; 32&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Book</span> <span class="token function">findBook</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段里，当参数的长度小于32，方法执行的结果才会缓存。</p><p>除了condition，<code>unless</code>属性也可以决定结果是否缓存，不过是在执行方法后。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value<span class="token operator">=</span><span class="token string">&quot;user_cache&quot;</span><span class="token punctuation">,</span>key<span class="token operator">=</span><span class="token string">&quot;#userId&quot;</span><span class="token punctuation">,</span> unless<span class="token operator">=</span><span class="token string">&quot;#result == null&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">getUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的代码片段里，当返回的结果为null则不缓存。</p><h4 id="_2-2-2-cacheput注解" tabindex="-1"><a class="header-anchor" href="#_2-2-2-cacheput注解" aria-hidden="true">#</a> 2.2.2 @CachePut注解</h4><p>@CachePut注解作用于缓存需要被更新的场景，和 @Cacheable 非常相似，但被注解的方法每次都会被执行。</p><p>返回值是否会放入缓存，依赖于condition和unless，默认情况下结果会存储到缓存。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@CachePut</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;user_cache&quot;</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">&quot;#user.id&quot;</span><span class="token punctuation">,</span> unless <span class="token operator">=</span> <span class="token string">&quot;#result != null&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">updateUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    userMapper<span class="token punctuation">.</span><span class="token function">updateUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> user<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当调用updateUser方法时，每次方法都会被执行，但是因为unless属性每次都是true，所以并没有将结果缓存。当去掉unless属性，则结果会被缓存。</p><h4 id="_2-2-3-cacheevict注解" tabindex="-1"><a class="header-anchor" href="#_2-2-3-cacheevict注解" aria-hidden="true">#</a> 2.2.3 @CacheEvict注解</h4><p>@CacheEvict 注解的方法在调用时会从缓存中移除已存储的数据。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@CacheEvict</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;user_cache&quot;</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">&quot;#id&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteUserById</span><span class="token punctuation">(</span><span class="token class-name">Long</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    userMapper<span class="token punctuation">.</span><span class="token function">deleteUserById</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当调用deleteUserById方法完成后，缓存key等于参数id的缓存会被删除，而且方法的返回的类型是Void ，这和@Cacheable明显不同。</p><h3 id="_2-3-缓存配置" tabindex="-1"><a class="header-anchor" href="#_2-3-缓存配置" aria-hidden="true">#</a> 2.3 缓存配置</h3>`,25),b=a(`<figure><img src="https://www.javayong.cn/pics/temp//OjMqsOn5dA.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>要使用它们，需要简单地声明一个适当的<code>CacheManager</code> - 一个控制和管理<code>Cache</code>的实体。</p><p>我们以Spring Cache默认的缓存实现<strong>Simple</strong>例子，简单探索下CacheManager的机制。</p><p>CacheManager非常简单：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CacheManager</span> <span class="token punctuation">{</span>
   <span class="token annotation punctuation">@Nullable</span>
   <span class="token class-name">Cache</span> <span class="token function">getCache</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
   
   <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCacheNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在CacheConfigurations配置类中，可以看到不同集成类型有不同的缓存配置类。</p><figure><img src="https://www.javayong.cn/pics/temp//vk9nmlzIbC.webp!large" alt="" tabindex="0"><figcaption>Simple</figcaption></figure><p>通过SpringBoot的自动装配机制，创建CacheManager的实现类<code>ConcurrentMapCacheManager</code>。</p><figure><img src="https://www.javayong.cn/pics/temp//GYJeXgi4Il.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>而<code>ConcurrentMapCacheManager</code>的getCache方法，会创建<code>ConcurrentCacheMap</code>。</p><figure><img src="https://www.javayong.cn/pics/temp//TTOwUF59LP.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p><code>ConcurrentCacheMap</code>实现了<code>org.springframework.cache.Cache</code>接口。</p><figure><img src="https://www.javayong.cn/pics/temp//qd2d2wJdJz.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>从Spring Cache的<strong>Simple</strong>的实现，缓存配置需要实现两个接口：</p><ul><li><p><strong>org.springframework.cache.CacheManager</strong></p></li><li><p><strong>org.springframework.cache.Cache</strong></p></li></ul><h2 id="_3-入门例子" tabindex="-1"><a class="header-anchor" href="#_3-入门例子" aria-hidden="true">#</a> 3 入门例子</h2><p>首先我们先创建一个工程spring-cache-demo。</p><figure><img src="https://www.javayong.cn/pics/temp//QOyVUVjie7.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>caffeine和Redisson分别是本地内存和分布式缓存Redis框架中的佼佼者，我们分别演示如何集成它们。</p><h3 id="_3-1-集成caffeine" tabindex="-1"><a class="header-anchor" href="#_3-1-集成caffeine" aria-hidden="true">#</a> 3.1 集成caffeine</h3><h4 id="_3-1-1-maven依赖" tabindex="-1"><a class="header-anchor" href="#_3-1-1-maven依赖" aria-hidden="true">#</a> 3.1.1 maven依赖</h4><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-cache<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.ben-manes.caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>caffeine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-1-2-caffeine缓存配置" tabindex="-1"><a class="header-anchor" href="#_3-1-2-caffeine缓存配置" aria-hidden="true">#</a> 3.1.2 Caffeine缓存配置</h4><p>我们先创建一个缓存配置类MyCacheConfig。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableCaching</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyCacheConfig</span> <span class="token punctuation">{</span>
  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> <span class="token class-name">Caffeine</span> <span class="token function">caffeineConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>
      <span class="token class-name">Caffeine</span><span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">.</span>
      <span class="token function">expireAfterWrite</span><span class="token punctuation">(</span><span class="token number">60</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MINUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token annotation punctuation">@Bean</span>
  <span class="token keyword">public</span> <span class="token class-name">CacheManager</span> <span class="token function">cacheManager</span><span class="token punctuation">(</span><span class="token class-name">Caffeine</span> caffeine<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">CaffeineCacheManager</span> caffeineCacheManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CaffeineCacheManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    caffeineCacheManager<span class="token punctuation">.</span><span class="token function">setCaffeine</span><span class="token punctuation">(</span>caffeine<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> caffeineCacheManager<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先创建了一个Caffeine对象，该对象标识本地缓存的最大数量是10000条，每个缓存数据在写入60分钟后失效。</p><p>另外，MyCacheConfig类上我们添加了注解：<strong>@EnableCaching</strong>。</p><h4 id="_3-1-3-业务代码" tabindex="-1"><a class="header-anchor" href="#_3-1-3-业务代码" aria-hidden="true">#</a> 3.1.3 业务代码</h4><p>根据<strong>缓存声明</strong>这一节，我们很容易写出如下代码。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Cacheable(value = &quot;user_cache&quot;, unless = &quot;#result == null&quot;)
public User getUserById(Long id) {
    return userMapper.getUserById(id);
}
@CachePut(value = &quot;user_cache&quot;, key = &quot;#user.id&quot;, unless = &quot;#result == null&quot;)
public User updateUser(User user) {
    userMapper.updateUser(user);
    return user;
}
@CacheEvict(value = &quot;user_cache&quot;, key = &quot;#id&quot;)
public void deleteUserById(Long id) {
    userMapper.deleteUserById(id);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码与硬编码里的代码片段明显精简很多。</p><p>当我们在Controller层调用 getUserById方法时，调试的时候，配置mybatis日志级别为DEBUG，方便监控方法是否会缓存。</p><p>第一次调用会查询数据库，打印相关日志：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>Preparing: <span class="token keyword">select</span> * FROM user t where t.id <span class="token operator">=</span> ? 
Parameters: <span class="token number">1</span><span class="token punctuation">(</span>Long<span class="token punctuation">)</span>
Total: <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二次调用查询方法的时候，数据库SQL日志就没有出现了， 也就说明缓存生效了。</p><h3 id="_3-2-集成redisson" tabindex="-1"><a class="header-anchor" href="#_3-2-集成redisson" aria-hidden="true">#</a> 3.2 集成Redisson</h3><h4 id="_3-2-1-maven依赖" tabindex="-1"><a class="header-anchor" href="#_3-2-1-maven依赖" aria-hidden="true">#</a> 3.2.1 maven依赖</h4><div class="language-xml line-numbers-mode" data-ext="xml"><pre class="language-xml"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.Redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>Redisson<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.12.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-2-2-redisson缓存配置" tabindex="-1"><a class="header-anchor" href="#_3-2-2-redisson缓存配置" aria-hidden="true">#</a> 3.2.2 Redisson缓存配置</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Bean(destroyMethod = &quot;shutdown&quot;)
public RedissonClient Redisson() {
  Config config = new Config();
  config.useSingleServer()
        .setAddress(&quot;redis://127.0.0.1:6201&quot;).setPassword(&quot;ts112GpO_ay&quot;);
  return Redisson.create(config);
}
@Bean
CacheManager cacheManager(RedissonClient RedissonClient) {
  Map&lt;String, CacheConfig&gt; config = new HashMap&lt;String, CacheConfig&gt;();
 // create &quot;user_cache&quot; spring cache with ttl = 24 minutes and maxIdleTime = 12 minutes
  config.put(&quot;user_cache&quot;, 
             new CacheConfig(
             24 * 60 * 1000, 
             12 * 60 * 1000));
  return new RedissonSpringCacheManager(RedissonClient, config);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，从Caffeine切换到Redisson，只需要修改缓存配置类，定义<strong>CacheManager</strong> 对象即可。而业务代码并不需要改动。</p><p>Controller层调用 getUserById方法，用户ID为1的时候，可以从Redis Desktop Manager里看到： 用户信息已被缓存，user_cache缓存存储是Hash数据结构。</p><figure><img src="https://www.javayong.cn/pics/temp//dWCrSBzXSc.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>因为Redisson默认的编解码是<strong>FstCodec</strong>， 可以看到key的名称是： \\xF6\\x01。</p><p>在缓存配置代码里，可以修改编解码器。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">RedissonClient</span> <span class="token class-name">Redisson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  config<span class="token punctuation">.</span><span class="token function">useSingleServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">setAddress</span><span class="token punctuation">(</span><span class="token string">&quot;redis://127.0.0.1:6201&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token string">&quot;ts112GpO_ay&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  config<span class="token punctuation">.</span><span class="token function">setCodec</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">JsonJacksonCodec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token class-name">Redisson</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>再次调用 getUserById方法 ，控制台就变成：</p><figure><img src="https://www.javayong.cn/pics/temp//Hh80EPVC0Z.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>可以观察到：缓存key已经变成了：[&quot;java.lang.Long&quot;,1]，改变序列化后key和value已发生了变化。</p><h3 id="_3-3-从列表缓存再次理解缓存抽象" tabindex="-1"><a class="header-anchor" href="#_3-3-从列表缓存再次理解缓存抽象" aria-hidden="true">#</a> 3.3 从列表缓存再次理解缓存抽象</h3><p>列表缓存在业务中经常会遇到。通常有两种实现形式：</p><ol><li>整体列表缓存；</li><li>按照每个条目缓存，通过redis，memcached的聚合查询方法批量获取列表，若缓存没有命中，则从数据库重新加载，并放入缓存里。</li></ol><p>那么Spring cache整合Redisson如何缓存列表数据呢？</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">&quot;user_cache&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">User</span><span class="token punctuation">&gt;</span></span> <span class="token function">getUserList</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Long</span><span class="token punctuation">&gt;</span></span> idList<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">getUserByIds</span><span class="token punctuation">(</span>idList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行getUserList方法，参数id列表为：[1，3] 。</p><figure><img src="https://www.javayong.cn/pics/temp//mOd6M7BgeW.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>`,56),h=s("strong",null,"没有共享",-1),f=a(`<p>这种情况下，缓存的颗粒度控制也没有那么细致。</p><p>类似这样的思考，很多开发者也向Spring Framework研发团队提过。</p><figure><img src="https://www.javayong.cn/pics/temp//UkXRc7g8O2.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><figure><img src="https://www.javayong.cn/pics/temp//XHUWdfuvUv.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>官方的回答也很明确：对于缓存抽象来讲，它并不关心方法返回的数据类型，假如是集合，那么也就意味着需要把集合数据在缓存中保存起来。</p><p>还有一位开发者，定义了一个@<strong>CollectionCacheable</strong>注解，并做出了原型，扩展了Spring Cache的列表缓存功能。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code> <span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span><span class="token string">&quot;myCache&quot;</span><span class="token punctuation">)</span>
 <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">findById</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">//access DB backend return item</span>
 <span class="token punctuation">}</span>
 <span class="token annotation punctuation">@CollectionCacheable</span><span class="token punctuation">(</span><span class="token string">&quot;myCache&quot;</span><span class="token punctuation">)</span> 
 <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">findByIds</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> ids<span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment">//access DB backend,return map of id to item</span>
 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>官方也未采纳，因为<strong>缓存抽象并不想引入太多的复杂性</strong>。</p><p>写到这里，相信大家对缓存抽象有了更进一步的理解。当我们想实现更复杂的缓存功能时，需要对Spring Cache做一定程度的扩展。</p><h2 id="_4-自定义二级缓存" tabindex="-1"><a class="header-anchor" href="#_4-自定义二级缓存" aria-hidden="true">#</a> 4 自定义二级缓存</h2><h3 id="_4-1-应用场景" tabindex="-1"><a class="header-anchor" href="#_4-1-应用场景" aria-hidden="true">#</a> 4.1 应用场景</h3><p>笔者曾经在原来的项目，高并发场景下多次使用多级缓存。多级缓存是一个非常有趣的功能点，值得我们去扩展。</p><p>多级缓存有如下优势：</p><ol><li>离用户越近，速度越快；</li><li>减少分布式缓存查询频率，降低序列化和反序列化的CPU消耗；</li><li>大幅度减少网络IO以及带宽消耗。</li></ol><p>进程内缓存做为一级缓存，分布式缓存做为二级缓存，首先从一级缓存中查询，若能查询到数据则直接返回，否则从二级缓存中查询，若二级缓存中可以查询到数据，则回填到一级缓存中，并返回数据。若二级缓存也查询不到，则从数据源中查询，将结果分别回填到一级缓存，二级缓存中。</p><figure><img src="https://www.javayong.cn/pics/temp//6jIXNdJbHp.webp!large" alt="来自《凤凰架构》缓存篇" tabindex="0"><figcaption>来自《凤凰架构》缓存篇</figcaption></figure><p>Spring Cache并没有二级缓存的实现，我们可以实现一个简易的二级缓存DEMO，加深对技术的理解。</p><h3 id="_4-2-设计思路" tabindex="-1"><a class="header-anchor" href="#_4-2-设计思路" aria-hidden="true">#</a> 4.2 设计思路</h3><ol><li><strong>MultiLevelCacheManager</strong>：多级缓存管理器；</li><li><strong>MultiLevelChannel</strong>：封装Caffeine和RedissonClient；</li><li><strong>MultiLevelCache</strong>：实现org.springframework.cache.Cache接口；</li><li><strong>MultiLevelCacheConfig</strong>：配置缓存过期时间等；</li></ol><p>MultiLevelCacheManager是最核心的类，需要实现<strong>getCache</strong>和<strong>getCacheNames</strong>两个接口。</p><figure><img src="https://www.javayong.cn/pics/temp//MlFyK4WSiF.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>创建多级缓存，第一级缓存是：Caffeine , 第二级缓存是：Redisson。</p><figure><img src="https://www.javayong.cn/pics/temp//JoL5oTXi6y.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>二级缓存，为了快速完成DEMO，我们使用Redisson对Spring Cache的扩展类<strong>RedissonCache</strong> 。它的底层是<strong>RMap</strong>，底层存储是Hash。</p><figure><img src="https://www.javayong.cn/pics/temp//Z4dbRzEVOa.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>我们重点看下缓存的「查询」和「存储」的方法：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ValueWrapper</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> <span class="token function">getRawResult</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">toValueWrapper</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getRawResult</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;从一级缓存查询key:&quot;</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> result <span class="token operator">=</span> localCache<span class="token punctuation">.</span><span class="token function">getIfPresent</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;从二级缓存查询key:&quot;</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    result <span class="token operator">=</span> <span class="token class-name">RedissonCache</span><span class="token punctuation">.</span><span class="token function">getNativeCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        localCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>「<strong>查询</strong>」数据的流程：</p><ol><li>先从本地缓存中查询数据，若能查询到，直接返回；</li><li>本地缓存查询不到数据，查询分布式缓存，若可以查询出来，回填到本地缓存，并返回；</li><li>若分布式缓存查询不到数据，则默认会执行被注解的方法。</li></ol><p>下面来看下「<strong>存储</strong>」的代码：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;写入一级缓存 key:&quot;</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    localCache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;写入二级缓存 key:&quot;</span> <span class="token operator">+</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">RedissonCache</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最后配置缓存管理器，原有的业务代码不变。</p><figure><img src="https://www.javayong.cn/pics/temp//6IEuaPkZ4h.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure><p>执行下getUserById方法，查询用户编号为1的用户信息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>- 从一级缓存查询key:1
- 从二级缓存查询key:1
- <span class="token operator">==</span><span class="token operator">&gt;</span> Preparing: <span class="token keyword">select</span> * FROM user t where t.id <span class="token operator">=</span> ? 
- <span class="token operator">==</span><span class="token operator">&gt;</span> Parameters: <span class="token number">1</span><span class="token punctuation">(</span>Long<span class="token punctuation">)</span>
- <span class="token operator">&lt;=</span><span class="token operator">=</span> Total: <span class="token number">1</span>
- 写入一级缓存 key:1
- 写入二级缓存 key:1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二次执行相同的动作，从日志可用看到从优先会从本地内存中查询出结果。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>- 从一级缓存查询key:1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>等待30s ， 再执行一次，因为本地缓存会失效，所以执行的时候会查询二级缓存</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>- 从一级缓存查询key:1
- 从二级缓存查询key:1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>一个简易的二级缓存就组装完了。</p><h2 id="_5-什么场景选择spring-cache" tabindex="-1"><a class="header-anchor" href="#_5-什么场景选择spring-cache" aria-hidden="true">#</a> 5 什么场景选择Spring Cache</h2><p>在做技术选型的时候，需要针对场景选择不同的技术。</p><p>笔者认为Spring Cache的功能很强大，设计也非常优雅。特别适合缓存控制没有那么细致的场景。比如门户首页，偏静态展示页面，榜单等等。这些场景的特点是对数据实时性没有那么严格的要求，只需要将数据源缓存下来，过期之后自动刷新即可。 这些场景下，Spring Cache就是神器，能大幅度提升研发效率。</p><p>但在高并发大数据量的场景下，精细的缓存颗粒度的控制上，还是需要做功能扩展。</p><ol><li>多级缓存；</li><li>列表缓存；</li><li>缓存变更监听器；</li></ol><p>笔者也在思考这几点的过程，研读了 j2cache , jetcache相关源码，受益匪浅。后续的文章会重点分享下笔者的心得。</p><hr><p>如果我的文章对你有所帮助，还请帮忙<strong>点赞、在看、转发</strong>一下，你的支持会激励我输出更高质量的文章，非常感谢！</p><figure><img src="https://www.javayong.cn/pics/temp//vBrZNjbMur.webp!large" alt="" tabindex="0"><figcaption></figcaption></figure>`,49);function y(w,C){const t=c("font"),o=c("ExternalLinkIcon");return l(),u("div",null,[d,s("p",null,[n("首先需要明确一点：Spring Cache不是一个具体的缓存实现方案，而是一个对"),e(t,{color:"red"},{default:p(()=>[n("缓存使用的抽象")]),_:1}),n("("),k,n(")。")]),g,s("p",null,[n("通常情况下，@Cacheable有一个属性key可以直接定义缓存key，开发者可以使用"),s("a",v,[n("SpEL"),e(o)]),n("语言定义key值。")]),m,s("p",null,[n("Spring Cache是一个对"),e(t,{color:"red"},{default:p(()=>[n("缓存使用的抽象")]),_:1}),n("，它提供了多种存储集成。")]),b,s("p",null,[n("执行完成之后，控制台里可以看到："),e(t,{color:"red"},{default:p(()=>[n("列表整体直接被缓存起来")]),_:1}),n("，用户列表缓存和用户条目缓存并"),h,n("，他们是平行的关系。")]),f])}const _=i(r,[["render",y],["__file","09SpringCache.html.vue"]]);export{_ as default};
