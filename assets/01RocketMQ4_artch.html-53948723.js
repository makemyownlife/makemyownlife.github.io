const e=JSON.parse('{"key":"v-427aecfa","path":"/mq/rocketmq4/01RocketMQ4_artch.html","title":"RocketMQ 整体架构","lang":"zh-CN","frontmatter":{"title":"RocketMQ 整体架构","category":"RocketMQ","tag":["RocketMQ","消息队列"],"head":[["meta",{"name":"keywords","content":"RocketMQ,消息队列,设计,精要,架构"}],["meta",{"name":"description","content":"一本RocketMQ电子书，希望对你有帮助！"}],["meta",{"property":"og:url","content":"https://javayong.cn/mq/rocketmq4/01RocketMQ4_artch.html"}],["meta",{"property":"og:site_name","content":"勇哥Java实战"}],["meta",{"property":"og:title","content":"RocketMQ 整体架构"}],["meta",{"property":"og:description","content":"1 专业术语 Producer 消息生产者，负责产生消息，一般由业务系统负责产生消息。 Consumer 消息消费者，负责消费消息，一般是后台系统负责异步消费。 PushConsumer Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。 PullConsumer Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。 ProducerGroup 一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。 ConsumerGroup 一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。 Broker 消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。 广播消费 一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以认为在消息划分方面无意义。 集群消费 一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个 Consumer Group 有 3 个实例(可能是 3 个进程，或者 3 台机器)，那举每个实例只消费其中的 3 条消息。 顺序消息 消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要是指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。 Message Queue 在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，理论上在 100 年内不会溢出，另外队列中只保存最近几天的数据，之前的数据会按照过期时间来删除。也可以认为 Message Queue 是一个长度无限的数组，offset 就是下标。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-17T07:53:52.000Z"}],["meta",{"property":"article:author","content":"勇哥"}],["meta",{"property":"article:tag","content":"RocketMQ"}],["meta",{"property":"article:tag","content":"消息队列"}],["meta",{"property":"article:modified_time","content":"2023-11-17T07:53:52.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ 整体架构\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-17T07:53:52.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"勇哥\\",\\"url\\":\\"https://javayong.cn/article/\\"}]}"]],"description":"1 专业术语 Producer 消息生产者，负责产生消息，一般由业务系统负责产生消息。 Consumer 消息消费者，负责消费消息，一般是后台系统负责异步消费。 PushConsumer Consumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。 PullConsumer Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。 ProducerGroup 一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。 ConsumerGroup 一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。 Broker 消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。 广播消费 一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以认为在消息划分方面无意义。 集群消费 一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个 Consumer Group 有 3 个实例(可能是 3 个进程，或者 3 台机器)，那举每个实例只消费其中的 3 条消息。 顺序消息 消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要是指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。 Message Queue 在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，理论上在 100 年内不会溢出，另外队列中只保存最近几天的数据，之前的数据会按照过期时间来删除。也可以认为 Message Queue 是一个长度无限的数组，offset 就是下标。"},"headers":[{"level":2,"title":"1 专业术语","slug":"_1-专业术语","link":"#_1-专业术语","children":[]},{"level":2,"title":"2 核心功能","slug":"_2-核心功能","link":"#_2-核心功能","children":[{"level":3,"title":"2.1 发布订阅","slug":"_2-1-发布订阅","link":"#_2-1-发布订阅","children":[]},{"level":3,"title":"2.2 消息优先级","slug":"_2-2-消息优先级","link":"#_2-2-消息优先级","children":[]},{"level":3,"title":"2.3 消息有序","slug":"_2-3-消息有序","link":"#_2-3-消息有序","children":[]},{"level":3,"title":"2.4 消息过滤","slug":"_2-4-消息过滤","link":"#_2-4-消息过滤","children":[]},{"level":3,"title":"2.5 消息持久化","slug":"_2-5-消息持久化","link":"#_2-5-消息持久化","children":[]},{"level":3,"title":"2.6 消息可靠性","slug":"_2-6-消息可靠性","link":"#_2-6-消息可靠性","children":[]},{"level":3,"title":"2.7 低延迟消费","slug":"_2-7-低延迟消费","link":"#_2-7-低延迟消费","children":[]},{"level":3,"title":"2.8 At least Once","slug":"_2-8-at-least-once","link":"#_2-8-at-least-once","children":[]},{"level":3,"title":"2.9 Exactly Only Once","slug":"_2-9-exactly-only-once","link":"#_2-9-exactly-only-once","children":[]},{"level":3,"title":"2.10 Broker 的 Buffer 满了怎么办?","slug":"_2-10-broker-的-buffer-满了怎么办","link":"#_2-10-broker-的-buffer-满了怎么办","children":[]},{"level":3,"title":"2.11 回溯消费","slug":"_2-11-回溯消费","link":"#_2-11-回溯消费","children":[]},{"level":3,"title":"2.12 消息堆积","slug":"_2-12-消息堆积","link":"#_2-12-消息堆积","children":[]},{"level":3,"title":"2.13 分布式事务","slug":"_2-13-分布式事务","link":"#_2-13-分布式事务","children":[]},{"level":3,"title":"2.14 定时消息","slug":"_2-14-定时消息","link":"#_2-14-定时消息","children":[]},{"level":3,"title":"2.15 消息重试","slug":"_2-15-消息重试","link":"#_2-15-消息重试","children":[]}]},{"level":2,"title":"3 架构概览","slug":"_3-架构概览","link":"#_3-架构概览","children":[]}],"git":{"createdTime":1700109645000,"updatedTime":1700207632000,"contributors":[{"name":"makemyownlife","email":"zhangyong7120180@163.com","commits":3}]},"readingTime":{"minutes":15.01,"words":4502},"filePathRelative":"mq/rocketmq4/01RocketMQ4_artch.md","localizedDate":"2023年11月16日","excerpt":"<h2> 1 专业术语</h2>\\n<ul>\\n<li>\\n<p>Producer 消息生产者，负责产生消息，一般由业务系统负责产生消息。</p>\\n</li>\\n<li>\\n<p>Consumer 消息消费者，负责消费消息，一般是后台系统负责异步消费。</p>\\n</li>\\n<li>\\n<p>PushConsumer\\nConsumer 的一种，应用通常向 Consumer 对象注册一个 Listener 接口，一旦收到消息，Consumer 对象立刻回调 Listener 接口方法。</p>\\n</li>\\n<li>\\n<p>PullConsumer</p>\\n<p>Consumer 的一种，应用通常主动调用 Consumer 的拉消息方法从 Broker 拉消息，主动权由应用控制。</p>\\n</li>\\n<li>\\n<p>ProducerGroup</p>\\n<p>一类 Producer 的集合名称，这类 Producer 通常发送一类消息，且发送逻辑一致。</p>\\n</li>\\n<li>\\n<p>ConsumerGroup</p>\\n<p>一类 Consumer 的集合名称，这类 Consumer 通常消费一类消息，且消费逻辑一致。</p>\\n</li>\\n<li>\\n<p>Broker</p>\\n<p>消息中转角色，负责存储消息，转发消息，一般也称为 Server。在 JMS 规范中称为 Provider。</p>\\n</li>\\n<li>\\n<p>广播消费</p>\\n<p>一条消息被多个 Consumer 消费，即使这些 Consumer 属于同一个 Consumer Group，消息也会被 Consumer Group 中的每个 Consumer 都消费一次，广播消费中的 Consumer Group 概念可以认为在消息划分方面无意义。</p>\\n</li>\\n<li>\\n<p>集群消费</p>\\n<p>一个 Consumer Group 中的 Consumer 实例平均分摊消费消息。例如某个 Topic 有 9 条消息，其中一个 Consumer Group 有 3 个实例(可能是 3 个进程，或者 3 台机器)，那举每个实例只消费其中的 3 条消息。</p>\\n</li>\\n<li>\\n<p>顺序消息\\n消费消息的顺序要同发送消息的顺序一致，在 RocketMQ 中，主要是指的是局部顺序，即一类消息为满足顺序性，必须 Producer 单线程顺序发送，且发送到同一个队列，这样 Consumer 就可以按照 Producer 发送的顺序去消费消息。</p>\\n</li>\\n<li>\\n<p>Message Queue\\n在 RocketMQ 中，所有消息队列都是持久化，长度无限的数据结构，所谓长度无限是指队列中的每个存储单元都是定长，访问其中的存储单元使用 Offset 来访问，offset 为 java long 类型，64 位，理论上在 100 年内不会溢出，另外队列中只保存最近几天的数据，之前的数据会按照过期时间来删除。也可以认为 Message Queue 是一个长度无限的数组，offset 就是下标。</p>\\n</li>\\n</ul>","copyright":{"author":"勇哥"},"autoDesc":true}');export{e as data};
