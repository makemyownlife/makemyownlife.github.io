import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as e,e as a}from"./app-9277c8b6.js";const o={},s=a(`<p>RocketMQ 的网络通讯模块负责生产者、消费者与 Broker 之间的网络通信。</p><p>笔者学习 RocketMQ 也是从通讯模块源码开始的，并且从源码里汲取了很多营养。</p><figure><img src="https://javayong.cn/pics/rocketmq/remotingcode.png?a=2" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="_1-网络协议" tabindex="-1"><a class="header-anchor" href="#_1-网络协议" aria-hidden="true">#</a> 1 网络协议</h2><p>客户端和服务端之间完成数据交互，需要约定数据协议。数据协议如下图：</p><figure><img src="https://javayong.cn/pics/rocketmq/remotingprotocol.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>传输内容分为以下四个部分：</p><p><strong>1、消息长度：</strong></p><p>​ 总长度，四个字节存储，占用一个 int 类型；</p><p><strong>2、序列化类型 &amp; 消息头长度：</strong></p><p>​ 占用一个 int 类型，第一个字节表示序列化类型，后面三个字节表示消息头长度；</p><p><strong>3、消息头数据</strong>：</p><p>​ 经过序列化后的消息头数据；</p><p><strong>4、消息主体数据：</strong></p><p>​ 消息主体的二进制字节数据内容。</p><p>消息头数据序列化默认是 <strong>JSON 格式</strong> ，示例如下：</p><figure><img src="https://javayong.cn/pics/rocketmq/remotingheaderdemo.png" alt="" tabindex="0"><figcaption></figcaption></figure><figure><img src="https://javayong.cn/pics/rocketmq/remotingheaderprotocol.png" alt="header格式说明" tabindex="0"><figcaption>header格式说明</figcaption></figure><p>网络协议设计的原则是<strong>便于编解码</strong>，这里我们温习下 TCP <strong>粘包</strong>和<strong>拆包</strong>的知识点。</p><figure><img src="https://javayong.cn/pics/rocketmq/tcp.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>TCP 是面向字节流的协议，它会将应用层发送的数据拆分成 TCP 报文段进行传输，发送端和接收端都会维护一个 buffer ，发送的数据首先会存至缓冲区 buffer ，然后通过网络发送给接收端的 buffer 中。</p><ul><li><strong>粘包</strong></li></ul><p>如果一次请求发送的数据量比较小，没达到缓冲区大小，TCP 则会将多个请求合并为同一个请求进行发送 。</p><ul><li><strong>拆包</strong></li></ul><p>如果一次请求发送的数据量比较大，超过了缓冲区大小，TCP 就会将其拆分为多次发送。</p><p>Netty 通过以下几种方式来解决粘包问题：</p><p><strong>1、消息定长：FixedLengthFrameDecoder</strong></p><p>发送的消息都是固定长度的，接收方根据固定长度来解析消息，这样可以有效避免粘包和拆包问题。</p><p><strong>2、特定分隔符：DelimiterBasedFrameDecoder</strong></p><p>在消息的末尾添加特定的分隔符，接收方根据分隔符来切分消息。</p><p><strong>3、消息头长度：LenghtFieldBasedFrameDecode</strong></p><p>在消息的头部添加表示消息长度的字段，接收方先读取消息头部的长度字段，然后根据长度字段的值来读取消息内容，从而正确地解析出完整的消息。</p><p>RocketMQ 的解码器就是使用了 <strong>LenghtFieldBasedFrameDecode</strong> 。</p><figure><img src="https://javayong.cn/pics/rocketmq/nettydecoder.png" alt="" tabindex="0"><figcaption></figcaption></figure><h2 id="_2-通讯方式" tabindex="-1"><a class="header-anchor" href="#_2-通讯方式" aria-hidden="true">#</a> 2 通讯方式</h2><p>客户端通信方式支持<strong>同步 sync</strong> 、<strong>异步 async</strong> 、<strong>单向 oneway</strong> 三种方式 。</p><figure><img src="https://javayong.cn/pics/rocketmq/clientcode.png?a=12" alt="" tabindex="0"><figcaption></figcaption></figure><h3 id="_2-1-同步-sync" tabindex="-1"><a class="header-anchor" href="#_2-1-同步-sync" aria-hidden="true">#</a> 2.1 同步 sync</h3><p>在同步通信中，客户端发送请求后会一直等待服务器响应，直到接收到响应或者超时。</p><p>这意味着：客户端发送线程在发送请求后会被阻塞，直到收到服务器的响应，然后继续执行发送下一个请求。</p><figure><img src="https://javayong.cn/pics/rocketmq/sync.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>同步请求的流程：</p><p>1、客户端连接服务端，创建 channel ；</p><p>2、客户端创建 responseFutrue 对象 ，主要由四个部分组成：<strong>响应结果、请求编号、回调函数、CountDownLatch</strong>。然后将 responseFutrue 对象加入到本地缓存 响应表 reponseTable 里 。</p><figure><img src="https://javayong.cn/pics/rocketmq/responseFuture.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>3、客户端将请求发送到服务端；</p><p>4、服务端解析出请求命令 ；</p><ol><li>请求命令中包含命令类型、请求编号，服务端根据命令类型选择处理器 ，执行请求命令；</li><li>服务端将响应数据返回给客户端；</li><li>客户端将响应结果填充到响应表 reponseTable 里，同时因为是同步命令，并调用 countDownLatch 的 countDown 方法 , 这样发送消息线程就不再阻塞（<strong>实现同步请求的精髓</strong>）。</li></ol><h3 id="_2-2-异步-async" tabindex="-1"><a class="header-anchor" href="#_2-2-异步-async" aria-hidden="true">#</a> 2.2 异步 async</h3><p>异步通信中，客户端发送请求后不会等待服务器的响应，而是继续执行后续代码。客户端会注册一个回调函数或者监听器，用于处理服务器响应。当服务器响应返回时，会触发回调函数的执行。</p><figure><img src="https://javayong.cn/pics/rocketmq/asyn.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>异步请求的流程 ：</p><p>1、客户端连接服务端，创建 channel ；</p><p>2、通过信号量 <code>semaphoreAsync</code> 限制正在进行的异步请求的最大数量 ;</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> acquired <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>semaphoreAsync<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3、客户端创建 responseFutrue 对象 ，主要由四个部分组成：<strong>响应结果、请求编号、回调函数、CountDownLatch</strong>。然后将 responseFutrue 对象加入到本地缓存 响应表 reponseTable 里 。</p><figure><img src="https://javayong.cn/pics/rocketmq/responseFuture.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>4、客户端将请求发送到服务端，客户端异步方法结束 。</p><p>5、服务端解析出请求命令 ；</p><ol><li>请求命令中包含命令类型、请求编号，服务端根据命令类型选择处理器 ，执行请求命令；</li><li>服务端将响应数据返回给客户端；</li></ol><p>6、通讯框架收到服务端的响应数据后，通过回调线程执行回调函数。</p><h3 id="_2-3-单向-oneway" tabindex="-1"><a class="header-anchor" href="#_2-3-单向-oneway" aria-hidden="true">#</a> 2.3 单向 oneway</h3><p>单向通信发起调用后，不关心调用结果，不做超时控制，只要请求已经发出，就完成本次调用。</p><p>通常用于可以重试，或者定时通知类的场景，调用过程是有可能因为网络问题，机器故障等原因，导致请求失败。业务场景需要能接受这样的异常场景，才可以使用。</p><figure><img src="https://javayong.cn/pics/rocketmq/oneway.png" alt="" tabindex="0"><figcaption></figcaption></figure><blockquote><p>需要注意的是，单向通信不能保证请求一定能够成功发送到服务器，也无法保证服务器是否正确地接收到了请求。</p></blockquote><p>oneway 请求的流程 :</p><p>1、客户端连接服务端，创建 channel ；</p><p>2、通过信号量 <code>semaphoreOneway</code> 限制正在进行的 oneway 请求的最大数量 ;</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">boolean</span> acquired <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>semaphoreOneway<span class="token punctuation">.</span><span class="token function">tryAcquire</span><span class="token punctuation">(</span>timeoutMillis<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span>*<span class="token constant">MILLISECONDS</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>3、客户端将请求发送到服务端，客户端 oneway 请求方法结束 。</p><p>4、服务端解析出请求命令 , 请求命令中包含命令类型、请求编号，服务端根据命令类型选择处理器 ，执行请求命令 , 并不会将响应数据返回给客户端 ；</p><p>下表展示了<strong>同步</strong>、<strong>异步</strong>、<strong>单向</strong>这三种通讯方式的优劣点：</p><table><thead><tr><th><strong>方式</strong></th><th><strong>发送TPS</strong></th><th><strong>发送结果反馈</strong></th><th><strong>可靠性</strong></th></tr></thead><tbody><tr><td>同步</td><td>快</td><td>有</td><td>不丢失</td></tr><tr><td>异步</td><td>快</td><td>有</td><td>不丢失</td></tr><tr><td>单向</td><td>最快</td><td>无</td><td>可能丢失</td></tr></tbody></table><h2 id="_3-reactor多线程设计" tabindex="-1"><a class="header-anchor" href="#_3-reactor多线程设计" aria-hidden="true">#</a> 3 Reactor多线程设计</h2><p>RocketMQ 的通信模块采用 Netty 组件作为底层通信库，同样也遵循了 Reactor 多线程模型，同时又在这之上做了一些扩展和优化。</p><figure><img src="https://javayong.cn/pics/rocketmq/reactor.png?a=12" alt="" tabindex="0"><figcaption></figcaption></figure><p>一个 Reactor 主线程 （ <code>eventLoopGroupBoss</code> ）责监听 TCP网络连接请求，建立好连接，创建 SocketChannel , 并注册到 selector 上。</p><p>RocketMQ 源码会自动根据 OS 的类型选择 NIO 和 Epoll ，也可以通过参数配置 ）， 然后监听真正的网络数据。</p><p>拿到网络数据后，再丢给 Worker 线程池（eventLoopGroupSelector ），再真正执行业务逻辑之前需要进行 SSL 验证、编解码、空闲检查、网络连接管理，这些工作都交给 defaultEventExecutorGroup 去做。</p><p>而业务操作由业务线程池中处理，根据 RemotingCommand 的业务请求编号 requestCode , 从处理器表 processorTable 这个本地缓存中找到对应的处理器 ， 然后封装成 task 任务后，提交到对应的业务处理器的线程池执行。</p><p>从入口到业务逻辑的几个步骤里，线程池一直在增加，这跟每一步步骤逻辑复杂性相关 ，越复杂，需要的并发通道越宽。</p><p>RocketMQ 的线程模型如下所示 ：</p><table><thead><tr><th>线程数</th><th>线程名</th><th>线程具体说明</th></tr></thead><tbody><tr><td>1</td><td>NettyBoss_%d</td><td>Reactor 主线程</td></tr><tr><td>N</td><td>NettyServerEPOLLSelector_%d_%d</td><td>Reactor 线程池</td></tr><tr><td>M1</td><td>NettyServerCodecThread_%d</td><td>Worker线程池</td></tr><tr><td>M2</td><td>RemotingExecutorThread_%d</td><td>业务 processor 处理线程池</td></tr></tbody></table><h2 id="_4-写到最后" tabindex="-1"><a class="header-anchor" href="#_4-写到最后" aria-hidden="true">#</a> 4 写到最后</h2><p>通讯模块核心知识点 ：</p><p>1、网络协议设计原则便于编解码，Netty 的 LenghtFieldBasedFrameDecode 解码器非常容易得解决 TCP 粘包和拆包的问题；</p><p>2、网络通讯框架支持<strong>同步</strong>、<strong>异步</strong>、<strong>单向</strong>这三种通讯方式 ；</p><p>3、理解 Reactor 线程模型很关键 。</p>`,89),p=[s];function r(c,i){return n(),e("div",null,p)}const l=t(o,[["render",r],["__file","01RocketMQ4_network.html.vue"]]);export{l as default};
