import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as s,c as a,e as t}from"./app-1c1562ff.js";const e={},p=t(`<p>很多同学都在使用 RocketMQ 时，经常会遇到消息堆积的问题。这篇文章，我们聊聊消息堆积的概念，以及如何应对消息堆积。</p><figure><img src="https://javayong.cn/pics/rocketmq/messageduiji.png" alt="" tabindex="0"><figcaption></figcaption></figure><h1 id="_1-基础概念" tabindex="-1"><a class="header-anchor" href="#_1-基础概念" aria-hidden="true">#</a> 1 基础概念</h1><p>消费者在消费的过程中，消费的速度跟不上服务端的发送速度，未处理的消息会越来越多，消息出现堆积进而会造成消息消费延迟。</p><p>虽然笔者经常讲：RocketMQ 、Kafka 具备堆积的能力，但是以下场景需要重点关注消息堆积和延迟的问题：</p><ol><li><p>业务系统上下游能力不匹配造成的持续堆积，且无法自行恢复。</p></li><li><p>业务系统对消息的消费实时性要求较高，即使是短暂的堆积造成的消息延迟也无法接受。</p></li></ol><h1 id="_2-消费原理" tabindex="-1"><a class="header-anchor" href="#_2-消费原理" aria-hidden="true">#</a> 2 消费原理</h1><figure><img src="https://javayong.cn/pics/rocketmq/pullmessageandconsume.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>客户端使用 <code>Push 模式 </code>启动后，消费消息时，分为以下两个阶段：</p><ul><li><p>阶段一：<strong>拉取消息</strong></p><p>客户端通过长轮询批量拉取的方式从 Broker 服务端获取消息，将拉取到的消息缓存到本地缓冲队列中。</p><p>客户端批量拉取消息，常见内网环境下都会有很高的吞吐量，例如：1个单线程单分区的低规格机器（4C8GB）可以达到几万 TPS ，如果是多个分区可以达到几十万 TPS 。所以这一阶段一般不会成为消息堆积的瓶颈。</p></li><li><p>阶段二：<strong>消费消息</strong></p><p>提交消费线程，客户端将本地缓存的消息提交到消费线程中，使用业务消费逻辑进行处理。</p><p>此时客户端的消费能力就完全依赖于业务逻辑的复杂度（<strong>消费耗时</strong>）和消费逻辑<strong>并发度</strong>了。如果业务处理逻辑复杂，处理单条消息耗时都较长，则整体的消息吞吐量肯定不会高，此时就会导致客户端本地缓冲队列达到上限，停止从服务端拉取消息。</p></li></ul><p>通过以上客户端消费原理可以看出，消息堆积的主要瓶颈在于本地客户端的消费能力，即<strong>消费耗时</strong>和<strong>消费并发度</strong>。</p><p>想要避免和解决消息堆积问题，必须合理的控制消费耗时和消息并发度，其中消费耗时的优先级高于消费并发度，必须先保证消费耗时的合理性，再考虑消费并发度问题。</p><h1 id="_3-消费瓶颈" tabindex="-1"><a class="header-anchor" href="#_3-消费瓶颈" aria-hidden="true">#</a> 3 消费瓶颈</h1><h2 id="_3-1-消费耗时" tabindex="-1"><a class="header-anchor" href="#_3-1-消费耗时" aria-hidden="true">#</a> 3.1 消费耗时</h2><p>影响消费耗时的消费逻辑主要分为 CPU 内存计算和外部 I/O 操作，通常情况下代码中如果没有复杂的递归和循环的话，内部计算耗时相对外部 I/O 操作来说几乎可以忽略。</p><p>外部 I/O 操作通常包括如下业务逻辑：</p><ul><li>读写外部数据库，例如 MySQL 数据库读写。</li><li>读写外部缓存等系统，例如 Redis 读写。</li><li>下游系统调用，例如 Dubbo 调用或者下游 HTTP 接口调用。</li></ul><p>这类外部调用的逻辑和系统容量需要提前梳理，掌握每个调用操作预期的耗时，这样才能判断消费逻辑中I/O操作的耗时是否合理。</p><p>通常消费堆积都是由于这些下游系统出现了服务异常、容量限制导致的消费耗时增加。</p><p>例如：某业务消费逻辑中需要调用下游 Dubbo 接口 ，单次消费耗时为 20 ms，平时消息量小未出现异常。业务侧进行大促活动时，下游 Dubbo 服务未进行优化，消费单条消息的耗时增加到 200 ms，业务侧可以明显感受到消费速度大幅下跌。此时，通过提升消费并行度并不能解决问题，需要大幅提高下游 Dubbo 服务性能才行。</p><h2 id="_3-2-消费并发度" tabindex="-1"><a class="header-anchor" href="#_3-2-消费并发度" aria-hidden="true">#</a> 3.2 消费并发度</h2><p>绝大部分消息消费行为都属于 IO 密集型，即可能是操作数据库，或者调用 RPC，这类消费行为的消费速度在于后端数据库或者外系统的吞吐量，通过增加消费并行度，可以提高总的消费吞吐量，但是并行度增加到一定程度，反而会下降。</p><p>所以，应用必须要设置合理的并行度。 如下有几种修改消费并行度的方法：</p><ul><li>同一个 ConsumerGroup 下，通过增加 Consumer 实例数量来提高并行度（需要注意的是超过订阅队列数的 Consumer 实例无效）。可以通过加机器，或者在已有机器启动多个进程的方式。</li><li>提高单个 Consumer 实例的消费并行线程，通过修改参数 consumeThreadMin、consumeThreadMax 实现。</li></ul><h1 id="_4-解决策略" tabindex="-1"><a class="header-anchor" href="#_4-解决策略" aria-hidden="true">#</a> 4 解决策略</h1><p>当面对消息堆积问题时，我们需要明确到底哪个环节出现问题了，不要慌张，也不要贸然动手。</p><h2 id="_4-1-确认消息的消费耗时是否合理" tabindex="-1"><a class="header-anchor" href="#_4-1-确认消息的消费耗时是否合理" aria-hidden="true">#</a> 4.1 确认消息的消费耗时是否合理</h2><p>首先，我们需要查看<strong>消费耗时</strong>，确认消息的消费耗时是否合理。查看消费耗时一般来讲有两种方式：</p><p><strong>1、打印日志</strong></p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">ConsumeConcurrentlyStatus</span> <span class="token function">consumeMessage</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">MessageExt</span><span class="token punctuation">&gt;</span></span> msgs<span class="token punctuation">,</span> <span class="token class-name">ConsumeConcurrentlyContext</span> context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">MessageExt</span> messageExt <span class="token operator">:</span> msgs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       			 <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       			 <span class="token comment">// TODO 业务逻辑</span>
      			 logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">&quot;MessageId:&quot;</span> <span class="token operator">+</span> messageExt<span class="token punctuation">.</span><span class="token function">getMsgId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; costTime:&quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">CONSUME_SUCCESS</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;consumeMessage error:&quot;</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token class-name">ConsumeConcurrentlyStatus</span><span class="token punctuation">.</span><span class="token constant">RECONSUME_LATER</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2、查看消息轨迹</strong></p><figure><img src="https://javayong.cn/pics/rocketmq/consumertrackcosttime.png" alt="" tabindex="0"><figcaption></figcaption></figure><p>当确定好消费耗时后，可以根据耗时大小，采取不同的措施。</p><ul><li>若查看到消费耗时较长，则需要查看客户端堆栈信息排查具体业务逻辑，需查看客户端 JVM 的堆栈 。</li><li>若查看到消费耗时正常，则有可能是因为消费并发度不够导致消息堆积，需要逐步调大消费线程或扩容节点来解决。</li></ul><h2 id="_4-2-查看客户端-jvm-的堆栈" tabindex="-1"><a class="header-anchor" href="#_4-2-查看客户端-jvm-的堆栈" aria-hidden="true">#</a> 4.2 查看客户端 JVM 的堆栈</h2><p><strong>假如消费耗时非常高，需要查看 Consumer 实例 JVM 的堆栈 。</strong></p><ol><li><p>通过 <code>jps -m</code> 或者 <code>ps -ef | grep java</code> 命令获取当前正在运行的 Java 程序，通过启动主类即可获得应用的进程 pid ;</p></li><li><p>通过 <code>jstack pid &gt; stack.log</code> 命令获取线程的堆栈。</p></li><li><p>执行以下命令，查看 <code>ConsumeMessageThread</code> 的信息 。</p></li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">cat</span> stack.log <span class="token operator">|</span> <span class="token function">grep</span> ConsumeMessageThread <span class="token parameter variable">-A</span> <span class="token number">10</span> <span class="token parameter variable">--color</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>常见的异常堆栈信息如下：</p><ul><li><p>示例1：<strong>空闲无堆积的堆栈</strong> 。</p><p>消费空闲情况下消费线程都会处于 <code>WAITING</code> 状态等待从消费任务队里中获取消息。</p></li></ul><figure><img src="https://javayong.cn/pics/rocketmq/waiting.png" alt="" tabindex="0"><figcaption></figcaption></figure><ul><li><p>示例2：<strong>消费逻辑有抢锁休眠等待等情况</strong> 。</p><p>消费线程阻塞在内部的一个睡眠等待上，导致消费缓慢。</p></li></ul><figure><img src="https://javayong.cn/pics/rocketmq/time_waiting.png" alt="" tabindex="0"><figcaption></figcaption></figure><ul><li><p>示例3：<strong>消费逻辑操作数据库等外部存储卡住</strong> 。</p><p>消费线程阻塞在外部的 HTTP 调用上，导致消费缓慢。</p><figure><img src="https://javayong.cn/pics/rocketmq/runnable.png" alt="" tabindex="0"><figcaption></figcaption></figure></li></ul><h1 id="_5-总结" tabindex="-1"><a class="header-anchor" href="#_5-总结" aria-hidden="true">#</a> 5 总结</h1><p>客户端使用 <code>Push模式 </code>启动后，消费消息时，分为以下两个阶段：<strong>拉取消息</strong>和<strong>消费消息</strong>。</p><p>客户端消费原理可以看出，消息堆积的主要瓶颈在于本地客户端的消费能力，即<strong>消费耗时</strong>和<strong>消费并发度</strong>。</p><p>当遇到堆积问题，首先分析消费耗时，然后根据耗时大小，采取不同的措施。</p><ul><li>若查看到消费耗时较长，则需要查看客户端堆栈信息排查具体业务逻辑，需查看客户端 JVM 的堆栈 。</li><li>若查看到消费耗时正常，则有可能是因为消费并发度不够导致消息堆积，需要逐步调大消费线程或扩容节点来解决。</li></ul><hr><p>参考文档：</p><blockquote><p>万字长文讲透RocketMQ 消费逻辑：</p><p>https://mp.weixin.qq.com/s/mlqhXCHfhEht7je8n0rArA</p><p>阿里云官方文档：</p><p>https://help.aliyun.com/zh/apsaramq-for-rocketmq/cloud-message-queue-rocketmq-4-x-series/use-cases/message-accumulation-and-latency#concept-2004064</p></blockquote>`,52),o=[p];function c(i,l){return s(),a("div",null,o)}const d=n(e,[["render",c],["__file","12RocketMQ4_messagecumulate.html.vue"]]);export{d as default};
